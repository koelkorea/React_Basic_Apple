 - react 사전이해에 필요한 JS지식

  @ 구조 분해 할당(destructuring assignment)?
     : ECMA6에서 새로 공개된 배열 또는 객체의 속성을 쉽게 추출하여 개별 단일 변수에 할당하는 방법으로.. 
       -> 배열이나 객체의 요소를 일일히 접근하여 변수에 할당하는 대신, 구조 분해 할당을 사용하여 한 번에 여러 변수에 값을 할당 가능 + []와 {}의 차이만 있을 뿐, 문법이 서로 비슷함
           -> 해당 컴포넌트의 지역변수 역할을 하는 state에 get, set 로직을 구현하는데 사용됨

       ex) 배열 구조 분해 할당
           const numbers = [1, 2, 3, 4, 5];
           const [a, b, ...rest] = numbers;         <- numbers의 배열요소의 값들을 각 개별변수에 일괄적으로 대입 가능
           const [e, f] = numbers;                  <- (중요) 값을 제공하는 배열 numbers의 요소의 개수 > 값을 받는 배열의 개수?
                                                         : 이 경우는 1, 2만 e, f에 대입
           console.log(a);    // 1
           console.log(b);    // 2
           console.log(rest); // [3, 4, 5]
           console.log(e);    // 1
           console.log(f);    // 2

        ex) 객체 구조 분해 할당
           const person = { name: 'John', age: 30, city: 'New York' };
           const { name, age, city } = person;      <- 객체 person의 멤버변수 값들을 각 개별변수에 일괄적으로 대입 가능
           console.log(name); // 'John'
           console.log(age);  // 30
           console.log(city); // 'New York'


  @ 스프레드 문법(spread syntax)
     : '...배열명 or 객체명'을 통해, 배열(array)이나 객체(object)에 존재하는 각 요소 또는 멤버변수들을 해당 컨테이너명을 사용하여 개별적인 값으로 쉽게 확장하는 작성하는 역할을 수행하는 문법
        (= 이걸 쓰면 귀찮게 배열, 객체의 각 모든 요소들을 일일히 기입하지 않아도 되며, 함수의 선언부에 parameter의 갯수에 따른 오버로딩 또한 노가다 없이 rest parameter형식으로 작성가능하게 해줌)
            -> 다시 말해 배열, 객체의 깊은 복사가 쉬워짐
               ex) const numbers = [1, 2, 3];
                   const copiedNumbers = [...numbers];
                   console.log(copiedNumbers); // [1, 2, 3]
                   const person = { name: 'John', age: 30 };
                   const copiedPerson = { ...person };
                   console.log(copiedPerson); // { name: 'John', age: 30 }


  @ html 이벤트핸들러 속성
    : js의 이벤트핸들러를 html에서 사용가능하게 속성으로 구현한 것.. 속성값으로는 행동 function명이나, 익명함수로 원하는 로직을 입력함녀 됨. onClick이 대표적


  @ 일급 객체 function
    : js의 function이란 변수에 대입이 가능하며, 다른 함수의 return으로 가능한 대상이자, 다른 함수의 parameter로도 사용이 가능함
      (= 특정 변수에 익명함수를 입력해서 저장시키거나, 다른 함수를 대입하는 것도 가능하며, callback 함수를 사용가능한 근원이 되는 js의 특성임)


  @ array/object를 다룰 때의 주의사항
    1. 배열명 / 객체명 그들 자신 자체는 reference 타입의 변수
       (= 배열요소 / 객체맴버변수 데이터를 보존하는게 아니라, 해당 배열이나 객체가 어떤 메모리 주소에 위치해 있는지에 대한 위치값(= 포인터)을 가지고 있음)
           -> 그래서, 'let 변수명 = 배열/객체명;' 과 같은 식의 코드는 의도대로 배열이나 객체의 값이 변수명에 복사되지 않고, 배열/객체명의 메모리 주소를 대입하는 '얕은 복사'가 실행됨
 
    2. 배열 / 객체는 다룰 때 원본을 보존하는 것이 좋기에, 완전히 다른 메모리주소를 할당한 후 값을 할당하는 '깊은 복사'를 쓰는게 좋음    
    3. js의 객체 내부의 멤버표기법은 2가지가 존재함
        ex) obj.member == obj["member"]

        - 일반적인 객체 멤버 표기법
           : 객체명.멤버변수명 or 멤버함수명(parameter);

        - js만의 유사 array스런 특수한 객체 내부 멤버표기법
           : 객체명[멤버변수명 or 멤버함수명(parameter)]
              -> 배열명[index]와 유사.. 
                   -> (중요) react에서는 return문에 html영역값을 가지는 멤버변수들을 가진 객체를 호출하고, [변수명]을 통해 특정 변수명 안에 있는 값과 일치하는 객체의 멤버변수가 가지는 값을 호출하여 조건문처럼 사용이 가능함
                        -> 유사 클로저(closure)라고 생각하면 편함 (= 은근히 구조가 복잡함)

             ex) var 탭UI = { 
                   info : <p>상품정보</p>,
                   shipping : <p>배송관련</p>,
                   refund : <p>환불약관</p>
                 }
                 
                 function Component() {
                   var [현재상태, 현재상태설정] = useState('info');
                   return (
                     <div>
                       { 탭UI[현재상태] }
                     </div>
                   )
                 }    


  @ 3항 연산자(ternary operator)
    : '조건식 ? true일시의 실행 : false일시의 실행' 형식으로 작성하는 조건문... 
        -> 이를 사용하면, if else if else 범벅보다, 1줄로 간편하면서도 때때로 직관적인 코드를 짤 수 있음
  

  @ 논리 부정 연산자 !
     : true, false의 각자 반대값을 출력하도록 함
 

  @ 배열object의 멤버함수 map
     1. [요소1, 요소2, ... , 요소n].map( function() { 내용 } )
         : 해당 배열 요소들의 개수만큼, 내부 무명함수의 내용을 반복해 줌

     2. [요소1, 요소2, ... , 요소n].map( function() { return '내용' )
         : 해당 배열 요소들의 개수만큼, 해당 횟차만큼의 index 위치에 있는 배열요소에 return에 존재하는 '내용'을 기입

           ex) [1,2,3].map(function(){
                 return 123           <- 123을 배열의 index마다 반복해서 기입 [123, 123, 123]
               });
 
     3. [요소1, 요소2, ... , 요소n].map( function(변수a) { 내용(변수a를 사용) } )
         : 해당 배열 요소들의 개수만큼, 내부 무명함수의 내용을 반복하되, 변수a에 해당하는 부분은 해당 횟차만큼의 index 위치에 있는 배열요소를 사용함

           ex) [1,2,3].map(function(a){
                 console.log(a);          <- 1, 2, 3을 log에 순차적으로 출력
               });

     4. [요소1, 요소2, ... , 요소n].map( function(변수a) { return (변수a를 사용) } )
         : 해당 배열 요소들의 개수만큼, 내부 무명함수의 내용을 반복하되, return에 해당하는 부분도 변수a에 해당하는 부분은 해당 횟차만큼의 index 위치에 있는 배열요소를 사용함

           ex) [1,2,3].map(function(a){
                 return a*100            <- 각 배열의 index에 위치한 요소 * 100에 해당하는 값을 배열의 각 index에 반복해서 기입 [100, 200, 300]
               });

     5. [요소1, 요소2, ... , 요소n].map( function(변수a, 변수i) { 내용(변수a와 i를 사용) } )
         : 해당 배열 요소들의 개수만큼, 내부 무명함수의 내용을 반복하되, 변수a에 해당하는 부분은 해당 횟차만큼의 index 위치에 있는 배열요소를 사용 + 변수i는 해당 index에 번호를 사용함
 
           ex) [1,2,3].map(function(a, i){
                 return a*i              <- 각 배열의 index에 위치한 요소 * 각 index의 값에 해당하는 값을 각 index에 반복해서 기입 [1, 4, 9]
               });


  @ HTML 이벤트핸들러 속성
     : HTML에는 자체적인 명세서에 동적인 웹페이지를 구성하도록 하기 위한, js의 자주 쓰이는 이벤트핸들러들을 DOM 속성 형식으로 쉽게 쓸 수 있기 지원함
        -> 이벤트핸들러가 전역변수로 노출 + 복수 이벤트핸들러를 설정하는 문법이 X + 사용자 정의 이벤트를 설정 불가능.. 이 3콤보로 요즘은 사장..
            -> 그렇지만 react에서는 이러한 형식의 친숙함을 차용하여, react방식의 매커니즘에서도 dom조작 없이 state의 변경을 통한 이벤트를 구현하였음
                -> 단! 이미 html DOM기반 이벤트핸들러는 존재하기에, 기존에 존재한 이벤트핸드러 속성을 'camalCase' 형식으로 표기하여 동일한 속성을 피함
                    -> 물론! 그렇다고, onClick으로 구현한 react의 유사 이벤트핸들러의 구현이 onclick과 절대 같지는 않음
                       (= 아마, 형식만 html DOM기반 이벤트핸들러 형식으로 작성된 react 이벤트 속성이 감지되면, 내부적으로 구현되는 로직이 존재할듯)


  @ 이벤트 객체 e
     : 이벤트핸들러에 들어가는 함수에 넣는 parameter로, 이는 객체로서 현재 발생하는 이벤트와 관련한 유용한 기능들을 제공하는 일종의 변수로 생각하면 됨
        - e.target            : 현재 이벤트가 발생한 곳을 알려줌
        - e.target.value      : 현재 이벤트가 발생한 곳의 값을 출력함
        - e.preventDefault()  : 해당 이벤트의 기본 동작을 막아줌
        - e.stopPropagation() : 가장 최상단의 조상 HTML DOM요소부터 해당 HTML DOM요소에 접근하는 호출 stack을 구성해 위치를 찾은 후, stack을 해제하는 과정에서 접근하게 되는 부모 HTML요소도 같은 이벤트핸들러의 내용을 작동시키게 되는 버블링을 막아줌

  @ 이벤트버블링
     : 어떤 HTML 요소에 이벤트가 발생하여 이벤트핸들러가 동작하고, 이어서 부모 요소부터 가장 최상단의 조상 요소에 이르기까지 같은 종류의 이벤트핸들러가 동작하는 개념을 의미
        -> HTML 요소 접근을 위한 stack 회수 과정에서 구현하였기에, 편도행에는 문제가 생기게 하지 않을 수 있다고 생각함
           (= e.stopPropagation()을 통해, 본 이벤트 발생 이후의 다른 HTML DOM요소들의 이벤트의 통제 또한 가능함)


  @ object(객체) 타입
     : js의 자료형 중 하나로 '속성 : 속성값 = key : value'구조를 가지는 멤버들이 여러개로 구성되어 있는 일종의 구조체(construct) 같은 자료형
        -> let 객체명 = {속성1 : 속성값, ... , 속성n : 속성값n} 형식으로 작성

      # (주의) react에서는 render할 component에 있는 출력값이 object 타입이면, 에러를 뿜으니... 유의하도록 하자 


  @ 스코프(Scope) 개념
     : 프로그래밍 언어에서 변수나 함수가 사용가능한 결계를 설정하여 위해 사용하는 개념으로.. 이를 바탕으로 변수나 함수, 객체들이 영역을 명확히 할 수 있는 '지역XX' 개념이나 '캡슐화' 등의 개념을 활용가능
        -> 이 결계(영역)을 바탕으로 클로저 로직이 시작되기에 엄청 중요...!
        
      # 함수의 스코프(Scope)를 정하는 기준
         1. 렉시컬 스코프(Lexical Scope) = 정적 스코프(Static Scope)
             : 함수가 어디에 '선언'되었는지에 따라 변수의 스코프가 정적으로 결정되는 것을 의미
               (= 다시 말해, 신분제처럼 함수는 작성되는 순간부터 자신의 소속 {}영역이 정해지는 걸 의미함)
                   -> (중요) 클로저(Closure)는 이에 따르면, 자신이 생성될 때의 환경(렉시컬 스코프)을 기억하는 함수로 정의가 가능!

         2. 동적 스코프(dynamic Scope) <->  렉시컬 스코프(Lexical Scope)
             : 함수가 '호출'하였는지에 따라 변수의 스코프가 동적으로 결정되는 것을 의미
                -> (주의) 단.. 일부 언어만 따르는 기준임

      # EMCA5 까지의 변수의 스코프(Scope)
         : EMCA5 까지는 var 타입 변수를 쓰는데, 이 녀석의 통용 범위는 function의 {}이 기준이 됨..
           (= for나 if같은 조건문의 {}는 전혀 스코프의 영역조차 되지 못함)
               -> EMCA6 이후, 블럭 스코프(block scope)의 등장과 let 변수의 등장 이유

      # EMCA6부터의 변수의 스코프(Scope)
         : 지역변수적 요소를 구현하고자 임의적으로 유저는 {}를 통해 결계로 구분되는 영역을 만들수 있게 되고. 그 안에 쓰는 변수 let 혹은 const는 그 안에서만 통용되는 지역변수처럼 적용됨
           (= 이를 통해 드디어 js는 for나 if같은 조건문의 {}를 지역변수를 위한 영역으로 구별할 수 있게 됨)


  @ 클로저(closure)개념
     : 포함한다(enclose)라는 개념에서 온 용어로.. js의 함수의 경우 자기 자신의 {} 영역(scope)을 가지고 있지만, 다른 한편으로는 자신의 선언 당시 포함된 환경(렉시컬 스코프)인 {}영역(scope)이 어디인지까지 또한 포함해서(enclose) 기억하는 특성을 의미하는 개념...
       (= 그렇기에, 자신을 감싼 {}영역 안의 변수나 객체를 기억하고, 심지어 내부함수라면 외부함수의 실행이 끝나도 외부함수의 변수에 접근이 가능함을 의미하다는 걸 알 수 있음)
           -> (중요) 이 특성이.. 'js의 1급 객체 함수' 개념과 '렉시컬 스코프(Lexical Scope)' 개념과 결합하면 어마어마한 모듈 패턴을 만들어 낼 수 있음  

      # 주의점
         : 클로저(closure) 사용을 통한 내부함수의 외부변수 참조가 시작되면, 설령 외부함수의 실행이 끝나더라도 가비지 콜렉터에 의해 메모리가 해제되지 않음
            -> (중요!) 클로저를 할당한 변수에 null을 할당해줌으로써 메모리를 해제

            ex) const outerFunc = () => {
                		let x = 10;

                		const innerFunc = (y) => {
                				x = x + y;
                				console.log(x);
                		}
                		return innerFunc;
                }
                let addFunc = outerFunc();
                addFunc(5);
                addFunc = null;        <- 메모리 회수 가능 지점

      # 클로저(closure) 응용사례
         1) 함수를 통한 캡슐화와 은닉화
             : 무명함수를 통해서 getter, sette 등을 흉내낼 수 있음

               ex) const user = () => {
                   		let userName = ''; // private
                   
                   		return {
                   				getUserName: function() {
                   						return userName;
                   				},
                   				setUserName: function(_userName) {
                   						userName = _userName;
                   				}
                   		};
                   }
                   
                   const user1 = user();
                   user1.getUserName(); 
                   user1.setUserName('Chojs');
                   user1.getUserName(); 

         2) 부분 적용 함수 구현 가능
             : return에 독립적인 무명함수를 반환하는 경우라도, 외부 함수의 변수를 클로저 개념을 통해 끝까지 참고 가능하기에..
               (= parameter의 일부는 나중에 받아 처음에는 null로 나중에 값을 받음으로최종적인 결과만 출력하게 할 수 있음)
                   -> react의 state가 로딩이 되기 전까지 null로 유지했다, 값 받으면 다른거로 바뀌게 하는거도 이런 지연 실행적 특성에 기인

         3) 커링(curring) 함수(function(a, b, c) ->  function(a)(b)(c)로 실행가능하게 함)를 구현 가능
             : 부분 적용 함수 구현과 마찬가지로 결국 일부 paramter를 나중에 받는걸 순차적으로 받아 지연 실행하는거로 바꾼거와 같음
                -> 2)번과 연계하여, 중간의 값에 따라 출력값을 바꿔 보내는 '미들웨어'와 '로그'의 구현에도 기여

                ex) const reduxThunk = (store) => (next) => (dispatch) => {
		                  return typeof action === "function" ? 
                        action(dispatch, store.getState) : next(action);
                    }
 
  @ 1급 객체(first-class object)
     : 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체라는 의미로 객체의 권한이나 호환성 관련된 프로그래밍적 개념
       (= js의 함수는 기본적으로 일반 변수와 같은 방식으로 사용이 가능해, 어마어마한 경우의 수로 응용이 가능함)

      # 1급 객체(first-class object)라면 가능한 4가지의 특성
         1. 변수에 할당될 수 있는 타입의 객체 (= js에서는 함수도 변수에 할당해서 쓸 수 있음)
         2. 함수 호출시 parameter로 전달 가능 (= 그래서 js에서 callback이나 무명함수를 연계시켜 실행도 가능)
         3. 함수의 return 문에 가입가능 (= 기본적인 함수간 연쇄작용이 가능함... 특히 2번 특성과 결합하면...)
         4. 동적으로 생성 및 파괴가 가능


  @ js 모듈러 시스템
     : HTML의 script 태그에서 다른 스크립트 파일들을 src속성을 통해 불러올 때, 해당 script 코드들이 1개의 단일영역에 적혀있는 것처럼 작동하는 것을 막고, js 모듈을 기준으로 '블럭 스코프'(block scope)와 같은 판정이 생겨서, 그 안에서 선언한 변수는 그 안에서만 사용이 가능하게 하는 시스템
         -> 다시 말해, Class 내 변수를 쓰려고 할 때 이들을 불러오는 문법이 있듯, 모듈 내의 변수들을 구분해서 불러오는 구문이 따로 필요하다는 것 의미
             -> 이렇게 js의 모듈을 불러오는 방식을 '모듈 시스템(module system)'으로 명칭함

      # 블럭 스코프(block scope)
        : js(es6 이후로 추정)에서 지역변수적 요소를 구현하고자 쓰는 결계로 그 안에 쓰는 변수 let 혹은 const는 그 안에서만 통용되는 지역변수처럼 적용됨
           -> {}를 통해 결계를 치고, 그 안에 쓴 변수 let 혹은 const는 그 안에서만 통용되는 지역변수화가 됨 (반대로, 안에서는 전역변수들을 만나는게 가능한 함수에서의 {}와 같음)
              (단! var는 그런거 적용 안 되니 쓰지 않도록 한다)

      # 자주 사용되는 2가지의 모듈 시스템
         1. ES Module (사실상의 승자)
             : JS ES6(ES2015)에 도입된 자바스크립트 자체의 모듈 시스템 방식 (과거 제작된 react에서 많이 보이는 녀석)
                -> (중요) NodeJS 13.2부터 ES모듈 시스템에 대한 정식 지원이 시작 = node.js에서도 babel같은거 없이 사용 가능 
                      -> package.json에서 type = "module" 선언화면 바로 사용 가능하게 조치 
                         (= package.json와 연관있는 react 또한 이를 사용함을 유추 가능...)
                             ->  정확히는 함수 component를 쓸 때, 해당 기능을 강화시키는 hooks 모듈을 불러올 때 사용)

              - ES Module 사용법
                : (from 사용할 모듈) export 구문을 입력 -> (to 가져오는 파일) import구문을 통해 불러옴

                1) ES Module 내보내기 : export 구문

                    a. export default 내보내고 싶은 변수명;
                        : import시 특별한 변수명을 적지 않으면(= 보통 import a구문 사용시), 이 때 지명한 변수를 가져옴
                          (단! 한번 사용 가능함.. 기본으로 출력할 변수를 부르기 때문)

                    b. export default { 내보내고 싶은 변수명(여러개도 가능) };
                        : import시 특별한 변수명을 적지 않으면(= 보통 import a구문 사용시), 이 때 지명한 변수들을 가져옴
                          (a와 마찬가지로 한번 사용 가능함.. 기본으로 출력할 변수를 부르기 때문)

                    c. export let(const) 내보내고 싶은 변수명;
                        : 이를 통해 여러개의 변수들을 직관적으로 지명 가능
                            -> 그나마 가장 범용성이 좋은 방법 

                2) ES Module 불러오기 : import 구문

                    a. import 지은 변수명 from '불러오는 모듈 경로'
                        : 모듈에서 변수 하나만 가져오는 방법  
                            -> export defalut {여려변수들} 을 사용한다면, b구문처럼 '지은 변수명'을 객체명처럼 사용 가능 

                    b. import * as 지은 변수명 from '불러오는 모듈 경로';
                        : 모듈에서 모든 변수를 가져오는 방법 
                          (*의 의미 : SQL에서 모든 변수 가져오는것 의미.. -> 이걸 '지은 변수명'으로 통칭해 객체명화 하는 것)
                            -> '별칭.프로퍼티' or '별칭.메서드명(파라미터....)'' 를 통해 값을 지칭해서 불러옴

                    c. import { 가져올 변수명(여러개도 가능) } from '불러오는 모듈 경로';
                        : 모듈에서 1개 ~ 여러개 변수를 가져오는 방법
                            -> 그나마 가장 범용성이 좋은 방법 

         2. CommonJs
             : NodeJS 환경에서 자바스크립트 모듈을 사용하기 위해 만들어진 모듈 시스템 
                -> 일부 내용은 ES Module과 기능상 호환되는 부분이 존재함

              - CommonJs 사용법
                 : (from 사용할 모듈) 사용할 변수 앞에 export.변수명 입력 or module.export { } 구문 입력- > (to 가져오는 파일) require('파일경로'); 구문을 통해 불러옴

                 1) CommonJs 모듈 내보내기 : export.변수명 및 module.export 구문

                     a. export.내보내고 싶은 변수명;
                         : 내보내고 싶은 js 변수 앞에 'export.' 를 일일히 붙여서 모듈의 변수로서 블록 스코프에 넣는 것으로 판정 

                     b. module.export { 내보내고 싶은 변수명(여러개도 가능) };
                         : 이를 통해 여러개의 변수들을 직관적으로 지명 가능
                             -> 그나마 가장 범용성이 좋은 방법 

                 2) CommonJs 모듈 불러오기 : require 구문

                     a. let or const { 불러오고 싶은 변수명(여러개도 가능) } = require('파일경로');
                         : 모듈에서 1개 ~ 여러개 변수를 가져오는 방법
                             -> 그나마 가장 범용성이 좋은 방법 

                     b. let or const 지은 변수명(= 별칭) = require('파일경로');
                         : 모듈에서 모든 변수를 '지은 변수명'으로 통칭해 객체명화 하여 가져오는 방법 
                             -> '별칭.프로퍼티' or '별칭.메서드명(파라미터....)'' 를 통해 값을 지칭해서 불러옴  


  @ (중요) Concurrency(동시성) & Parallelism(병렬성)
     : 여러가지의 프로그래밍 작업의 동시 수행에 대한 프로그래밍 개념으로... 논리적 vs 물리적인 관점으로 구분된 용어
        -> 각각 '비동기 작업처리', '병렬 작업처리'의 개념과 직결되는 관련성이 있는 용어로 제대로 모르면, 두 처리방식의 차이점을 알수 없음
           (= 이 두가지 방식은 시스템을 구성할 때 양립불가능한 요소가 아니라는 점 명심)

       1. Concurrency(동시성) => (중요) [비동기 작업 처리]와 연관
           : 여러가지의 프로그래밍 작업을 동시에 수행하는 것에 대한 논리적인 개념
              -> 비동기적으로 빠르게 프로세스 및 컨텍스트들을 전환하며 여러 작업을 수행하면? 거의 동시에 여러 작업이 실행되는 것으로 보여짐
                 (= 사실 비동기 작업처리는 운영체제의 복잡 정교한 스케줄링 정책에 의해 실행되는 방식으로, 물리적으로 동시적 프로그래밍 작업을 수행하진 않기에 논리적인 동시적 작업을 충족하여 Concurrency한 task로 인정)

                 ex) 프로세서의 프로세스 스케쥴링(process scheduleing), 쓰레드의 컨텍스트 스위치(context switch)
                     
       2. Parallelism(병렬성) => (중요) [병렬 작업 처리]와 연관
           : 여러가지의 프로그래밍 작업을 동시에 수행하는 것에 대한 물리적인 개념
              -> 실제로도 완벽하게 동시에 프로그래밍 작업이 수행하는 경우에만 한정함

                 ex) 멀티 CPU코어(Multi-Processor), 멀티 쓰레드(Multi-thread)를 통한 다중 프로세싱 (Multiprocessing), 다중 쓰레딩 (Multithreading)


      # 컨택스트(context)                     vs          쓰레드(thread)
        - 동시성(concurrency) 관여                        - 병렬성(Parallelism) 관여 + 동시성(concurrency)도 부분적 강화
        - 비동기적 작업 처리                               - 멀티 쓰레드(multi thread)를 통한 병렬 처리
        - 실행 중 프로세스, 스레드의 상태 정보              - 프로세스 내에서 실행되는 독립적인 실행 단위


      # 동기화 문제
         : Concurrency(동시성) & Parallelism(병렬성)한 task에서나 둘 다 동시기에 공유된 자원에 경쟁적으로 접근(race condition)하게 되었을떄, 작업 과정 자체가 매번 달라지고 작업 결과의 신뢰성에 문제가 발생
            -> 세부적 분류
               1) 어떻게 프로세스 간 공유 자원(프린터,통신망 등)을 배타적(한 순간에 1개의 프로세스 만 사용)으로 사용하게 할거냐?
                  (= 어떻게 화장실에 1명만 들어가게 할거냐?)
                    -> 공유변수구역 or 임계구역(critical section) 의 상호배제(mutual exclusion) 문제 
                     
               2) 혹시라도 두 프로세스가 서로 다음 작업이 서로 점유중인 공유변수구역을 필요로 해서, 병행 프로세스의 다음 작업 자체가 진행이 안된다면 어쩔거냐?
                  (= 혹시라도 1명만 들어가야 하는 샤워실, 화장실에 들어간 사람들이 다음에 들어갈 곳이 서로가 있는 곳일떄는 어떻게 위치 교환을 하게 할거냐?)
                    -> 교착상태 (Deadlock) 문제

               3) 그렇다면 어떤 식으로 다수의 프로세스들에게 명령을 전달하여 1), 2)의 문제를 피하고자 할거냐?
                  (= 사람들을 어떤식으로 통제해서, 화장실을 질서정연하게 이용하게 할거냐?)
                    -> 자료 교환을 위한 메세지 전달 방식 상의 통신 (Communication) 문제

               4) 실행 과정이 약간 변동이 생겨도 작업 결과의 신뢰성은 보증 가능하냐?
                  (= 화장실 가는 순서가 약간 변동이 생겨도, 결국 미래는 비슷하게 흘러갈거냐?)
                    -> 실행순서와 관계없이 항상 같은 결과를 얻어야하는 결정성 (Determinacy) 문제


      # 'Concurrency(동시성) : Parallelism(병렬성) = 비동기 처리 : 병렬 처리'의 CS의 역사
         1. 싱글 프로세서 시스템 (Single-Processor Systems)
            : 초기 컴퓨터는 싱글 프로세서(Single-Processor) + 1개의 프로세스(process)만이 실행이 가능함
               -> 시스템의 최소 실행단위는 프로세스(process)이며, 1개의 프로세스만 실행이 가능
                  (= 코드 작업을 순차적으로 1요청에는 1응답이 되기까지 다음을 작업을 진행하지 않는 '동기적 프로그래밍' 방식을 사용)

            - 용어 사전
               1) 프로세스
                   : 현재 컴퓨터에서 메모리에 instance로서 객체화 되어 올라가 실행중인 프로그램를 통칭하는 용어
                      -> 과거에는 컴퓨터에 여러개의 프로그램을 실행한다는 개념이 없는 '프로세스 기반의 시스템'이 주류
                         (= 당연히 비동기 작업처리라는 개념이 없었음)

               2) 프로세서(= CPU)
                  : 프로세스를 실제로 수행하는 주체를 의미하는 장치로 일명 중앙처리장치.. 
                     -> 단일 프로세서(Single-Processor) = 1코어 cpu
                     -> 다수 프로세서(Multi-Processor)  = 멀티코어 cpu
                         : (IF) 프로세서의 수가 많으면?
                             -> 다중 프로세싱 (Multi processing) 가능
                                 : 여러 개의 프로세서가 동시에 다양한 작업을 처리하는 기술, 각 프로세서는 독립적인 실행 단위인 프로세스를 처리
                                   (= 물리적으로 병행 프로세스를 수행하는 병렬 처리의 효율이 늘어남)
   
                             -> 다중 쓰레딩 (Multithreading) 가능
                                 : 멀티코어를 멀티쓰레드로 사용하게 설계된 프로세스(= 프로그램)의 경우 퍼포먼스가 늘어날 수 있음

         2. 멀티 프로그래밍 (Multi-Programming) (= 동시성(Concurrency) 관점의 비동기적 프로세스 처리 가능한 시대의 등장)
            : 1960년대 후반 컴퓨터의 성능이 여러개의 프로세스를 띄울 수 있을 정도로 발전함
               -> 이제는 싱글 프로세서(Single-Processor) 환경에서 다중 처리(Multi-Processing) 시스템을 구현할 필요성이 생김
                  (= 싱글 프로세서(Single-Processor)라서 진짜로 물리적으로 동시에 코드를 처리하는 병렬처리는 불가능하지만.. 여러개의 프로세스를 어떻게든 동시간대에 실행하게 해서, 언제라도 유저가 조작하면 반응에 응할 수 있도록 컴퓨터를 설계해야 함)  
                      -> How to solve?
                          : 어차피 CPU 1개라서 병렬성(Parallelism)한 병렬처리는 불가능? 그럼 동시성(Concurrency)한 관점에서 CPU가 시간차로 플래쉬보다 ㅈㄴ 빠르게 여러 프로세스의 처리를 번갈아가며 처리하면? 동시에 프로세스를 실행하는거처럼 보이니 문제없겠네?
                             -> '시분할 시스템'을 통해 '동시성 프로세스(Concurrent Process)' 방식을 구현한, '프로세스 스케줄링(process scheduleing)'으로 비동기적 멀티태스킹(multi tasking) 구현
                                (= 프로세스 처리의 상태 기록을 위해서 컨텍스트(context) 개념이 도입 + 프로세스 간 통신을 위해 IPC 프로세서 사용 + 프로세스 동기화(processs Synchronization)를 통한 경쟁상태 문제 해결)
                      -> 결론
                          : 동시성(Concurrency) 측면에서는 진전이 있었지만, But 병렬성(Parallelism) 병렬처리에는 한계


            - 동시적 태스크 동기화 (Concurrent task Synchronization) 문제
               : 다수의 프로세스가 동시성(Concurrent)을 가지는 업무들(tasks)을 함께 수행함에 따라, 동시기에 공유된 자원에 경쟁적으로 접근(race condition)하게 되었을떄, 작업 과정 자체가 매번 달라지고 작업 결과의 신뢰성에 문제가 발생
                  -> 프로세스 동기화(processs Synchronization)를 통해 해결 가능

            - 용어 사전
               1) 다중처리(Multi-Processing)
                  : 컴퓨터 시스템이 동시에 여러 작업을 처리할 수 있는 능력을 의미... '처리방식', '사용자', '태스크(프로세스 실행개수)' 등 관점에 따라 구분하는 방식이 다양함
   
                     a. 싱글 태스킹 (Single-Tasking)
                         : 하나의 태스크 만을 전념 실행  
   
                     b. 멀티 태스킹 (Multi-Tasking)
                         : 여러 태스크들을 동시에 실행시킴

               2) 프로세스 스케줄링(process scheduleing)
                  : 프로세서(= CPU)가 아주 빠르게 주기적으로 각 프로세스의 주도권을 오가며 실행하는 계획안으로 이를 통해 싱글 프로세서(Single-Processor)로 다수의 프로세스들을 실행 가능하게 함
      
               3) 동시성 프로세스(Concurrent Process)
                  : '프로세스 스케줄링(process scheduleing)'을 통해, 동시성(Concurrency) 관점에서 비동기적으로 여러 프로세스들을 실행하는 것처럼 보이게 하는 방식
   
                    a. 독립적 프로세스 (Independent process)
                        : 여러 프로세스들이 '프로세스 스케줄링(process scheduleing)'을 통해 각각 독립적으로 동시성 수행(= 멀티태스킹)되는 개념
                          (= 개별 프로세스들은 다른 프로세스들에게 영향을 주지도, 받지도 않고, 데이터를 공유하지도 않음)
      
                    b. 협력 프로세스 (cooperaitng process)
                        : 다른 프로세스의 실행에 영향을 주는 여러 프로세스들이 '프로세스 스케줄링'을 통해, 동시성 수행(= 멀티태스킹)되는 개념
                          (= 각 프로세스들은 동일한 시스템을 기반에 두고 작동하기에, 동일한 메모리 공간에서 변수, 파일, 메세지 등을 공유하기에 나타나는 현상)
                              -> IPC(Inter-Process Communication) 프로세스를 사용해서 프로세스 상호 간 통신하여.. 공유될 데이터를 주고받음

               4) 프로세스 동기화(processs Synchronization)
                  : 입출력장치나 메모리와 같은 자원 한 순간에 하나의 프로세스만 이용하도록 제어하는 임계구역(critical section) 의 상호배제(mutual exclusion)를 구현
                     -> 이를 통해 경쟁상태(race condition)를 해소하고 공유자원의 일관성을 보장해 주는 것


         3. 컨텍스트 (Context) 개념을 활용한 프로세스(process) 내부의 비동기 작업 (= 프로세스 내부의 동시성(concurrency) 개념의 등장)
            : 1960 ~ 1970년대 개별 프로세스의 코드처리도 굳이 1요청에 1응답의 동시성 프로그래밍을 고집할 필요가 없어질 정도로 컴퓨터의 성능이 향상
               -> 이제는 싱글 프로세서(Single-Processor) 개별 프로세스(process) 내부의 코드를 단일 처리 흐름(후에 single thread로 불림)으로 동시성(Concurrent)을 가지도록 비동기로 작업 처리할 수 있게 해야 함
                   -> How to solve?
                       : 컨텍스트 스위칭(Context swiching)을 통해 해결
                          -> 프로세스 스케쥴링(process scheduleing)을 통해 프로세스 간 비동기적 멀티태스킹(multi tasking) 구현했던걸 응용하면 되잖아?
                             (= 프로세스(process)에서 비동기로 작업될 코드를 만나면? 해당 되는 프로세스 내부의 비동기 작업 상태 정보를 가지는 컨텍스트(Context)를 생성되게 함 + 이를 비동기 작업의 단위로 삼아 프로세스 처리 흐름이 돌아올 수 있게 하자)

            - 용어 사전
               1) (중요!) 컨텍스트(context) 
                  : 실행 중인 프로세스(process)나 스레드(thread)의 상태를 나타내는 정보 집합 (레지스터 값, 프로그램 카운터 등의 정보 존재)
                     -> 프로세스 간의 실행 순서와 동시성을 관리할 수 있기에, 프로세스 및 쓰레드 간의 스위칭이 가능해져 멀티태스킹이 실현
                        (= 정확히는 프로세스 스케쥴링과 프로세스 내부의 비동기 작업, 병렬 처리에 전부 사용될 수 밖에 없음)
                            -> (중요) js의 promise 객체 또한 정확히는 이 프로세스의 컨텍스트(context)에 대한 내용을 담는 개념임

               2) 컨텍스트 스위칭(context switing) 
                  : 현재 실행 중인 프로세스 or 쓰레드의 상태를 저장하고 다음 실행할 프로세스 or 쓰레드의 상태를 복원하는 과정
                    (= Concurrency(동시성) & Parallelism(병렬성) 양쪽 모두와 연관이 깊은 개념)


         4. 쓰레드(thread) 개념의 등장 (= 프로세스 내부의 '유사' 병렬성(Parallelism) 개념 (= 결국 동시성(concurrency)의 등장)
             : 1970년대 컴퓨터의 발전은 싱글 프로세서(single processor) 환경임에도, 더 이상 프로세스를 프로그래밍의 최소 처리 흐름 단위로 둘 이유가 없을 정도로 발전함
               (= 개별 프로세스의 처리에 있어, 동시성(Concurrency)을 넘어서 병렬성(Parallelism)을 기반으로 한 병렬처리가 가능할 수 있도록, 프로그래밍의 새로운 최소 처리 흐름 단위가 필요)
                   -> 프로세스 내에서 실행되는 각각의 독립적인 실행 단위인 '쓰레드(thread)'의 등장
                      (= 쓰레드를 여러개를 쓰는 멀티 쓰레드(multi thread)를 통해, 병렬성(Parallelism)에 입각한 프로세스의 병렬처리가 가능해짐)

            - 쓰레드(thread)의 특징
               1) 개별 thread는 각각 독립된 실행 흐름과 스택(stack)을 가짐
                  (= 다른 thread와 처리 영역이 겹치는 고생을 하지 않기에, 동시성 문제를 방지하는 측면이 존재)

               2) 개별 thread는 프로세스 안에서의 전체적인 실행 흐름과 힙(heap)영역은 공유를 함
                  (= 각자 하는 일이 전체를 향하는 일괄적인 흐름을 가진 작업이 됨)

               3) 개별 thread도 context가 존재하여, context switching의 대상이 될 수 있음

               4) 한 프로세스(process)의 여러개의 쓰레드(thread)가 존재 가능함

               5) 기본적으로 쓰레드는 평행성(Parallelism)을 근거로 한 물리적으로 동시적 프로그래밍 처리를 하는 병렬처리를 위해 만들어짐
                   -> (주의!) 단! 진정한 평행성(Parallelism)은 멀티코어 cpu를 사용한 멀티 프로세서 환경에서 실현됨 = 싱글 프로세서 환경에서는 멀티 쓰레드 해봐야 동시성(concurrency) 기반 작업이 됨

               6) 쓰레드는 한편으로는 동시성(concurrency) 또한 강조한 개념임
                  (= 여러개의 쓰레드는 프로세스의 context swiching 작업 또한 더 빠르게 처리하여 공유 자원을 또한 더 효율적으로 사용하기에, 비동기 처리 또한 더 빠르게 수행하게 해줌)

         5. 다중 프로세싱(multi processing)의 등장 (= 프로세스 단위로 진정한 병렬성(Parallelism) 개념과 병렬처리 가능한 시대)
             : 소위 말하는 듀얼 코어 CPU의 등장으로 프로세스들을 동시성(Concurrency)에 근거한 비동기가 아닌 병렬성(Parallelism) 병렬처리가 가능해짐
               (= 추후 이 멀티 코어가 쓰레드와 하드웨어적 소프트웨어적으로 더 연계되어... 개별 프로세스의 퍼포먼스 향상에도 프로세서의 모든 역량을 집중하는게 또 가능해짐)


  @ 컨텍스트(context) with 동시성(concurrency)
     : 실행 중인 프로세스(process)나 스레드(thread)의 상태를 나타내는 정보 집합 (레지스터 값, 프로그램 카운터 등의 정보 존재)
        -> 프로세스 간의 실행 순서와 동시성(concurrency)을 관리할 수 있기에, 프로세스 및 쓰레드 간의 스위칭이 가능해져 멀티태스킹이 실현
           (= 정확히는 프로세스 스케쥴링과 프로세스 내부의 비동기 작업, 병렬 처리에 전부 사용될 수 밖에 없음)
               -> (중요) js의 promise 객체 또한 정확히는 이 프로세스의 컨텍스트(context)에 대한 내용을 담는 개념임


  @ 쓰레드(thread) with 평행성(Parallelism)
     : 프로세스(= 컴퓨터에서 메모리에 instance로서 객체화 되어 올라가 실행중인 프로그램)마다 최소 1개는 존재하는 한 단계 더 낮은 프로그램의 최소 실행 흐름 단위
       (= 쉽게 말해, 쓰레드는 실행 중인 개별 프로세스 안에 속해서, 개별적으로 코드를 읽고 실행하는 주체로 이해하면 되며, 당연히 프로세스를 실행하기 위해서는 최소 실행 주체가 1개는 필요하다는 점에서 매우 상식적인 말임)
           -> ex) 프로세스(process) : 개별 건설현장 = 쓰레드(thread) : 현장 노동자
                  (= 건설 현장에서 업무를 수행하기 위해서는? 당연히 최소 1명의 노동자가 필요함)

      # 쓰레드(thread)의 특징
         1) 개별 thread는 각각 독립된 실행 흐름과 스택(stack)을 가짐
            (= 다른 thread와 처리 영역이 겹치는 고생을 하지 않기에, 동시성 문제를 방지하는 측면이 존재)

         2) 개별 thread는 프로세스 안에서의 전체적인 실행 흐름과 힙(heap)영역은 공유를 함
            (= 각자 하는 일이 전체를 향하는 일괄적인 흐름을 가진 작업이 됨)

         3) 개별 thread도 context가 존재하여, context switching의 대상이 될 수 있음

         4) 한 프로세스(process)의 여러개의 쓰레드(thread)가 존재 가능함

         5) 기본적으로 쓰레드는 평행성(Parallelism)을 근거로 한 물리적으로 동시적 프로그래밍 처리를 하는 병렬처리를 위해 만들어짐
             -> (주의!) 단! 진정한 평행성(Parallelism)은 멀티코어 cpu를 사용한 멀티 프로세서 환경에서 실현됨 = 싱글 프로세서 환경에서는 멀티 쓰레드 해봐야 동시성(concurrency) 기반 작업이 됨

         6) 쓰레드는 한편으로는 동시성(concurrency) 또한 강조한 개념임
            (= 여러개의 쓰레드는 프로세스의 context swiching 작업 또한 더 빠르게 처리하여 공유 자원을 또한 더 효율적으로 사용하기에, 비동기 처리 또한 더 빠르게 수행하게 해줌)


      # 다중 쓰레드(multi thread) with 병렬처리
         : 실행 중인 개별 프로세스에서 개별적으로 코드를 읽고 실행하는 주체가 여럿인 경우인 프로세스 환경을 의미하는 것으로.. 평행성(Parallelism)에 입각한 병렬처리가 가능해짐
            -> 쓰레드(thread)의 개수가 많으면, 평행성(Parallelism)이 context swiching을 더 효율적으로 수행하게 하여 동시성(concurrency)을 강화하기에, 프로세스의 비동기 코드 처리를 더 빠르게는 할수 있음..
                -> (중요) BUT! 쓰레드의 갯수는 비동기 작업 가능 여부와 1도 상관 X

         1) 다중 쓰레드(multi thread) + 동기적 프로그래밍 처리를 하는 경우
             : 싱글 쓰레드 환경과 마찬가지로.. 해당 작업이 완료될 때까지 다른 작업들이 블로킹 됨.. 
               (= 1요청 1응답이 완료 될 때까지 다른 쓰레드가 논다는 말씀...)

         2) 다중 쓰레드(multi thread) + 비동기적 프로그래밍
             : 싱글 쓰레드 일때?  
                -> 진행중인 비동기 코드의 컨택스트(context)을 번갈아가며 수행하는 컨텍스트 스위칭(context switing)으로 커버

             : 쓰레드의 수가 많을 때 
                -> 비동기 코드의 컨택스트(context)들을 실제로 동시에 다른 쓰레드들이 같이 처리해 줌 
                   (= 컨텍스트 스위칭(context switing)의 수가 적어짐)


      # (중요) 다중 쓰레드(multi thread) & 프로세서(processor)의 갯수에 따른 Concurrency(동시성) & Parallelism(병렬성) 관계
         : 다중 쓰레드(multi thread)의 Parallelism(병렬성)에 기반한 병렬 처리는 오직 다중 코어 CPU를 사용한 다중 프로세서(multi processor) 환경에서만 가능!
            <-> 싱글 프로세서(single processor) 환경에서는 멀티 쓰레드를 사용해봐야, 결국 다양한 작업들을 동시에 조율하고 번갈아가며 실행함으로써 마치 동시에 처리되는 것처럼 보이는 동시성(concurrency)에 기반한 기반 일종의 비동기 작업이 됨
                (= 그럼에도 이를 쓰는 이유는 이를 통해 응답없음으로 인한 블로킹을 피할수가 있음)


  @ 비동기 작업 VS 동기 작업
     : 요청(request)를 수행할 시, 응답(resonse)을 받을 때까지 다음 코드로 넘어가는가 넘어가지 않는가 여부에 따라 갈림

        1. 동기 작업 (순차적 작업)
           : 1요청(request)과 1응답(resonse)은 하나의 작업처리 단위(transaction) 세트로서 동시에 일어나는걸 전제로 하여, 프로세스의 흐름를 1차선적으로 수행하는 것을 동기라고 함
              -> 대충 노빠꾸 one way 전략에 위에서 까라면 밑에서는 일방적으로 까는 것과 비슷..
                 (= 2인 3각 릴레이 계주처럼, 한 팀의 작업이 끝날때까지 다른팀들은 보고만 있어야 함)
                     -> 쉽게 설계할 수 있지만, 결과가 주어질 때까지 아무것도 못하고 대기해야 함
  
        2. 비동기 작업(비순차적 작업) with 동시성(concurrency)
           : 요청(request)과 응답(resonse)이 동시에 일어나지 않는 별개의 작업처리 단위(transaction)로서, 동시성(concurrency)을 기반으로 동시 다발적으로 발생가능하고, 다른 작업을 시작할 수 있도록 제어가 반환되어 요청과 응답이 다른 시간대 존재해도 되는 작업 처리 방식을 비동기라고 함
             (= 프로세스의 작업처리 상태값을 가진 컨텍스트(context)를 통해, 비동기 코드를 수행중인 thread들이 어디에 비동기 코드가 있는지와 처리 여부를 체크가능)
                 -> 쉽게 말해, 개별 요청과 응답은 전체프로세스와 별개로 독립적이면서 병렬적으로 수행되며, 어떤 요청단위가 수행되고 나면 응답이 오는거랑 상관없이 다른 프로세스는 진행됨
                    (= 메인 쓰레드가 아닌 다른 쓰레드로 비유 가능한 계열사들이 본사의 의지랑 상관없이 자신의 비즈니스를 수행하고 계약하는 독립채산제나 현실의 회사생활에서 직원을 출장보내도 본사는 굴러가는걸 생각해보면 간단함)


      # 비동기 작업처리의 장, 단점    
         1) 장점
             : 결과가 주어지는데 시간이 걸리더라도, 동시기에 다른 작업 또한 동시에 할 수 있으므로 자원을 효율적으로 사용

         2) 단점
             : 제대로 신경을 쓰지 않으면, 한 프로세스의 작업처리 단위(transaction)들이 전부 비동기적으로 수행되어 일처리가 뒤죽박죽하게 됨
               (= 비동기적 작업방식을 통해 제대로 된 효율을 내기 위해서는 복잡한 설계도 감안해야 함..)
                  -> 비동기적 작업처리 프로세스 또한 통제를 위해서는.. 개별 비동기 코드들을 작업흐름(workflow) 용도를 기준으로 그루핑을 한 뒤, 그 그룹들이 각각 하나의 작업처리 단위(transaction)로서 하나의 컨텍스트(context)에 근거해 각각 동기적(= 순차적) 방식으로 단계적으로 수행될 수 있어야 한다는 결론 도출  
                      -> (중요) 여기서의 '컨텍스트(context) 단위'는 프로세스 내부의 업무들을 큰 틀에서 독립성을 가진 기준으로 짜여 있다 생각하자                                    


      # 비동기적으로 작동하는 코드들이 큰 틀에서 동기적(= 순차적)으로 단계적 동작하게 하는 방법(?)
         : 쉽게 말해, 비동기 작업처리 코드로 이뤄진 프로세스의 작동 로직을 기준으로 순번을 책정한 집단들을 컨텍스트(context) 단위로 세우고, 각 그룹에 해당하는 비동기 코드들을 분류 후 컨텍스트(context) 단위로 코드들의 실행타이밍을 통제함으로서, 그룹기준으로 순차적 처리가 가능하게 한다고 생각하면 됨
            -> 해당 프로세스의 논리적 작업흐름(workflow)의 개별 단위들을 기준으로 실제 프로세스 로직의 작업처리 단위(transaction)들을 분류하고, 그렇게 분류된 작업처리 단위(transaction)에 소속된 컨텍스트(context) 단위들은 자신이 소속된 작업흐름(workflow)가 실행될 타이밍에 맞춰 동시성(concurrency)을 가지고 수행됨
               (= 이를 통해 무질서하게 수행되는 개판 5분전을 방지하고, 비동기 코드의 실행 메커니즘을 인간의 시각을 기준으로 설계할 수 있게 됨)

               ex) 페이지 리로드 기능에 속하는 컨텍스트(context) 단위의 workflow 분류
                    (1단계) -> 필요한 페이지의 html파일들을 다운로드 하는 로직(해당 로직에 속한 작업처리 단위(transaction) 비동기적으로 실행)
                    (2단계) -> (1단계 완료시) 다운로드 받은 html파일들을 랜더링(해당 로직에 속한 작업처리 단위(transaction) 비동기적으로 실행)


         - 세부적 설명
            1단계) 프로세스의 내부 기능들을 업무 독립성 측면에서 분류하여 컨텍스트(context) 단위로 나누고, 해당 프로세스의 개별 컨텍스트(context) 단위의 비동기 코드들을 분류함
            2단계) 각 컨텍스트(context) 단위에 해당하는 기능별 로직들을 순차적인 작업흐름(workflow)의 집합으로 간주하고 나눔
            3단계) 해당 작업흐름(workflow)을 단위(= 시스템 입장에서는 작업처리 단위(transaction)로 간주)들을 기준으로 각 컨텍스트(context) 그룹의 비동기 코드들을 2차 그룹화를 시킴
            4단계) 각 그룹 내의 모든 비동기 코드들을 1개의 작업처리 단위(transaction)로서 간주, 작업흐름(workflow)의 순서를 기준으로 microtask queue에 넣어 실행타이밍 통제함
                   (= 시스템 입장에서의 작업흐름(workflow) 단위 == 작업처리 단위(transaction)로 간주)
             
         - 용어 설명
            1) 컨텍스트(context) 단위
               : 프로세스의 내부 기능들을 업무 독립성 측면에서 분류하여, 해당 프로세스의 개별 컨텍스트(context) 단위의 비동기 코드들을 1차적으로 분류하는 집단 기준
                 (= 대충... Promise 객체의 연쇄 호출에서 Promise 덩어리 전체를 떠올리면 됨)
                  -> 이를 통해 그 기능의 작업 상태를 하나의 컨텍스트(context)에 근거할 수 있고, 작업처리 단위(transaction) 별로 2차 분류된 비동기 코드들을 통제 가능

            2) 작업흐름(workflow) 
               : 비동기적 코드로 이루어진 프로세스의 로직을 업무로 추상화한 내용적 논리로 바라보는 인간의 관점을 분류(catagorize) 기준으로 삼아서, 큰 틀에서 작은 업무 단위들을 구분하여 질서정연하게 순차적으로 수행되는 업무 단위로 도식화한 결과물 
                 (= 작업처리 단위(transaction) == 시스템 입장에서의 보는 작업흐름(workflow) 단위)

            3) 작업처리 단위(transaction)
               : 도출된 개별 작업흐름(workflow)을 메커니즘적인 작업흐름의 단위로 간주하여, 그 개별 작업흐름(workflow) 단위(unit)를 기준으로 컨텍스트(context) 단위에 속한 원맨아미 같은 비동기 코드들을 2차적으로 분류하는 집단 단위 
                 (= 대충... Promise 객체의 연쇄 호출에서 개별 then() 단위나, await에 속한 코드를 떠올리면 됨)
                    -> 같은 분류기준으로 묶였을 경우 원래 한 몸이었던 것처럼 일괄적으로 조작 및 통제가 가능해지기에 작업처리 단위(transaction)라고 부름
       
            
         - (중요!) js에서도 이같은 작업흐름(workflow) 개념을 기점으로 비동기 프로세스의 작업처리 단위(transaction) 순서를 통제할 방식이 필요해서 등장한게 promise 객체
            -> Promise 객체의 상태값은 이 작업흐름(workflow)개념을 바탕으로 비동기 프로세스의 내부에서 순차적으로 작업처리 단위(transaction)의 수행되는 각 단위의 업무 처리 현황 및 결과가 기준이 됨


  @ Promise 객체
     : ECMA6 이후 JS로 작성된 프로세스의 내부 작업의 비동기 처리를 위해, 프로세스의 비동기 코드 작업 상태에 대한 정보(= 상태값)를 가지는 컨텍스트(context) 단위의 역할을 수행하는 promise 객체
        -> 거대한 비동기 프로세스을 '작업흐름(workflow)을 기준으로 작업처리 단위(transaction)'를 순차적으로 나눈 뒤, 그 영역의 성공/실패 여부를 상태값을 통해 통제하는 방식으로 의 무분별한 비동기적 컨텍스트(context)의 생성을 방지하여 프로세스의 안정적 실행을 가능하게 함
           (= 비동기 작업에 따른 상태값의 구현은 내부에서 비동기 작업의 (각 처리단계를) 성공여부를 boolean으로 잡으면.. 그 값에 따라서 Promise 객체 생성자의 parameter로 들어가는 무명함수의 parameter인 2개의 parameter로 놓은 2개의 callback(일반적으로 resolve, reject 불림) 중 하나를 실행하는 방식)
               -> 그렇기에, 순차적으로 동적하는 js에서 ajax 같은 비동기로 각각 병렬적으로 동작하는 기능을 구현이 가능함
                  -> 일반적으로 비동기처리를 통해 전체적인 작업의 처리시간(leading time)을 줄일 수 있음
                     (= 비동기 작업은 일반적으로 서버와의 데이터 통신이나 파일 읽기와 같이 시간이 오래 걸리는 작업을 의미)


      # (중요) Promise 객체가 각 비동기 작업처리 단위(transaction)의 성공/실패 여부를 판단하는 로직
         : (이름은 상관없지만) Promise 객체 생성자의 parameter로 들어가는 무명함수의 parameter로 들어가는 2개의 callback함수(일반적으로 resolve, reject 불리는)를 넣으면.. 내부에서 비동기 작업 성공여부를 boolean으로 기록되게 하면
            -> 비동기 작업 성공시 (= promise객체의 상태값 : fulfilled) : resolve를 실행
            -> 비동기 작업 실패시 (= promise객체의 상태값 : rejected)  : reject를 실행
         
               ex) const promise = new Promise((resolve, reject) => {

                     // 비동기 작업 수행 성공여부를 따지는 로직
                     if (isResolved == true) {
                       resolve("Success");   <- 성공적으로 처리될 경우 무명함수의 parameter 중 resolve를 callback함수로 호출
                     } else {
                       reject("Error");      <- 거부될 경우 무명함수의 parameter 중 reject를 callback함수로 호출
                     }
                     
                   });

      # (중요) Promise 객체의 비동기 작업처리 단위(transaction) 처리 결과 상태값 3가지
         : 비동기 프로세스 내부의 진행되는 로직들은 순차적으로 진행되는 작업처리 단위(transaction)의 성공/실패 여부를 기록한 각 Promise객체의 상태값에 따라 후속처리가 분기처리함
            -> (중요) 이 Promise객체의 상태값(pending, fulfilled, rejected)은 추후 비동기작업 처리 및 현재 단계 동기작업 처리의 성공/실패의 후속 처리 로직에 관여
               (= 각 단계의 비동기 작업처리 단위(transaction)의 성공/실패에 따른 후속 처리 로직은 상태값의 도출을 순차적으로 기다려야 함 == 비동기 작업의 일부 로직을 순차적인 동기적 처리로 처리함)   
                  -> 추후 fetch()나 axios 등 js에서 비동기로 서버와 통신한 ajax 통신 결과에 따른 분기처리를 가능하게 함

         1) 대기(pending)
            : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 수행이 아직 완료되지 않은 상태
               -> 상태값이 pending으로 유지됨 =  다음 단계의 then(), catch(), finally() 패턴 및 async, await에서 다음 단계의 await 구문의 실행을 억제하는데 사용
                  (= '상태값이 pending -> 다른 상태로 변화'가 비동기 작업의 일부 로직이 동기적으로 처리되게 유도하는 일종의 트리거 역할)
 
         2) 이행(fulfilled)
            : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 수행이 성공적으로 완료된 상태
                -> then(), catch(), finally() 패턴의 .then()와 async, await에서 패턴에서 await를 구현하는데 사용
                   (= 상태값이 fulfilled로 전환되는 순간, 해당 코드들이 순차적으로 실행)

         3) 거부(rejected)
            : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 수행이 실패한 상태
                -> then(), catch(), finally() 패턴의 .catch()을 구현하는데 사용
                    -> (중요!) async, await에서도 비동기작업이나 현재 await 작업의 실패 후의 처리는 .catch()가 맡게 됨
                       (= async, await와 then(), catch(), finally()는 공존이 가능하다는 결론이 나옴...)


      # ajax와 axios, fetch API와 Promise 객체의 관계
         : 추후 ajax 기능을 수행하는 axios와 fetch API 또한 promise 객체의 상태값을 기반으로 동작하는 비동기 작업
           (= js의 비동기적 정보 교환 기법은 각 작업처리 단위(transaction) 수행에 따른 결과값을 가진 Promise 객체를 return함)
            -> (중요) 그들의 요청에 대한 응답 내용 또한 비동기 프로세스의 개별 작업처리 단위 수행 결과의 후속을 처리하는 하단의 then(), catch(), finally()와 async / await을 이용하여 처리할 수 있음


  @ Promise API
     : Promise 객체에는 5가지 정적 멤버함수들이 존재하며, 프로세스 안의 여러개의 비동기 작업 코드들에 대한 통제를 더 의도(semantic)를 가지고 정확하게 할 수 있음

        1. Promise.all( iterable 객체 ) 
            : (중요) promise 객체들이 여러개 있고, 그들의 작업을 동시성을 가지고 진행시키고, 이들이 끝나기 전까지 다음 작업을 처리하지 않고 기다려야 하는 경우 사용하는 함수
                -> 쉽게 말해, 각 업무를 기준으로 구분한 비동기 작업 코드로 이뤄진 컨텍스트(context) 집단들 여러개를 더 큰 틀에서 일괄적으로 동시성(concurrency)을 가지고 동작하도록 통제하기 위한 방법

                ex) Promise.all( [promise 객체1, ... promise 객체n])
                     : (중요) 함수의 결과값은 안에 존재하는 promise 객체들의 처리가 '전부 성공' or '하나라도 실패'의 경우로 나뉨

                         - iterable 객체 안의 promise 객체의 비동기 작업 전부 성공시?
                             : 각 promise 객체가 가진 작업처리 성공에 대한 결과값의 배열형식으로 변환되어, 새로운 promise 객체의 상태값으로 반환

                               ex) Promise.all의 성공 결과값 예시
                               
                                   [promise 객체1 성공상태값, ... , promise 객체n 성공상태값]
                                     -> (주의) 해당 배열의 순서는 parameter로 들어간 iterable 내부의 index 그대로임

                               ex) 모든 비동기 처리 성공한 Promise.all 예시

                                   // 1, 2, 3이 새로운 promise 객체의 상태값으로 반환
                                   Promise.all([
                                     new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
                                     new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
                                     new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
                                   ]).then(alert); 


                         - iterable 객체 안의 promise 객체의 비동기 작업 하나라도 실패시?
                             : 그 즉시 Promise.all 전체가 거부 처리 되어서 .catch 구문이 실행됨...
                                -> (주의) 그렇다고 다른 promise 객체를 통한 비동기 작업까지 중지되진 않음.. 단지 다른 비동기 처리결과에 따른 promise 객체의 상태값이 그 뒤 어쩄든 상관없이 완전히 무시됨

                               ex) 비동기 처리 중 하나라도 작업처리 실패가 나는 Promise.all 예시

                                   // Error: 에러 발생!
                                   Promise.all([
                                     new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
                                     new Promise((resolve, reject) => setTimeout(() => reject(new Error("에러 발생!")), 2000)),
                                     new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
                                   ]).catch(alert); 


            # Promise.all( iterable 객체 ) 특징
               1) parameter로 들어간 iterable 객체 안의 promise 객체들은 일괄적인 타이밍에 비동기로 실행됨
               2) (중요) Promise.all() 함수의 결과값은 안에 존재하는 promise 객체들의 처리에 따라 all or nothing같은 개념
               3) Promise.all() 함수의 결과값이 성공처리 되었는데, iterable 객체에 일반값이 있는경우.. 성공값에 해당하는 배열에 그 일반값이 들어감

                  ex) Promise.all([ new Promise((resolve, reject) => { setTimeout(() => resolve(1), 1000) }), 2, 3 ]).then(alert); 
                       -> 결과값 : [1, 2, 3]

               4) parameter는 iterable 객체면 뭐든 ㅇㅋ임
                  (= promise 객체가 아닌 일반값도 넣을 수 있음)
                      -> 물론 대개는 promise 객체 배열이 들어감

               5) Promise 객체에는 '취소’라는 개념이 없어서, Promise.all도 프라미스를 취소하지 않움
                  (= catch() 뜨는걸 원하지 않아서, 해당 Promise 객체에 속한 작업을 취소할 수 없다는 말)
                     -> 만약 각 비동기 작업의 실패/성공 응답을 받고 싶으면 Promise.allSettled을 쓰자


        2. Promise.allSettled( [promise 객체1, ... promise 객체n])
            : Promise.all과 비슷하나... all or nothing 개념이 아니라.. 각 promise의 처리에 대한 결과값을 응답으로 각각 반환해줌

              ex) let urls = [
                    'https://api.github.com/users/iliakan',
                    'https://api.github.com/users/Violet-Bora-Lee',
                    'https://no-such-url'
                  ];
                  
                  Promise.allSettled(urls.map(url => fetch(url)))
                    .then(results => { 
                      results.forEach((result, num) => {
                        if (result.status == "fulfilled") {
                          alert(`${urls[num]}: ${result.value.status}`);
                        }
                        if (result.status == "rejected") {
                          alert(`${urls[num]}: ${result.reason}`);
                        }
                      });
                    });

                  ------------------------------------------------------------------
                  [ {status: 'fulfilled', value: ...응답...},
                    {status: 'fulfilled', value: ...응답...},
                    {status: 'rejected', reason: ...에러 객체...} ] 형식으로 반환
                  ------------------------------------------------------------------

              - 응답이 성공할 경우 : {status:"fulfilled", value:result} 형식으로 해당 promise 결과값 리턴
              - 에러가 발생한 경우 : {status:"rejected", reason:error} 형식으로 해당 promise 결과값 리턴

        3. Promise.race( [promise 객체1, ... promise 객체n])
            : Promise.all과 비슷하나, 다만 가장 먼저 처리되는 프라미스의 결과(혹은 에러)만을 반환

               ex) 다음 작업은 1번쨰 promise 객체의 비동기 작업이 가장 빨리 나왔기에, 1번쨰 promise의 결과값만 출력

                   Promise.race([
                     new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
                     new Promise((resolve, reject) => setTimeout(() => reject(new Error("에러 발생!")), 2000)),
                     new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
                   ]).then(alert); // 1

        4. Promise.resolve( value )
            : (async/await 등장 이후 사장) value 에 해당하는 parameter 값으로 작업 상태값이 성공 상태인 promise 객체를 생성
              -> (중요!) 상단 promise객체 생성과 하단 then() 구문에서 지겹게 보는 무명함수의 1번쨰 parameter인 callback함수명이 이 녀석

        5. Promise.reject( error )
            : (async/await 등장 이후 사장) error에 해당하는 parameter 값으로 작업 상태값이 실패 상태인 promise 객체를 생성
              -> (중요!) 상단 promise객체 생성과 하단 then() 구문에서 지겹게 보는 무명함수의 2번쨰 parameter인 callback함수명이 이 녀석

               ex) const promise = new Promise((resolve, reject) => {

                     if (isResolved == true) {
                       resolve("Success");   <- 성공적으로 처리될 경우 무명함수의 parameter 중 resolve를 callback함수로 호출
                     } else {
                       reject("Error");      <- 거부될 경우 무명함수의 parameter 중 reject를 callback함수로 호출
                     }
                     
                   });

                   promise.then(
        
                     (result) => {
                       console.log("Resolved:", result);
                     },
                     (error) => {
                       console.error("Rejected:", error);
                     }
                   )


  @ then(), catch(), finally()
     : 비동기 프로세스의 개별 작업처리 단위(transaction)를 기준으로, 각 작업이 진행완료 될 때까지(pending) 기다린 뒤 그 성공(fulfilled)과 실패(rejected) 결과를 바탕으로 경우의 수에 따른 수행할 분기 구조를 구현하는데 사용되는 promise 객체의 멤버함수들
       (= 비동기 작업 시도를 try로 보면 try ~ catch와 유사 + 비동기 작업의 일부를 동기적인 것으로 만듦)
           -> (중요) then(), catch(), finally()는 전부 무명의 콜백함수를 parameter로 가짐
                : but! 몇개의 callback 함수가 parameter로 들아가는지가 다름
                   => then()의 경우?    2개의 무명의 콜백함수를 parameter로 가지고, 그 콜백함수는 각각 2개의 object(일반적으로 result, error라고 불림)를 parameter로 가짐 
                   => catch()의 경우?   1개의 무명의 콜백함수를 parameter로 가지고, 그 콜백함수는 1개의 object(일반적으로 error라고 불림)를 parameter로 가짐 
                   => finally()의 경우? 무명의 콜백함수는 parameter로 가지지 않음

               ex) const promise = new Promise((resolve, reject) => {
        
                     // 비동기 작업 수행 성공여부를 따지는 로직
                     if (isResolved == true) {
                       resolve("Success");   <- 성공적으로 처리될 경우 무명함수의 parameter 중 resolve를 callback함수로 호출
                     } else {
                       reject("Error");      <- 거부될 경우 무명함수의 parameter 중 reject를 callback함수로 호출
                     }
        
                   });
        
                   // 상단의 promise객체를 통한 비동기작업이 끝난 이후 then(), catch(), finally() 함수는 수행
                   promise.then(
        
                     (result) => {
                       console.log("Resolved:", result);
                     },
                     (error) => {
                       console.error("Rejected:", error);
                     }
        
                   ).catch((error) => {
                     console.error("Caught an error:", error);
        
                   }).finally(() => {
                     console.log("Finally");
                   });


         1) then()
            : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction)의 성공/실패 후, 분기에 따라 자신의 parameter인 2개의 무명의 콜백함수(각각 result, error로 알려진 object를 parameter로 가져감) 중 하나를 실행함
               -> (중요) 2개의 무명함수 parameter로 선언만해두고 사용 안 해도 무방함
         
              a. (1번째 무명함수 parameter) result
                  : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 결과가 성공이면, 그 성공의 결과값을 가지는 object
         
              b. (2번째 무명함수 parameter) error
                  : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 결과가 실패이면, 그 실패의 결과값을 가지는 object
                     -> catch()로도 구현가능!
         
         2) catch()
            : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 결과의 실패가 감지되면, 자신의 parameter인 무명의 콜백함수(error로 알려진 object만 parameter로 가져감) 중 실행함
              (= catch() == then()의 실패 케이스만 특정한 Promise 객체의 멤버함수)
                  -> 따라서, then()은 비동기처리 성공시에만 동작하게 쓸 수도 있음
         
         3) finally()
            : (비동기 프로세스의) 현제 작업처리 단위(transaction) 결과의 성공/실패와 상관없이, 자신의 parameter인 무조건 무명의 콜백함수를 실행함
               -> finally()의 parameter인 무명의 콜백함수는 parameter를 가지지 않음


      # then(), catch(), finally() 비동기 프로세스 처리 패턴의 약점 및 한계
         : 작업처리 단위(transaction)안의 작업처리 단위(transaction)의 등장으로 인한 callback hell 문제로 인해 코드가독성이 메챠쿠챠...
            -> 이를 해결하기 위해 등장한게 async / await 패턴과 React hooks라고 보면 됨

               ex) promise.then(
                     (result) => {

                        promise.then(
                           (result) => { 

                              promise.then((result) => { 내용 })
                               .catch((error) => { 내용 })
                               .finally(() => { 내용 })
                        })
                        .catch((error) => { 내용 })
                        .finally(() => { 내용 }
                     }

                   ).catch((error) => {
                     console.error("Caught an error:", error);
                   }).finally(() => {
                     console.log("Finally");
                   });


  @ async / await
     : (then(), catch(), finally()의 callback hell 문제를 막기 위해) Promise의 상태값을 기반으로 특정 함수를 기반으로 비동기 프로세스로서 병렬적으로 처리하기 위한 비동기 프로세스 처리 패턴
        -> 특정 함수를 비동기 프로세스로서 병렬적으로 처리하기 위한 예약어로 async를 사용, 그 {} 안에 특정 코드가 작업처리 단위(transaction)의 기점으로서 요청에 대한 응답이 나올떄까지 대기하도록 하기 위한 이정표 역할의 예약어로서 await를 사용
           (= async 함수명{ await코드; 코드 ~~  await 코드;} 이런식으로 사용)

         1) async
            : 어떤 함수를 비동기 프로세스로서로 병렬적으로 코드를 처리하라고 표기하기 위한 목적의 예약어
               -> 비동기 프로세스 작업 처리 결과의 성공/실패에 대한 상태값을 가진 promise 객체를 return함

         2) await   
            : async로 비동기 방식 처리 간판이 붙은 함수 작업영역의 코드 중, 수행결과가 나올 떄까지 기다려야 하는 작업처리 단위(transaction)의 기점이 될 코드를 의미하는 표식을 의미하는 예약어가 await
                -> (중요!) await는 이전 await의 다음 코드 ~ 현재 await 코드의 범위인 해당 작업처리 단위(transaction)의 처리결과가 성공이었을 때만, 다음 await까지의 작업처리 단위(transaction)를 진행함
                   (= 작업처리 단위(transaction의 결과가 성공시에만 진행되는 then() 패턴을 공식적으로 다른 방식으로 구현한 것에 가까움)


      # (중요) async / await 작업처리 단위(transaction)의 실패 후의 처리는 .catch()가 맡게 됨
         : then(), catch(), finally()와 async / await는 공존이 가능함을 암시함.. 
            -> 전자는 promise 객체의 메서드고, 후자는 promise객체를 기반으로 동작하기 때문에 호환됨

               ex) async function fetchData() {
                  
                     try {
                       const response = await fetch('https://api.example.com/data');
                       const data = await response.json();
                       
                       const userResponse = await fetch('https://api.example.com/user/' + data.userId);
                       const userData = await userResponse.json();
                       
                       console.log('Order:', orderData);

                     } catch (error) {
                       console.error('Error:', error);
                     }
                   }


  @ Ajax(Asynchronous JavaScript and XML)
     : 프로그래밍 언어인 JavaScript와 마크업 언어인 XML을 이용해서, 브라우저에서 새로고침을 하지 않고도 서버에 GET, POST 요청을 통해 데이터를 주고받을 수 있게 도와주는 브라우저 차원에서 지원되는 비동기적 정보 교환 기법
       (= 쉽게 말해, 웹페이지를 개발할 때, JavaScript를 이용해서 서버에 GET, POST 요청을 새로고침이 없이 비동기적인 연속성을 가지고 보내고, 받고 할 수 있음을 의미)
          <-> 과거 html태그 중 form 태그가 이런 서버에 대한 데이터 요청을 'http메서드(get, post에 한정) + url형식'을 통해 http API 방식으로 티키타카를 할 수 있게 하였으나..? 티키타카할 떄마다 화면이 새로고침이 되어 모든 html요소와 데이터를 다시 받아오는걸 피할 수 없었음


      # 관련 개념 간단 설명 및 정리

         1. 서버
             : 유저가 데이터달라고 요청(request)을 서버가 정한 API 규격(요청 방법 : 어떤 자료 = http메서드 : url형식)에 맞게 하면, 이를 알아먹고 요청에 맞는 데이터를 보내주는(response)하는 간단한 프로그램을 실행하는 컴퓨터

                ex) 유튜브 서버     = 유저가 영상 달라고 하면 영상 보내주는 프로그램을 돌리는 컴퓨터
                    네이버웹툰 서버 = 유저가 웹툰 달라고 하면 웹툰 보내주는 프로그램을 돌리는 컴퓨터

         2. http 메서드
             : 월드 와이드 웹(World Wide Web)에서 사용되는 Hypertext Transfer Protocol(HTTP)을 통해 서버에 요청을 보내는 방법을 정의하는 명령어
               (= 쉽게 말해, client(유저)가 서버로 하여금 일부 자원(resource)에 대한 자료를 보내면, 이를 이용해 수행해야 할 구체적인 동작 방식 종류를 핀포인트로 지정하는 것이라 보면 됨)
                   -> 대충 어떤 url에 딸려 있는 자원(resource)을 어떻게 작업(http 메서드)을 쳐라라는 동사적인 의미를 가지고 있음  

              - http 메서드의 종류

                 1) GET (원년 멤버)
                     : 서버에서 보낸 데이터를 단순 조회하기 위해 사용하는 http 메서드
                        -> (중요) 요청시 http의 head 부분에 client(유저)가 보낸 parameter가 url과 함께 보이는 특징 존재
                        -> 동일한 요청을 연속적으로 수행해도, 같은 결과가 나옴 = 데이터가 변조되지 않기에 안전한 http 메서드

                 2) POST (원년 멤버)
                     : 서버로 일부 데이터를 보내면, 이를 이용해서 서버로 하여금 새로운 데이터들을 생성/변조/삭제하기 위해 사용하는 http 메서드 
                        -> (중요) 요청시 http의 head 부분에는 url과 http메서드만 보일 뿐, client(유저)가 보낸 parameter는 body 부분에 놓여있어 보이지 않음
                        -> PUT, PATCH, DELETE를 대체할 수 있는 범용성 높은 http 메서드
                        -> 동일한 요청을 연속적으로 수행하면, 여러 리소스가 생성될 수 있음 = 데이터가 변조되기에 안전 X한 http 메서드

                 3) PUT
                     : 서버로 보낸 내용이 기존 리소스의 모든 데이터를 빈 칼럼값까지 완벽하게 대체하여 수정하는 데 사용하는 http 메서드
                        -> (중요) 업데이트 하는 내용이 유저가 보낸 내용과 완전히 동일함 = 동일한 요청을 연속적으로 수행해도, 같은 결과가 나옴 = 데이터가 변조되지 않기에 안전한 http 메서드

                 4) PATCH
                     : 서버의 기존 리소스를 부분적으로 업데이트하는 데 사용되는 http 메서드
                        -> (중요) 업데이트 하는 내용이 부분적으로 지정되어 있음 = 동일한 요청을 연속적으로 수행해도, 같은 결과가 나옴 = 데이터가 변조되지 않기에 안전한 http 메서드

                 5) DELETE
                     : 서버에서 데이터를 제거할 때 사용하는 http 메서드
                        -> (중요) 삭제할 데이터는 특정한 값을 기준으로 정해져 있음 = 동일한 요청을 연속적으로 수행해도, 같은 결과가 나옴 = 데이터가 변조되지 않기에 안전한 http 메서드


              - http 메서드가 get, post 이외로 더 생기는 이유

                 1) http 메서드의 갯수가 많아지면, 메서드명 자체에 의미적(semantic)인 부분을 고려할 수 있게 되고, 유저나 개발자가 해당 http API의 의도를 더 쉽게 파악할 수 있음
                 2) 같은 url이라도 http 메서드가 다르면, 동사적인 의미(semantic)자체가 달라지기에, 다른 http API로 구분될 수 있기 때문
                     -> class에 따른 집합의 존재로 같은 변수명들의 구분이 가능하여, 변수명 짓기의 스트레스에서 쉽게 벗어나는 같과 같이, url 설계에서도 스트레스가 많이 사라지게 됨

      # JS기반 언어에서 Ajax(Asynchronous JavaScript and XML) 사용하는 방법

         1. XMLHttpRequest라는 옛날 고전적인 js에서의 ajax 문법 사용
         2. js ECMA6 이후 등장한 fetch() 사용
         3. axios라는 js 외부 라이브러리 사용

      # axios VS fetch

         1. 공통적인 부분
             1) 둘 다 JS의 promise가 상태를 관리하여 다른 코드가 비동기적으로 실행될 수 있도록 만드는 객체인 Promise 객체의 API를 기반으로 사용하여 구현된 기능
             2) 둘 다 JS의 사용자가 서버로 http 메서드 + url로 요청을 보내는 짓은 비동기로 병렬적 실행을 하지만, 각 요청은 요청에 대한 결과가 나올 때까지 기다려야 함..
                 -> 각 http 메서드를 통한 요청에 대한 결과를 기다린 뒤에는? 
                     a. then(), catch(), finally() 함수
                         : 비동기 작업의 '성공 or 실패 or 무조건 실행' 이라는 조건에 맞춰 try, catch, finally와 유사한 느낌으로 then(), catch(), finally() 함수를 연쇄적으로 사용해서 시도에 대한 성공 실패여부를 따지는 조건분기 진행루트를 만들 수 있음
                        (= try ~ catch가 switch 문법 기반이니 만큼, then(), catch(), finally() )
                 
             3) (둘 다 ajax 방식으로 서버와 통신하기에) 받아오는 데이터는 json이나 html종류를 받아옴
             4) (둘 다 ajax 방식으로 서버와 통신하기에) 비동기식으로 병렬적으로 코드를 수행함 = 연달아 들어오는 fetch()나 axios 구문이 있으면, 거의 시간차 없이 수행된다 보면 됨
                 -> 그래도... 동시에 수행하는건 아니기에.. 어쩄든 진짜 여러 ajax 요청들을 최대한 동시기에 비동기적으로 보내기 위해 사용하는게, js의 Promise 객체의 정적 함수 임 
        
         2. 차이점

             - axios 특성
               1) 장점
                   a. 받아오는 json 형식의 데이터를 사용자가 보기 좋게 자동으로 array로 변환해 줌
                   b. http메서드를 단순히 axios 객체의 멤버함수로 제공해서 쓰게 함으로서, 개발자로 하여금 직관적으로 http 메서드를 사용하게 함

               2) 단점 : 외부 js 라이브러리이기에 어쩄든 개발자가 조금이라도 번거로워지고, 서비스에서 로딩시간 증가에 영향을 줄 소지는 있음

             - fetch()
               1) 장점
                   a. ECMA6에서 기본으로 지원되는 함수라서, 별 다른 과정없이 그냥 써먹을 수가 있음

               2) 단점
                   a. 받아오는 json 형식의 데이터를 자동으로 array로 변환해주진 않아서, 요청이 성공해서 데이터를 받으면 이를 변환하는 코드가 추가되어야함
                   b. axios 라이브러리 처럼, http메서드를 단순히 axios 객체의 멤버함수로 제공해서 쓰게 하는게 아니라... 2번쨰 parameter로 js객체 형식으로 옵션값을 통해 http 메서드의 속성들을 하나하나 지정해줘야 함


  @ axios 라이브러리

      # axios 라이브러리 설치 및 모듈 불러오기 명령어
         : npm install axios
           import axios from 'axios'

      # axios 특성
        1) 장점
            a. 받아오는 json 형식의 데이터를 사용자가 보기 좋게 자동으로 array로 변환해 줌
            b. http메서드를 단순히 axios 객체의 멤버함수로 제공해서 쓰게 함으로서, 개발자로 하여금 직관적으로 http 메서드를 사용하게 함

        2) 단점 : 외부 js 라이브러리이기에 어쩄든 개발자가 조금이라도 번거로워지고, 서비스에서 로딩시간 증가에 영향을 줄 소지는 있음

   
      # axios로 http 메서드 요청을 보내는 문법
         1) axios.get('url명')  
             : 해당 url명으로 get요청을 하게하는 axios 라이브러리의 멤버함수
   
         2) axios.post('url명', {name : 'kim'})
             : post는 요청자가 데이터를 보내면, 그걸 서버가 가공한 후 response를 보냄
   
         3) 요청에 대한 리턴이 등장하면.. promise 객체의 상태값에 따라 후속 처리를 하면 됨
             -> 상단의 then(), catch(), finally()나 async, await 구문 참고


      # axios 사용시 주의사항
         1) json으로 돌아온 응답값은 axios에서는 json -> object array 형태로 자동 변경해 줌..
         2 '결과값명.data'로 사용자가 원하는 object array 데이터 꾸러미를 받고, 가공할때는 array에서 멤버객체를 지정해 시작하자
             -> 안 그러면, 사용자가 바라는 요청데이터 이외에, 어마어마한 상태값을 가지는 object나 array가 그냥 통쨰로 들어오고 타입에러가 생김


  @ fetch()
     : 비동기 작업으로 네트워크를 통해 리소스를 가져오는 ajax 기능을 수행하는데 사용되는 Promise API를 기반으로 작성된 JS함수, 기본적으로 return의 결과로 Promise를 반환하여 각 작업들은 결과에 따른 분기 처리도 가능함

      # fetch() 특성
         1) 장점
             a. ECMA6에서 기본으로 지원되는 함수라서, 별 다른 과정없이 그냥 써먹을 수가 있음
 
         2) 단점
             a. 받아오는 json 형식의 데이터를 자동으로 array로 변환해주진 않아서, 요청이 성공해서 데이터를 받으면 이를 변환하는 코드가 추가되어야함
             b. axios 라이브러리 처럼, http메서드를 단순히 axios 객체의 멤버함수로 제공해서 쓰게 하는게 아니라... 2번쨰 parameter로 js객체 형식으로 옵션값을 통해 http 메서드의 속성들을 하나하나 지정해줘야 함

      # fetch() 함수 호출로 http 메서드 요청을 보내는 문법구조..
         : 크게 '요청' -> '응답' -> '결과값으로 가공' 이렇게 3개의 단계를 가지며.. 요청에 대한 응답에서 문제가 생기면, 그냥 catch()를 통한 에러처리..
       
         1) fetch() 함수를 사용하여 http '요청' 보내기
             : 함수의 parameter로 url 주소는 필수로 입력해야 함
               (= headers나 method와 같은 멤버가 있는 객체타입 파라미터인 options는 필수는 아님)

               - options 객체 parameter의 멤버

                  a. headers 멤버객체
                      : http요청에 설정할 header 영역 정보 가짐

                  b. method 멤버변수
                      : get 이외의 메서드 사용시 적어야 함

                  c. body 멤버변수
                      : post 메서드와 같이 요청시 서버에 '문자열' or Form 데이터, blob 등의 값을 보내는게 있을시 사용 
                         -> (주의) 본문이 문자열일 때 Content-Type 헤더가 text/plain;charset=UTF-8로 기본 설정 
                                  (= json같은거로 응답 받으려면, 헤더에 Content-Type 에 대한 값을 'application/json;charset=utf-8'로 작성해 야함 )
 
              ex) fetch('url명', { headers : { 멤버1 : 값1 , ... , 멤버n : 값n} ,
                                   method  : '메서드명' ,
                                   body    : '문자열' or Form 데이터, blob 등  });

         2) 서버로 부터 데이터를 받은 '응답' ->'결과값' 가공
             : 요청에 대한 응답이 도착했으면, then()이나 await 를 사용하여 응답으로 받은 값을 소위 response(이름은 뭘로해도 상관없음.. 단지 요청에 대한 결과를 품는 promise객체를 의미하면 됨) 메서드라는 promise기반 함수를 통해 원하는 타입으로 변경하는 후속처리 감행
               (= axios는 이 부분에 대해 기본적으로 json() 함수로 변형을 하고, 이걸 또 object array로 자동으로 변형해주는 셈)

               - response 메서드
                 : 응답값 본문을 원하는 타입으로 바꿔줘서 후속처리를 할 수 있게 도와주는 promise기반 함수
                    -> (주의) input 자체가 애초에 object만을 대상으로 하기에, response.text().json() 이런식으로 중첩사용이 안 됨

                    a. response.text()        : 응답값을 text로 변환해 반환
                    b. response.json()        : 응답값을 JSON 형태로 파싱해 변환해 반환
                    c. response.formData()    : 응답값을 FormData 객체 형태로 변환해 반환
                    d. response.blob()        : 응답값을 Blob(타입이 있는 바이너리 데이터) 형태로 변환해 반환
                    e. response.arrayBuffer() : 응답값을 ArrayBuffer(바이너리 데이터를 로우 레벨 형식으로 표현한 것) 형태로 변환해 반환
                    f. response.body          : 응답값을 본문을 청크 단위로 읽을 수 있음
                 
                  ex) await 방식
    
                      let response = await fetch('https://api.github.com/repos/javascript-tutorial/ko.javascript.info/commits');
                      let commits = await response.json();
                      alert(commits[0].author.login); 
    
                  ex) then() 방식
    
                      fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
                      .then(response => response.json())
                      .then(commits => alert(commits[0].author.login));

               - response의 멤버객체 header
                 : 요청시 option 객체에 header에 대한 멤버변수 정보를 보냈으면, 응답시 해당 header 값에 대한 정보도 같이 나오는데.. 이를 response객체를 통해 호출 가능
                    -> (참고) 멤버변수 : 멤버값 형식으로 저장되기에 key, value 형식으로 꺼내쓰기도 됨

                  ex) await 방식
    
                      let response = await fetch('https://api.github.com/repos/javascript-tutorial/ko.javascript.info/commits');
                      let header = await response.headers.et('요청할 header명');
                      alert(header); 

                      for (let [key, value] of response.headers) {
                        alert(`${key} = ${value}`);
                      }
    
                  ex) then() 방식
    
                      fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
                      .then(response => response.get('요청할 header명'))
                      .then(header => alert(header));


               - 그 외 response의 멤버변수들
                  a. response.status : 응답의 HTTP 코드
                  b. response.ok     : 응답 상태가 200과 299 사이에 있는 경우 true           


  @ localStorage & sessionStorage
     : 웹 브라우저에서 데이터를 저장하는 데 사용되는 옵션들
       (= 서버가 아닌 client 쪽에 저장해서 사용할 로직과 이에 필요한 데이터를 저장하는 공간)      

      # localStorage & sessionStorage 공통 특징
         1) 문자열만 저장 가능
         2) key, value 형식 저장
         3) 수정 불가 (= 삭제 후 생성 다시 해야..)   

      # localStorage & sessionStorage 차이점
         1) 데이터 수명
             - localStorage   : 사용자가 정리하기 전까지 유지
             - sessionStorage : 사용자와의 현재 세션이 유지되는 동안만 유지 (= 탭이나 브라우저 종료되면 삭제)      

         2) 접근 범위
             - localStorage   : 동일한 도메인(사이트) 내의 모든 웹 페이지에서 공유됨 (= 그 이외의 웹페이지에서는 참고 불가)
             - sessionStorage : 사용자와의 현재 세션이 유지되는 동안 모든 탭 간에 공유가 가능      

         3) 용도
             - localStorage   : 지속적인 상태 정보(ex : 유저 설정, 로그인 정보)
             - sessionStorage : 임시 정보 (ex : 장바구니 정보)     
              
         4) 저장 크기
             - localStorage   : 도메인(사이트)마다 5MB
             - sessionStorage : 20MB      

      # localStorage & sessionStorage 메서드

        - localStorage & sessionStorage.setItem(key값, value값)
           : 브라우저의 localStorage 항목에 key, value를 저장하기 위한 localStorage 객체의 내부함수  

        - localStorage & sessionStorage.getItem(key값)
           : 브라우저의 localStorage 항목의 해당 key에 있는, value를 추출 위한 localStorage 객체의 내부함수    

        - localStorage & sessionStorage.removeItem(key값)
           : 브라우저의 localStorage 항목에 해당 key에 해당하는 key, value를 삭제 위한 localStorage 객체의 내부함수     


  @ JSON 전역 객체
     : JS에서 JavaScript Object Notation(JSON)을 분석하거나 값을 JSON으로 변환하는 메서드를 가지는 전역객체  

      # JavaScript Object Notation(JSON)
         : Javascript 객체 문법을 따르는 문자열 기반의 데이터 포맷으로.. 베이스가 된 문법이 JS의 object일뿐 어디서나 쓸수 있는 범용적 데이터 포맷
            -> JSON의 특성
               1) JSON은 순수히 데이터 포맷 (= 멤버변수 O , 메서드 X)
               2) 프로퍼티와 값을 구분시, 큰 따옴표("") 만 사용해서 구분할 수 있음
               3) JSON은 '문자열'로서 JSON은 그 전체에 해당하며, 이를 파싱(paring)하여 JS Object로 쓸 수 있게 변환함
                  (= JSON 형식 데이터 그 자체로는 JS object 마냥 객체명.프로퍼티명 or 객체명['프로퍼티명']; 이런식으로 쓸 수 없음)      

      # JSON 메서드
        - JSON.stringify(array/object 변수)
           : paramter의 array/object -> JSON 변환하여 문자열로서 저장 가능하게 하는 JSON 객체의 내부 함수
              -> 선택 사항으로 특정 속성만 포함하거나, 사용자 정의 방식으로 속성을 대체 가능      
              
        - JSON.parse(JSON 형식 구문)
           : paramter의 JSON 형식 문자열을 JSON으로서 구문 분석하여, JSON구문 -> array/object나 숫자 문자 반환
              -> 선택적으로 분석 결과의 값과 속성을 변환해 반환
                  -> BUT! object의 함수는 받아주지 못함


           





