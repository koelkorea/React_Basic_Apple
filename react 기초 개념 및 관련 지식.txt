 [functional component를 기준으로 작성된 설명임을 밝힘]
   -> class component도 하단에 언급함.... 추후 class -> function으로 넘어가기까지의 역사나 hooks에 관련된 역사적 부분까지 정리할 예정

 react 라이브러리 사용시 jsx 형식을 사용하며, 그 내부에서 사용자지정 HTML 태그와 같은 <App>으로 명명되는 HTML conponent를 제작.. 
  -> react 라이브러리는 index.js에서 ReactDOM.createRoot(document.getElementById('root')).render 함수 안에 이런 conponent를 조립해서 블록으로 장난감 만들듯 구성한 페이지
     -> ReactDOM 라이브러리의 static함수인 render API를 통해, 이를 최종적으로 index.html의 root라는 id의 div태그에 전달함으로서, 브라우저가 rendering을 하게 함

 - jsx(java script extention)란 무엇인가?
    : js에 자체적인 확장 문법을 곁들은 형식의 언어로 이를 통해서 react는 프로그래머에게 코딩의 직관성과 편의성을 강력하게 제공함
       -> 1. js에서 HTML component 작성을 통해, html 구성의 기본 벽돌과도 같은 component를 html 형식의 문법 거의 그대로 사용해서 쉽게 만들 수 있음
              : 일단 component를 만들어두고, 모듈러를 통해 가져온다면 <컴포넌트명> 형식으로 작성하여, 작성한 html 코드를 쉽게 재사용이 가능함
                 -> (주의!) 단! 반드시 component는 하나의 <div> 태그만을 최상위 부모로 가지고 있어야 함
                            (= 병렬의 div를 짜지 말라는 말... component는 말 그대로 jsx를 통해 작성하는 html의 최소단위라고 보면 됨)
       -> 2. 어떤 component를 구성하는 특정 html 태그의 이벤트핸들러 안에서만 통용되는 스코프를 {}를 통해서, 해당 html component가 사용자의 조작에 반응하는 반응형 componen
              -> 해당 html영역에서만 통용되는 js변수를 선언하고, component에서 선언한 js변수를 쉽게 {}안의 js변수(보통은 state)와 대입함으로서 'DOM조작 명령어 없이' 해당 c
                  : 이를 추후 서버로 부터 데이터를 받는 것 + state의 set함수를 통한 변경시 조건부 랜더링이라는 특성과 props를 통해 이를 타 compoenent에 전달하는 법을 조합
       -> 3. 시멘틱 + get, set 캡슐화 구현 + 변경시 rendering 자동 수행되는 state와 다른 자식 component에 '일괄적'으로 html 속성을 넣는 형식으로 다양한 형태의 값들을 전달
              - state : 해당 페이지 안에서만 쓸 지역변수로서의 목적을 가지고 선언한 get, set 로직이 적용된 변수
              - props : '부모 component -> 자식 component'로 '일괄적'으로 html 속성을 넣는 형식으로 다양한 형태의 값들을 전달하기 위한 목적을 가지는 js객체
                        (= props의 핵심은 부모 component에서 속성을 적고, 그 값으로 부모 component의 state값을 넣어 또한 전송할 수 있다는 점에 있음!)
                           -> 누군가의 자식인 component는 component들은 'props'의 역할(일반적으로는 props라 지음)을 하는 parameter를 단 1번만 받음

  # js가 아나라 jsx(java script extention)를 쓰는 이유?
    : 순수 js만 써서하려면... 그냥 React.createRoot 함수를 짤없이 써야하는데, 이거보단 그냥 html 흉내라도 내게 하는게 더 직관적이라 jsx를 씀
       -> babel 같은 ECMA5 JS 이전 버전으로 호환성 맞추는 컴파일러를 쓰면 다 확인이 어느정도 가능함을 확인 가능

  # (주의!!) jsx(java script extention)도 엄밀하게는 js를 기반으로 함
     1. js에서 예약어로 쓰이는 단어인데, HTML component에서도 속성으로 사용하는 단어가 있는 경우는 이를 다르게 쓸수 밖에 없음을 명심해야.
        -> 그 대표적 CASE가 class로.. js에서는 class 타입을 선언할 때 사용하며, html에서는 html 요소의 속성으로 사용되기에... 그 양자는 서로 구분될수 있어야함
           ex) class -> className
     2. style 속성도 작성시 'style = { {key : 'value' , key : 'value' } }' 형식으로 작성해야 한다는 불편함이 존재함    
        -> 엄밀하게는 js지 html이 아니기에 style을 기존 html 형식으로 ""안에 통쨰로 작성하면, js 문법으로는 도저히 해석하도록 코딩하기가 어렵기에..
            -> 그래서 js 객체 형식인 {key : value}을 이용해서 style이 jsx 형식에서 코딩 가능하도록 구현
     3. style 속성의 세부 속성들 중 font-size 같이 '-'가 들어 간 녀석들은 fontSize 값이 일종의 camalCase 형식으로 바꿔야함
         -> js에서 -은 -연산자로서 작동하기 때문
           ex) <h1 style= "color : red", font-size : '16px'>  ->  <h1 style={ {color : 'red' , fontSize : '16px'} }>

 - {}문법의 포텐셜
     : 스코프{} 영역은 고립된 js 지역변수들의 영역이기에, 여기서 js변수를 선언해서 손쉽게 component 차원에서 선언된 JS변수(state, props와 연관)에 값을 대입하기만 하면,
        ->  HTML 그 어떤 요소(속성, contents 등 어디를 불문하고) 에서라도 data binding(= 내용이 자동으로 반영)됨
            -> (중요!) 최종적으로 state, props객체의 전달값 변경과 연동된 render API를 통해, DOM조작 없이 내용을 바꾸면서 자동으로 render되게 만드는 시발점이 됨

  # js 변수가 있는데, state변수나 props객체를 써야 하는 이유?
     : 1. 분명한 용도적 의미를 가지며
       2. js의 구조 분해 할당(destructuring assignment) 문법을 통해 구현한 getter setter 로직을 써서 캡슐화를 구현함
       3. (가장 핵심적인 이유!) state 변수 , props객체의 멤버변수의 값 변경 = 자동 rendering의 트리거 조건
          (= 기존 js 변수들처럼 이벤트핸들러 같은 짓으로 DOM조작 코드를 짜지 않아도, 값 변경시 이들과 연관된 html 태그만 rendering이 자동으로 실행되는 기적을 맛 볼수 있
 - state 
    : 해당 페이지 안에서만 쓸 지역변수로서의 목적을 가지고 선언한 get, set 로직이 적용된 변수 + state값의 변경이 감지시 해당 html 재rendering 
      (= 해당 component에서 값이 변경되었을때, html에 자동으로 내용이 반영되고 rendering되게하고 싶을 떄? state를 사용 ㅇㅋ) 

    # (중요) state 과거사
       : state도 원래는 props와 마찬가지로 object 속성이며, functional component 기준으로 구조분해 할당과 useState 함수를 통해 만들어진 개별 state들은 state객체의 멤버속성

    # state 사용법
       1. 변수타입 [getter함수의 별칭, setter함수의 별칭] = useState('변수가 담을 value값'); 작성
           -> 참고로 parameter로 들어갈 내용을 []을 통해 여러개 담아도 사용가능함

       2. {} 문법을 통해 conpent의 원하는 자리에 사용함

           @ getter함수의 별칭
              : 해당 state값을 조회하고 싶을때 사용하는 변수명
                 (state getter함수의 사용법) 
                   : getter함수의 별칭
                      -> state 배열을 사용했을 경우?
                          : 'getter함수의 별칭[index]'로 원하는 state요소에 접근 가능

           @ setter함수의 별칭
              : 해당 state값을 수정 + 변경된 state값을 반영한 html영역을 다시 rendering 하도록 조치하고 싶을때 사용하는 변수명
                 -> 이 setter 역할의 함수는 비동기방식(= 병렬로 다음코드를 계속 처리)으로 재rendering 처리되어서, rendering의 결과가 당장에 반영되지 않고, 화면에는 늦게 반
                 (state setter함수의 사용법) 
                   : setter함수의 별칭(state가 될 value or 연산식 or 변수명);
                      -> (중요) set함수를 쓰지 않아도, state를 바꿀수는 있지만...
                                자동 rendering의 작동 트리거는 set함수를 통해 state를 변경하는 것이기에 state에 set을 안쓰는건 react를 사용할 의미가 없다는 점과 같음을 명
                      -> (중요) state 배열을 사용했을 경우? 
                          : 'setter함수의 별칭(배열변수 or 배열 그 자체)' 와 같이 parameter로 배열이 들어가게 해야함
                              -> 이 또한 js의 구조분해 할당 문법의 원리로 작동
                                 (= '주는쪽 배열의 요소개수 != 받는 쪽 배열의 요소개수'  ->   대입이 가능한 index에 해당하는 요소들만 대입하고, 나머지 index는 관련 X)
                              1. setter함수의 별칭(배열 그 자체)를 통한 state 배열 수정
                                  : 'setter함수의 별칭[수정내용1, 수정내용2 , ... ]'로 배열 그 자체를 parameter로 투입해서 원하는 state요소를 순차적으로 일괄 변경도 가능함
                                      -> But! 이렇게 state 배열을 사용하면서 setter 또한 배열로 parameter를 줘서 사용하면.. 유지보수나 확장성이 아예 병신이 되므로 추천은 
                              2. setter함수의 별칭(배열변수)를 통한 state 배열 수정
                                  : let 배열명 = [...타 배열변수명]'로 스프레드 문법(spread syntax)을 통한 state 배열을 깊은복사를 한 뒤,
                                    배열명[index] = '원하는 value값' 과 같은 식으로 새로 선언된 배열의 원하는 index의 요소에 원하는 값을 대입하고,
                                    'setter함수의 별칭(배열명)' 과 같은 식으로 원하는데로 값이 수정된 state배열로 수정 
           
                                 ex) let [states, setStates] = useState(['내용1', '내용2', '내용3']);
                                      : 여기서 states라는 state는 state배열로 선언되었고, component에 2번째 요소인 '내용2'에 대한 부분을 담고 싶은 html 태그가 있다면?
                                          -> getter의 경우 : { states[1] }; 이런식으로 작성함
                                          -> setter의 경우 : 
                                              1. 배열 그 자체 parameter로
                                                  : { setStates(['내용1', '내용4', '내용3']); } 이런식으로 set 함수를 통해 변경 
                                              2. 깊은복사한 배열변수 parameter로 
                                                  : let copyArray = [... state]; 로 스프레드 문법(spread syntax)을 통한 state 배열을 깊은복사를 한 뒤
                                                    copyArray[1] = '내용4';
                                                    setStates(copyArray); 이런식으로 작성
 - props 
    : '부모 component -> 자식 component'로 html 속성을 넣는 형식으로, 부모 component의 {} 제한을 넘어 '일괄적'으로 다양한 형태의 값(일반문자도 가능)들을 전달하기 위한 목적
      (= props의 핵심은 부모 component에서 속성을 적고, 이를 통해 부모 component의 state값 또한 전송할 수 있다는 점에 있음!)
         -> 해당 component에서 부모 componont에서 값들을 받아 사용하고 싶고, 변경사항이 생길시 자동으로 다시 전달되어 내용이 반영되고 rendering되게하고 싶을 때? props를 사
       
    # props 사용법
      1. <자식components props속성명1 = { state명 } props속성명2 = "속명2 내용" props속성명 = {속성3 속성값} /> 형식으로 'props속성명'과 그에 해당하는 값을 { js객체명 }이
      2. 자식components의 function에 'props'에 해당하는 parameter를 적음
      3. 자식components 안에서 { props.속성명 } 형식으로 부모 component로 부터 전달받은 props 속성을 골라서 사용 
         ex) function App (){
               let [글제목, 글제목변경] = useState(['남자코트 추천', '강남 우동맛집', '파이썬독학']);
               return (
                 <div>
                   </ Modal 글제목전달={글제목}         <- 부모 component <App>에서, 자식 component <Modal>에 '글제목전달'이란 속성명에 '글제목' 이란 부모의 state값을 대입
                            color = "blue"     >      <- 부모 component <App>에서, 자식 component <Modal>에 'color'이란 속성명에 'blue'란 문자열 값을 대입해서 props객체의 
                 </div>
               )
             }
             
             function Modal(props){
               return (
                 <div className="modal" style={{ background : props.color }}>     <- 자식 component <Modal>은 부모가 전달한 props객체에서 'color'라는 멤버변수의 값을 꺼내
                   <h4>{ props.글제목[0] }</h4>                                    <- 자식 component <Modal>은 부모가 전달한 props객체에서 '글제목'이라는 부모의 state값인 
                   <p>날짜</p>
                   <p>상세내용</p>
                 </div>
               )
             }
  
    # props객체 핵심적인 특성 및 전달 방식의 장, 단점
       : props 객체는 부-자 component에서만 통용되는 일종의 지역객체 + 부모 -> 자식 편도적 전송 흐름 + 전송의 대상도 부-자 component에만 한정
          -> 단점인 노가다로 인한 개발자의 실수를 줄이고자, 일부 자주 사용되는 props로 전달되는 값을 아예 전역변수로서 관리하자는 취지의 의견 등장
              -> redux 라이브러리의 탄생
  
          @ (장점) 
             : 개발자가 생각해야 할 side effect가 적음
                1) 지역변수로서 다른 component에 영향 X 
                2) component간 값의 흐름을 예측하기 쉬움 
                3) 전송되는 값이 개발자가 적은것에 한정되어 딱 정해짐 
  
          @ (단점)
             : 값의 지속성이 일시적 + 전달 시 값의 나열도 일일히 해줘야해서 노가다가 심하기에 관리하기가 힘듦...
                1) 자신의 영역에서만 살아있는 지역변수를 계속 쓰려면 다른 component에 전달, 전달의 연속  
                2) 자주 사용되는 값일수록, 노가다를 통해 매번 개별 다른 자식 component의 속성으로 나열해서 props객체로 값을 보내야 하는 반복의 노가다를 맛봐야 함
                3) 철저히 1:1 구조의 component간 일방적 전송이라... 그 밑의 후손들에게 전달할거면 마찬가지로 2)의 노가다를 또 겪어야 함..
  
    # (중요) props 의 특성
       : 순수 react의 props객체의 전달 대상은 '부모 -> (개별) 자식' +  자동으로 더 후손 component로 전달도 X 라서... 
          -> 전달할 props객체의 멤버변수와 자식 component의 머리수가 많아지면? 그거 관리하는게 사실상 노가다에 가깝고, 개발자의 실수로 인해 많은 삽질이 발생할 소지가 있음
             (= 대부분의 component들이 쓰는 공통의 속성값의 경우, 전역객체 props를 통해 관리되어야 할 필요성 존재)
                 -> redux의 등장
  
      1. props를 통해 부모 component는 함수나 클래스 {}제한을 넘어, 사실상 다른 함수나 클래스 {}에 속한 자식 component에 값을 전달할 수 있음
      2. (중요!) 반드시 '부모 -> (개별) 자식' 으로만 일방적으로 전달됨
           -> 자식 -> 부모, 형제끼리 props객체 전송 같은건 불가능
               -> 따라서, 어떤 state를 사용하는 component그룹이 있다면, 거기서 가장 상위의 선조 component에게 state를 선언해두는게 좋음
               
      3. 각 props객체를 구성하는 멤버변수들은 개별 component만을 기준으로 일종의 지역변수 개념으로 작성됨
         (= component만 다르면 속성명 겹쳐도 상관 없음)  
  
      4. (3번의 지역변수 개념에 의거..) props객체는 개별 component 단위로 전송되며, props에 들어갈 멤버변수는 반드시 해당 자식 component에 속성형식으로 일일이 열거되어야 
         (= 자식 component가 자신의 아들 및 후손 component에 값을 보내고 싶으면, component마다 props객체의 멤버로서 전달할 속성을 일일히 기입하는 노가다를 뛰어야 함) 
            -> 그거 ㅈ같아서 몇몇 변수는 전역객체 props로 전달해서 쓰기위해 만든 라이브러리가 redux!
  
    # props 사용시 유의점
      1. 부모 component 측에서 props로 전송 가능한 속성의 갯수는 제한이 없음
      2. props 객체의 멤버변수로 들어가는 속성에 들어갈 수 있는 값의 자료형 또한 제한이 없음
         (= 부모 component의 state값 또한 전송가능한 수많은 자료형의 일부에 지나지 않음)
            -> (중요!) 심지어 함수도 전송이 가능!
  
      3. props 객체를 전송받는 자식 component는 parameter로 받는 props객체를 객체 그 자체로 1번만 받고, 거기서 필요한 멤버변수를 꺼내서 그 값을 component 구현에 사용함
          -> parameter명에 props라고 이름까지 정해져 있진 않지만, 일반적으로 props로 적음  
  
      4. 자식 component로 전달된 props객체는 값의 수정을 위한 접근이 일반적으로는 불가능함
         (= 전달된 props객체는 일종의 값들이 새겨진 앍기전용의 상수 창고로서, 값의 복사는 가능해도 수정은 불가능하다 생각하면 이해가 쉬움)
  
      5. (중요!) 하지만! props객체를 통해 전달된 setstate 함수를 통해서, 부모의 state 변수 자체를 수정하는 방식으로 부모 component의 값을 통제하는 것은 가능함!
           -> 애초에 props를 통해 부모 component의 state를 이용한 권장사항이기 때문에 당연히 잘되는게 당연함
  
      6. (중요!) 그렇지만, props객체에 유저가 수정을 위한 접근이 불가능할 뿐이지, 5번 이외의 이유로도 변동이 생기면, 재rendering이 시작되고 반영된다는 점은 명심해야 함
           -> props객체로 전달된 setState로 부모 component의 state값을 통제하여 rerendering을 유도하고, 그로 인해 props객체가 다시 값을 가져와야 할 필요로 인한 변화는 의도
              (= props객체의 전달값 중 부모의 state값에 해당되는 부분이 수정되어 변해서 다시 전달되는거 상황말고, 다른 props값에 해당하는 부모 component의 속성값이 직접 수
  
                 ex) function ParentComponent() {
                       let color = 'red';
                     
                       setTimeout(() => {
                         color = 'blue';             <- setTimeout()을 통한 props객체에 포함되는 속성값의 강제 수정을 유도하여, props객체의 변화까지 인위적으로 이끌어내는 
                       }, 1000);
                     
                       return <ChildComponent color={color} />;
                     }
                     
                     function ChildComponent(props) {
                       return <div style={{ background: props.color }}>Hello, World!</div>;        <- props.color의 값 변경으로 ChildComponent가 rerendering
                     }
  
    # 자식 -> 부모, 형제 -> 형제 끼리 component 전송이 불가능한 이유에 대한 추론?
       : 애초에 호출된 component을 react팀은 자식 component라 정의하고, 거기에 html 속성 형식으로 사용자가 적은 값들에 대해서는 부모 component가 타 component를 호출하는 것
         (= 애초에 component 호출을 통한 접점 관계를 부모 - 자식이라 명명함 + 형제관계나 자식 - 부모 관계는 그렇게 값을 전달할 방법이 로직적으로 존재하지 않음)

- Context API
    : props는 컴포넌트의 계층구조가 깊어지고 넓어지면 사용하는게 노가다에 가깝다는 것을 해결하기 위한 방책 중 하나로 react에서 기본제공하는 API
       -> 대충 공유한 state정보를 저장하는 context 객체를 생성하고 나면, 그 context객체에 접근가능한 component를 지정하고 state의 종류를 지정해서, 해당 컴포넌트의 후손들이 자유롭게 state에 접근가능하게 함 

    # 사용법
       1) createContext()로 context 제작
       2) 해당 context를 사용할 component를 <context명.Provider> 태그로 감쌈
       3) <context명.Provider> 안에 value 속성을 추가하고, 공유할 state들을 js {}안에 속성 객체형식으로 나열해 작성함
       4) 제작한 context를 export 처리하고, 사용할 component 파일에서 해당 context가 저장된 변수를 import함
       5) useContext(context명)라는 reacthooks 함수를 사용하여, 제작된 context1안의 state 들을 state 객체 형식으로 변환해서 반환함
       6) 5번을 통해.. props 문법 없이 해당 component와 후손들이 context안에서 공유하기로 한 state값들을 static 값 마냥 가져다 씀  

          ex) export let Context1 = createContext(); 
              <Context1.Provider value={{ stock, shoes }}>
                 <Detail shoes = {shoes} /> 
              </Context1.Provider> 
              ------------(다른 component가 있는 jsx 모듈 안에서...)-----------
              import { Context1 } from '파일경로'; 
              ------------(원하는 Detail가문 내 compoent안에서..)--------------
              let example = useContext(Context1);
                -> example.state명[index번호] 식으로 사용 

    # (주의) Context API를 잘 안쓰는 이유
        -> (중요!) 결론 : 이 2가지 이슈들 문제로... 아예 전역으로 쓸 state를 나열하고, 별 문제없이 가져다 쓰게하자는 외부 라이브러리 'redux'를 쓰게 됨 

        1) Context랑 연관된 전체 component 가문들의 경우 무지성적 rerendering 이슈
           : 해당 context의 state를 안쓰는 component들도 만약 context를 쓰기로 한 component의 가문 안에 소속된 경우...
              -> context의 state들을 쓰던말던 걔들이 변경될때마다, 모든 가문구성원 component들은 일괄적으로 rerendering 됨...
                 (= 비효율적인 rendering 이행으로 인해, 컴퓨터 자원 낭비가 심하고, 성능으로 말이 안 나올수가 없음) 

        2) Context를 직접 사용한 component는 재사용이 어려움
           : 어차피 component에서 context를 가져다 쓸거면, 또 모듈로 context, useContext를 모듈로 가져와야 하는데? 
               -> 그렇게 API가 적용된 component를 또 다른 모듈에서도 재사용을 하게 되어 중첩되기 시작하면?
                   -> 결국 기존 props처럼 프로그래머의 노가다를 요구하게 되고, 사람의 실수로 인한 비효율적 문제가 터져나오게 됨

 - component 란?
    : react 라이브러리에서 JSX(JavaScript XML) 문법을 사용해서, 웹페이지의 상태(state)와 속성(properties)와 이벤트 핸들링을 수행하는 User Interface에서 rendering의 기본 단
       -> 쉽게 말해.. 다음과 같은 성질을 전부 가짐
           1. component는 js를 기반으로 작성된 일종의 HTML 요소로서, react에서는 rendering 기본 블록같은 단위를 의미
           2. component는 그 자체가 상태(state)와 속성(properties)을 가지고 이벤트헨들링까지 독립적(stand alone)으로 수행 가능함
           3. React.Component를 기반으로 그 자식 class로서 구체적인 component가 작성될 수도 있지만, 함수처럼 호출하면 즉시 관련 component를 return해주는 방식으로 사용도 가
           4. JSX(JavaScript XML) 문법 라는 특수 문법으로 구현
           5. component는 독립적으로 동작 가능 =  일단 만들어두면 다른 component에 가져다 붙여서 확장 가능 (= component tree 구조)
               -> 코드의 재사용성과 유지보수성을 높여줌 + 확장성이 뛰어나서, 복잡한 UI를 구현할 수 있음

           6. 다른 component에 호출된 하위 component는 호출한 component와 '부모 : 자식' 관계를 가지며, parameter를 통해 부모 component로부터 state들을 모은 js객체(= props)

    # component 사용의 주의점
       1. component는 일종의 rendering 가능한 html 요소 단위로서 1개의 component는 단 1개의 최상위 선조격 div만 가지고 있어야 함
          (= 애초에 component를 왜 쓰는지에 대한 semantic한 부분을 생각하고, 해당 component를 개발자가 왜 조각으로 만드는지 생각해야 함) 
             -> 굳이 써야 한다면? 빈 태그( <> <compoenent></compoenent> </>)로 나머지를 감싸는 fragment 문법을 쓰자

       2. component간 상태(state)는 공유 불가능이며, 부모-자식 간의 속성(properties)만 전달이 가능할 뿐임
          (= 쓸데없이 component를 쪼갰다가, 개발자 입장에서 인지 불가능한 수준으로 스파게티코드를 맛볼 수 있음)

       3. component만으로 구성된 배열을 만들수 있음
          (= 애초에 js에서 html 태그도 마찬가지로 배열로 만들 수 있음)
          ex) [<div>안녕</div>, <div>안녕</div>, <div>안녕</div>]       <- js에서 가능
              [<Modal/>, <Modal/>,  <Modal/>]                          <- jsx에서만 가능

       4. (중요) objects are not valid as a react child (found: object with keys { 문제있는 key명 }) 오류 주의!
            : react에서는 component를 rendering 하는 과정에서, 화면에 출력할 때 필요한 state나 props객체의 멤버변수가 가지고 있는 값이 '객체(object)' 자료형일 경우 renderi
               -> 문제의 핵심은 현재 rendering하라고 던져준 변수가 key : value 형식의 object라, react 상에서 뭘 화면에 띄어줘야 할지 모르는것에 있음
                  (= error 메시지가 어떤 key명이 문제의 쟁점인지 파악 후, 그런 key를 가지고 있을법한 object 객체를 가진 component가 무엇인지 찾아서, 그 객체가 자신의 value
                     ex) <h4>{ 글입력배열[i] }</h4>   ->   <h4>{ 글입력배열[i].입력값 }</h4>
                           : 글입력배열[i] 자체가 key : value를 가진 object라, 이를 문자열인 value만 가져올 수 있도록 '배열.key명' 문법으로 객체의 멤버변수를 지정함

    # component는 언제 쓸까?
       1. 반복적으로 잘 쓰이는 html요소
       2. 값이 자주 변경되어, state와 props가 필히 필요해서 관리해줘야 하는 html 요소들
          (= 너무 component를 잘게 쪼게면, 관리 단위로서 component가 의미가 없으며, state관리가 더 복잡해짐)
       3. 페이지가 큰 html 요소 

    # (중요) component의 Lifecycle (생명주기)
        : react의 화면 구성의 기초가 되는 component는 크게 'mount(생성) - update(vdom의 rerendering을 통한 부분적 변경) - unmount(삭제)'의 3단계의 상태에 해당하는 시기를 거친다는 것을 의미하는 용어
          (= 정확히는 component는 mount와 unmount 2가지 상태를 지니는데, component를 갱신하는 update = 'mount(생성) - unmount(삭제) - mount(생성)의 과정을 따르는 것과 같음을 기억하자')
              -> (중요) 해당개념이 중요한 이유
                   : component의 관련 기능을 구현하는 과정에서 lifecycle의 개념을 사용하는 'lifecycle 메서드'가 이와 연관되어 있으며, 그 중 어떤 내용을 component의 rendering 후가 되거나 제거 전에 수행하라는 코드를 삽입하는 'lifecycle hook'을 사용할 수 있기 때문
                     (= lifecycle hook의 존재는 개발자가 확실히 특정 코드의 실행 시기를 사실상 완벽하게 통제할 수 있음을 의미함)
                         -> (중요!) rendering 완료 전, 후라는 시점은 별거 아닌거 같아도, 어떤 요소나 데이터가 로딩이 되지 않아 에러가 나거나, 성능이 쓸데없이 낮아지게 되는 원인이 된다는점에서 아주 중요함!
    

    # (중요) component의 lifecycle method와 lifecycle hook

        1) lifecycle method
           : class component에서 lifecycle을 기준으로, 상태 관리와 lifecycle 관리 및 부수 효과 처리(side effect 처리) 등 다양한 리액트 기능들을 사용할 수 있게하는 위한 함수들의 집합

             ex) setState() : 상태관리 멤버함수
                 componentDidMount() :
                 componentDidUpdate() : lifeCycle 상태를 트리거 삼아 호출되는 멤버함수
                 componentWillUnmount() : 
                 shouldComponentUpdate() : 리렌더링을 진행할지 여부를 결정함수

        2) lifecycle hook  
            : class component의 lifeCycle의 특정 시점에 실행되는 멤버함수 componentDidMount, componentDidUpdate, componentWillUnmount 통칭하는 함수집합
               -> hook의 의미는 일종의 이벤트헨들러와 연쇄되는 이벤트 내용처럼, component의 Lifecycle의 상태변화를 트리거 삼아 같이 실행되도록 갈고리를 건다는 의미를 가지고 붙여진 이름
                  (= 쉽게 말해, componentDidMount, componentDidUpdate, componentWillUnmount의 안에 적힌 내용들은 lifeCycle 상태에 따라 해당 함수들이 실행되면, 실행되게 설정된 코드들)
                 

              @ class component 시절 Lifecycle hook 관련 코드 구현
                 : componentDidMount(), componentDidUpdate(), componentWillUnmount()라는 class component의 멤버함수를 통해 해당 함수 스코프에 원하는 내용을 집어넣어서 사용
                    -> (중요!) Mount, Update는 rendering 후가 실행 시점의 기준 <-> Unmount는 component 해제 전이 실행 시점의 기준임을 명심해야 함

                   ex) class Detail2 extends React.Component {   
                           componentDidMount(){ Detail2 component 생성시 이 안의 코드가 실행 }                 <- component는 등장 후에 이것좀 해줘
                           componentDidUpdate(){ Detail2 component가 rerendering 될 시 이 안의 코드가 실행 }   <- component는 업데이트 되고나서 이것좀 해줘
                           componentWillUnmount(){ Detail2 component가 삭제 될 시 이 안의 코드가 실행 }         <- component는 '사라지기 전'에 이것좀 해줘
                       }

              @ function component에서 Lifecycle 관련 코드를 사용가능하게 된 시기의 구현
                 : function component의 기능을 강화하는 react hooks 중 하나인 useEffect() 함수를 통해 구현함
                    -> useEffect()
                        : lifecycle hook계열의 함수 기능을 function component 구조에서도 쓸 수 있게 하는 react hooks 함수
                           -> 기능 구현 자체는 lifeCycle hook처럼 lifeCycle 시점에 매핑되는 함수를 만들지 않고..
                              useEffect() 함수의 parameter나 내용을 통해, 내용 작동의 '시점'과 '반응할 state변수'를 설정함으로서 유저가 원하는 lifeCycle hook의 내용을 세밀하게 작성할 수 있게 해둠
                              (= 실행 시점을 세세하게 나눌수 있다는 점이 서비스의 성능과 체감에 영향을 줄 수 있음)

                              ex) useEffect( () => {

                                   (함수 내부 구조1) component rendering 시 실행되는 코드 (필수)
                                   ---------------------------------------------------------------------------------------------------
                                    해당 부분의 코드는 component의 rendering과 연관된 lifeCycle인 'mount(생성)', 'update(rerendering 변경)'와 연관되어, lifecycle hook 함수 componentdidmount(), componentDidUpdate()과 연관됨
                                    (= 해당 component가 mount(생성), update(rerendering으로 인한 수정)시, html rendering이 완료되고 나서! 해당 무명 함수의 내용이 실행됨)
                                       -> rendering이 끝나고 실행된다는 건, 주로 어렵고 복잡한 연산을 수행하거나, 서버에서 데이터를 가져오는 등 수행 시간이 오래걸리거나, 모든게 로딩과 rendering이 끝나고 가장 나중에 처리되어야 할 내용을 useEffect()에서 짬처리를 하게 됨을 의미
                                          (= 함수명을 핵심기능이 아닌 부가기능이라 중요성이 떨어지는 것을 의미하는 side effect에서 따왔음을 짐작가능한 이유를 알 수 있음)

                                       -> 정확히는 아래의 내부구조3에 [state 배열]을 어떻게 적었냐에 따라서, 어떤 state변수의 변경에만 componentDidUpdate()의 구현 타이밍을 통제할 수 있음
                                          (= component 생성 후에 실행되는 componentdidmount()는 무조건 실행됨)
                                   ---------------------------------------------------------------------------------------------------
     
                                   
                                   (함수 내부 구조2) clean up function 영역 = 존재하는 component를 해제(및 새로 갱신)하기 전에 실행되는 코드 (필수 X)
                                   ---------------------------------------------------------------------------------------------------
                                   return () => {

                                    clean up function 내부의 코드는 lifeCycle 중 이미 존재하는 component의 'unmount(삭제)'와 연관되어, lifecycle hook 함수 componentWillUnmount()과 연관됨
                                      -> 정확히는 아래의 내부구조3에 [state 배열]을 어떻게 적었냐에 따라서, state변경에 따른 'update(rerendering 변경)' 상황이 벌어지기 전에도 해당 코드의 작동 여부를 통제할 수 있음
                                         (= 뭔 수를 쓰더라도 완전한 component 해제 전에 실행되는 componentWillUnmount()는 무조건 실행됨...)
                                             -> [] 부분을 아예 배제하거나, [state 배열]을 적으면, 완전한 component 해제가 아닌 component update(갱신) 상황에서도 해당 코드는 작동함
                                                (= component update(갱신)과정에도 component unmount(해제)가 엄밀하게는 포함되기 때문 )

                                      -> clean up function 내부 내용은 보통 수행한 작업들을 정리하고 리소스를 해제하는 불필요한 리소스 사용을 방지하고 메모리 관리에 활용함
                                          ex) timer 제거, socket 연결요청제거, ajax요청 중단 (서버 db에 데이터 요청 중단)

                                      -> clean up function이 update(갱신)와 연관이 되는 이유?
                                          : component의 update(갱신) 상태라는건 component가 다시 rendering 될 때, 기존에 존재하는 component는 unmount(해제)시키고, 갱신된 component를 다시 mount시키는 개념이기 때문

                                   } 
                                   ---------------------------------------------------------------------------------------------------
     
                                  }
     
                                  (함수 내부 구조3) 해당 useEffect()에 유효한 state 변수배열 적기 (필수 X)
                                  ----------------------------------------------------------------------------------------------------
                                  , []   <- (중요!) state 변수를 배열요소로 적음 = 해당 useEffect() 함수는 여기 적힌 state 변수의 변경에만 작동함
                                              -> 해당 parameter는 필수적으로 적는 부분은 아님 

                                                  - []를 비움
                                                     : 모든 state의 변화에 반응하지 않음
                                                       (= mount와 unmount에 1번씩만 useEffect()함수를 작동시킴)
    
                                                  - []부분을 쓰지 않음
                                                     : 모든 state의 변화에 반응함

                                                  - []안에 state변수들을 적음
                                                     : 해당하는 state변수들의 변화에만 useEffect() 함수는 반응하여 작동함
                                                       (= state 변수가 많아지면 개발자의 대갈통이 깨질 수 있음)
                                  ----------------------------------------------------------------------------------------------------
                                  )  


                                 [case1] 만약 useEffect 안의 내용에 대해 'mount(생성)' 후에만 실행을 원한다면?
                                   : useEffect( () => {내용}, [] )
                                      -> 어떤 state가 변화해서 rerendering이 되던 말던, 해당코드를 실행하지 않는다는 것을 의미
                                         (= 최초 1회 component를 mount(생성)할때면 useEffect()의 내용을 실행해라)
                                 
                                 [case2] 만약 useEffect 안의 내용에 대해 update(rerendering으로 인한 수정)를 하더라도 특정 state의 변화에만 변경되게 만들고 싶다면?
                                   : useEffect( () => {내용}, [state변수에 대한 배열요소] )
                                      -> 배열 안에 존재하는 state 요소들의 경우만 변화하여 rerendering이 되는 경우만, 해당코드를 실행하게 함
                                         (= 조건부 componentdidupdate() 실행과 같음)
                                 
                                 [case3] 근데 useEffect() 쓰는데, 만약 무조건 component update(갱신) 전에 실행하고 싶은 코드가 있다면 어떻게 함?
                                   :  useEffect( () => { 내용에 'return () => {내용}' })
                                       -> component의 update로 인한 rerendering 직전이나, component의 unmount시 해당 코드가 실행됨
                                          (정확히는 'return () => {내용}' 부분에 해당하는 부분이 unmount와 연관된 부분으로, 과거 class component 시절 lifecycle hook 계열 함수 중 
                                 
                                 [case4] 그럼 useEffect() 쓰는데, 만약 useEffect() unmount 전에만 실행하고 싶은 코드가 있으면?
                                   : useEffect( () => {return () => {내용} }, [] )
                                     (= 사실상의 componentWillUnmount() 함수 부분을 대체 구현)
                                       -> 비워둔 []   : state 변화에 대해 해당 useEffect()는 작동 X
                                       -> return 코드 : useEffect 본 내용 실행전에 해당 코드 실행
                                 
                                 [case5] 그럼 useEffect() 쓰는데, 특정 component update(갱신) 전에 실행하고 싶은 코드가 있다면 어떻게 함?
                                   : useEffect( () => {return () => {내용} }, [state변수에 대한 배열요소] )
                                     (= 'return 코드를 어떤 state변화에도 반응하지 말라'는 내용의 명령어로 unmount시에만 실행되는 코드를 구현할 수 있음)
                                       -> [state변수에 대한 배열요소]   : 해당 state 변화에 대해서만, 해당 useEffect()는 작동함
                                       -> return 코드                  : useEffect 본 내용 실행전에 해당 코드 실행


 - (중요) class component
    : 원래 react의 component를 작성할때는 객체지향관점에서 class 자료형으로 component를 작성하고 이를 객체화하여 호출함
      (= React class의 Component라는 class를 상속받음)

    # class component가 도태 된 이유?
       : 더 쓰기 편하면서, 직관적이면서, 코드량도 적은 functional component가 class component가 할수 있는 모든 기능을 가지고 있기 때문
         -> 정확히는 16.8에서 functional component도 state나 여러기능을 쉽게 사용하게 하는 react hook의 등장으로 functional 방식으로 코딩하는게 유리해졌기에 class componen

    # class component를 통해 유추가능한 중대한 사실들
       1) (중요) props도 객체지만, state도 원래는 객체
          (= functional component에서 구조분해할당 문법을 통해 생성해 준 개별 state명들은 사실 state객체의 객체 안의 1개의 멤버변수)
             -> 그래서, functional component에서 만든 state에서 hooks문법인 usestate() 안에 제대로 된 자료형을 안 넣으면, 자동으로 그 state는 object 형식으로 지정되는 것..

       2) setState 함수는 개별적으로 존재하며, 그 목표는 state라는 객체 자신의 멤버변수를 변경하는 것이기에, '멤버명 : 값' 형식으로 parameter를 지정함
          (= functional component에서 구조분해할당 문법을 통해 생성해 준 개별 setState함수들은 사실 일종의 alias(별칭)으로서, 'setState(지정 state멤버변수)'와 비슷하게 치

       3) 조상인 Component class의 render 함수를 해당 component에 맞춰 override함
          (= Component render 기능의 인터페이스화는 이미 class component 시절부터 시작된 전통임)
              -> render 함수는 해당 html DOM요소를 브라우저에서 쉽게 랜더링이 가능하도록 react 차원에서 jsx형식을 우리가 아는 그 형식으로 푸는 함수로 interface화 되어있음
 
 - memo(무명 함수형 컴포넌트 내용)
   : 특정 component가 크고 무겁기에 부모로부터 받은 props 값이 변동되는 것을 제외하고, react의 재랜더링 조건을 회피하고 싶을 떄 사용하는 함수
     (= 조건부로 재랜더링 원칙이 적용된 특수한 component lifeCycle을 가졌다 보자)
        -> memo의 결과값은 let, const, var로 받으며, 그 변수명은 반드시 component명이 되어야 함 

      ex) function MemoChild(){                                              let MemoChild = memo(function (){
            console.log('부모 Conponent인 Cart가 랜더링 되면? );       ->         console.log('부모 Conponent인 Cart가 랜더링 되면? );
            return <div></div>;                                                  return <div></div>;
          }                                                                  })

    # memo(무명 함수형 컴포넌트 내용)의 로직
       : 재랜더링 대상으로 들어간 컴포넌트 내용에 기존 props와 바뀐 props를 비교하는 연산이 추가로 진행되고, 그것이 다르면 재랜더링 진행함
         (= props가 크고 복잡하면 이거 자체로도 부담이 될 수도 있기에, 전가의 보도처럼 지르지 말고, 잘 판단해서 써야함) 


 - (종합) react를 통해 동적인 UI를 만들려면?
  1. class나 function component를 만들어서 html 구조를 만들고, 거기에 맞는 css로 디자인을 확정함
  2. 해당 component UI의 상태를 제어할 flag 변수의 역할을 하는 state선언를 선언함
  3. component 내에서 3항 조건문을 활용하여, 앞서 선언한 flag state에 따라 해당 component를 어떻게 보일지를 작성함
      -> 해당 조건문의 작동의 key가 되는 state변경을 위해서는, react의 이벤트핸들러 속성 + {}를 통해 앞서 선언한 state변수들에 접근하여 이를 조작함

  # (중요) JSX에서 component의 return부분에 HTML영역을 작성시 조건문이 필요하다면?
     1) 반드시! 3항 연산자를 통한 true와 false문을 통한 패턴화로 해결하면 됨
        -> (주의) 조건식에는 state값도 당연히 사용이 가능함 + null을 사용하면 그 자리에 아무것도 출력하지 않을수 있음

     2) JS의 null, undefined, NAN, 0, "" 이 아닌 모든 값을 true로 치환하는 강제형변환을 통해서도 조건문이 구현 가능
        (= '조건문 && 참일시 출력할 HTML영역'은 조건문과 HTML영역이 둘 다 참이면.. 오른쪽에 있는 내용이 자리에 남게 됨)

         ex) { state == null? <p>참이면 보여줄 HTML</p> : null } ==  { state == null && <p>참이면 보여줄 HTML</p> }
        
     3) js의 객체의 유사 array와 비슷한 멤버변수 접근법을 응용해서도 switch문과 같은 조건문 효과를 내서 동적인 경우의 수로 원하는 html 출력 가능

         ex) var 탭UI = { 
               info : <p>상품정보</p>,
               shipping : <p>배송관련</p>,
               refund : <p>환불약관</p>
             }
             
             function Component() {
               var 현재상태 = 'info';
               return (
                 <div>
                   {
                     탭UI[현재상태]     <- HTML 영역값을 가진 멤버변수를 보유한 객체 '탭UI'라는 JS객체를 유사array 인덱스를 통한 접근으로, 현재상태라는 변수에 적힌 값이 일종의 해당되는 객체의 멤버변수명을 호출하는 switch문과 같은 조건문 효과를 내서  <p>상품정보</p> 출력예정
                   }
                 </div>
               )
             } 

  # (중요) JSX에서 반복문이 필요하다면?
     : js 지역 스코프 {}에 js 배열(state배열도 포함)객체의 멤버함수 map()을 이용하고, 배열 안에 component를 담도록 하자 
       (= for 문법은 JSX 안에서 사용할 수 없음)
         -> (참고) map 반복문으로 반복생성한 html 요소들에는 이렇게 반복 생성된 요소들을 구분하기 위한 key 속성을 추가해야 warning이 뜨지 않음 

            ex1) function App (){
                   return (
                     <div>
                       { 
                         글제목.map(function(a){                 <- 첫번째 parameter a = 해당 index순번의 배열요소
                           return (
                           <div className="list" key={i}>
                             <h4>{ a }</h4>
                             <p>2월 18일 발행</p>
                           </div> )
                         }) 
                       }
                     </div>
                   )
                 }

            ex2) function App (){
                   return (
                     <div>
                       { 
                         글제목.map(function(a, i){              <- 두번째 parameter i = 해당 index의 값 그 자체
                           return (
                           <div className="list" key={i}>
                             <h4>{ 글제목[i] }</h4>
                             <p>2월 18일 발행</p>
                           </div> )
                         }) 
                       }
                     </div>
                   )
                 }

  # 만약 반복되는 html요소를 구현하는데 for문이 굳이 쓰고 싶다면?
     : component의 return 부분은 jsx 부분이므로, 그 윗 라인 영역인 js 영역에서 for문을 사용하여, 배열 안에 html요소를 대입한 후 이를 jsx의 conponent return 영역에서 호출

       ex) function App (){
             var 어레이 = [];
             for (var i = 0; i < 3; i++) {
               어레이.push(<div>안녕</div>)         <- 이런식으로 배열에 html요소를 대입
             }
             return (
               <div>
                 { 어레이 }
               </div>
             )
           }


 - react 사전이해에 필요한 JS지식
  @ 구조 분해 할당(destructuring assignment)?
     : ECMA6에서 새로 공개된 배열 또는 객체의 속성을 쉽게 추출하여 개별 단일 변수에 할당하는 방법으로.. 
       -> 배열이나 객체의 요소를 일일히 접근하여 변수에 할당하는 대신, 구조 분해 할당을 사용하여 한 번에 여러 변수에 값을 할당 가능 + []와 {}의 차이만 있을 뿐, 문법이 서
           -> 해당 컴포넌트의 지역변수 역할을 하는 state에 get, set 로직을 구현하는데 사용됨

       ex) 배열 구조 분해 할당
           const numbers = [1, 2, 3, 4, 5];
           const [a, b, ...rest] = numbers;         <- numbers의 배열요소의 값들을 각 개별변수에 일괄적으로 대입 가능
           const [e, f] = numbers;                  <- (중요) 값을 제공하는 배열 numbers의 요소의 개수 > 값을 받는 배열의 개수?
                                                         : 이 경우는 1, 2만 e, f에 대입
           console.log(a);    // 1
           console.log(b);    // 2
           console.log(rest); // [3, 4, 5]
           console.log(e);    // 1
           console.log(f);    // 2

        ex) 객체 구조 분해 할당
           const person = { name: 'John', age: 30, city: 'New York' };
           const { name, age, city } = person;      <- 객체 person의 멤버변수 값들을 각 개별변수에 일괄적으로 대입 가능
           console.log(name); // 'John'
           console.log(age);  // 30
           console.log(city); // 'New York'

  @ 스프레드 문법(spread syntax)
     : '...배열명 or 객체명'을 통해, 배열(array)이나 객체(object)에 존재하는 각 요소 또는 멤버변수들을 해당 컨테이너명을 사용하여 개별적인 값으로 쉽게 확장하는 작성하는 
        (= 이걸 쓰면 귀찮게 배열, 객체의 각 모든 요소들을 일일히 기입하지 않아도 되며, 함수의 선언부에 parameter의 갯수에 따른 오버로딩 또한 노가다 없이 rest parameter형
            -> 다시 말해 배열, 객체의 깊은 복사가 쉬워짐
               ex) const numbers = [1, 2, 3];
                   const copiedNumbers = [...numbers];
                   console.log(copiedNumbers); // [1, 2, 3]
                   const person = { name: 'John', age: 30 };
                   const copiedPerson = { ...person };
                   console.log(copiedPerson); // { name: 'John', age: 30 }

  @ html 이벤트핸들러 속성
    : js의 이벤트핸들러를 html에서 사용가능하게 속성으로 구현한 것.. 속성값으로는 행동 function명이나, 익명함수로 원하는 로직을 입력함녀 됨. onClick이 대표적

  @ 일급 객체 function
    : js의 function이란 변수에 대입이 가능하며, 다른 함수의 return으로 가능한 대상이자, 다른 함수의 parameter로도 사용이 가능함
      (= 특정 변수에 익명함수를 입력해서 저장시키거나, 다른 함수를 대입하는 것도 가능하며, callback 함수를 사용가능한 근원이 되는 js의 특성임)

  @ array/object를 다룰 때의 주의사항
    1. 배열명 / 객체명 그들 자신 자체는 reference 타입의 변수
       (= 배열요소 / 객체맴버변수 데이터를 보존하는게 아니라, 해당 배열이나 객체가 어떤 메모리 주소에 위치해 있는지에 대한 위치값(= 포인터)을 가지고 있음)
           -> 그래서, 'let 변수명 = 배열/객체명;' 과 같은 식의 코드는 의도대로 배열이나 객체의 값이 변수명에 복사되지 않고, 배열/객체명의 메모리 주소를 대입하는 '얕은 복
 
    2. 배열 / 객체는 다룰 때 원본을 보존하는 것이 좋기에, 완전히 다른 메모리주소를 할당한 후 값을 할당하는 '깊은 복사'를 쓰는게 좋음    
    3. js의 객체 내부의 멤버표기법은 2가지가 존재함
        ex) obj.member == obj["member"]

        - 일반적인 객체 멤버 표기법
           : 객체명.멤버변수명 or 멤버함수명(parameter);

        - js만의 유사 array스런 특수한 객체 내부 멤버표기법
           : 객체명[멤버변수명 or 멤버함수명(parameter)]
              -> 배열명[index]와 유사.. 
                   -> (중요) react에서는 return문에 html영역값을 가지는 멤버변수들을 가진 객체를 호출하고, [변수명]을 통해 특정 변수명 안에 있는 값과 일치하는 객체의 멤버변수가 가지는 값을 호출하여 조건문처럼 사용이 가능함
                        -> 유사 클로저(closure)라고 생각하면 편함 (= 은근히 구조가 복잡함)

             ex) var 탭UI = { 
                   info : <p>상품정보</p>,
                   shipping : <p>배송관련</p>,
                   refund : <p>환불약관</p>
                 }
                 
                 function Component() {
                   var [현재상태, 현재상태설정] = useState('info');
                   return (
                     <div>
                       { 탭UI[현재상태] }
                     </div>
                   )
                 }    

  @ 3항 연산자(ternary operator)
    : '조건식 ? true일시의 실행 : false일시의 실행' 형식으로 작성하는 조건문... 
        -> 이를 사용하면, if else if else 범벅보다, 1줄로 간편하면서도 때때로 직관적인 코드를 짤 수 있음
  
  @ 논리 부정 연산자 !
     : true, false의 각자 반대값을 출력하도록 함
 
  @ 배열object의 멤버함수 map
     1. [요소1, 요소2, ... , 요소n].map( function() { 내용 } )
         : 해당 배열 요소들의 개수만큼, 내부 무명함수의 내용을 반복해 줌

     2. [요소1, 요소2, ... , 요소n].map( function() { return '내용' )
         : 해당 배열 요소들의 개수만큼, 해당 횟차만큼의 index 위치에 있는 배열요소에 return에 존재하는 '내용'을 기입

           ex) [1,2,3].map(function(){
                 return 123           <- 123을 배열의 index마다 반복해서 기입 [123, 123, 123]
               });
 
     3. [요소1, 요소2, ... , 요소n].map( function(변수a) { 내용(변수a를 사용) } )
         : 해당 배열 요소들의 개수만큼, 내부 무명함수의 내용을 반복하되, 변수a에 해당하는 부분은 해당 횟차만큼의 index 위치에 있는 배열요소를 사용함

           ex) [1,2,3].map(function(a){
                 console.log(a);          <- 1, 2, 3을 log에 순차적으로 출력
               });

     4. [요소1, 요소2, ... , 요소n].map( function(변수a) { return (변수a를 사용) } )
         : 해당 배열 요소들의 개수만큼, 내부 무명함수의 내용을 반복하되, return에 해당하는 부분도 변수a에 해당하는 부분은 해당 횟차만큼의 index 위치에 있는 배열요소를 사

           ex) [1,2,3].map(function(a){
                 return a*100            <- 각 배열의 index에 위치한 요소 * 100에 해당하는 값을 배열의 각 index에 반복해서 기입 [100, 200, 300]
               });

     5. [요소1, 요소2, ... , 요소n].map( function(변수a, 변수i) { 내용(변수a와 i를 사용) } )
         : 해당 배열 요소들의 개수만큼, 내부 무명함수의 내용을 반복하되, 변수a에 해당하는 부분은 해당 횟차만큼의 index 위치에 있는 배열요소를 사용 + 변수i는 해당 index에
 
           ex) [1,2,3].map(function(a, i){
                 return a*i              <- 각 배열의 index에 위치한 요소 * 각 index의 값에 해당하는 값을 각 index에 반복해서 기입 [1, 4, 9]
               });

  @ HTML 이벤트핸들러 속성
     : HTML에는 자체적인 명세서에 동적인 웹페이지를 구성하도록 하기 위한, js의 자주 쓰이는 이벤트핸들러들을 DOM 속성 형식으로 쉽게 쓸 수 있기 지원함
        -> 이벤트핸들러가 전역변수로 노출 + 복수 이벤트핸들러를 설정하는 문법이 X + 사용자 정의 이벤트를 설정 불가능.. 이 3콤보로 요즘은 사장..
            -> 그렇지만 react에서는 이러한 형식의 친숙함을 차용하여, react방식의 매커니즘에서도 dom조작 없이 state의 변경을 통한 이벤트를 구현하였음
                -> 단! 이미 html DOM기반 이벤트핸들러는 존재하기에, 기존에 존재한 이벤트핸드러 속성을 'camalCase' 형식으로 표기하여 동일한 속성을 피함
                    -> 물론! 그렇다고, onClick으로 구현한 react의 유사 이벤트핸들러의 구현이 onclick과 절대 같지는 않음
                       (= 아마, 형식만 html DOM기반 이벤트핸들러 형식으로 작성된 react 이벤트 속성이 감지되면, 내부적으로 구현되는 로직이 존재할듯)

  @ 이벤트 객체 e
     : 이벤트핸들러에 들어가는 함수에 넣는 parameter로, 이는 객체로서 현재 발생하는 이벤트와 관련한 유용한 기능들을 제공하는 일종의 변수로 생각하면 됨
        - e.target            : 현재 이벤트가 발생한 곳을 알려줌
        - e.target.value      : 현재 이벤트가 발생한 곳의 값을 출력함
        - e.preventDefault()  : 해당 이벤트의 기본 동작을 막아줌
        - e.stopPropagation() : 가장 최상단의 조상 HTML DOM요소부터 해당 HTML DOM요소에 접근하는 호출 stack을 구성해 위치를 찾은 후, stack을 해제하는 과정에서 접근하게 

  @ 이벤트버블링
     : 어떤 HTML 요소에 이벤트가 발생하여 이벤트핸들러가 동작하고, 이어서 부모 요소부터 가장 최상단의 조상 요소에 이르기까지 같은 종류의 이벤트핸들러가 동작하는 개념을 
        -> HTML 요소 접근을 위한 stack 회수 과정에서 구현하였기에, 편도행에는 문제가 생기게 하지 않을 수 있다고 생각함
           (= e.stopPropagation()을 통해, 본 이벤트 발생 이후의 다른 HTML DOM요소들의 이벤트의 통제 또한 가능함)

  @ object(객체) 타입
     : js의 자료형 중 하나로 '속성 : 속성값 = key : value'구조를 가지는 멤버들이 여러개로 구성되어 있는 일종의 구조체(construct) 같은 자료형
        -> let 객체명 = {속성1 : 속성값, ... , 속성n : 속성값n} 형식으로 작성
      # (주의) react에서는 render할 component에 있는 출력값이 object 타입이면, 에러를 뿜으니... 유의하도록 하자 

  @ 스코프(Scope) 개념
     : 프로그래밍 언어에서 변수나 함수가 사용가능한 결계를 설정하여 위해 사용하는 개념으로.. 이를 바탕으로 변수나 함수, 객체들이 영역을 명확히 할 수 있는 '지역XX' 개념이나 '캡슐화' 등의 개념을 활용가능
        -> 이 결계(영역)을 바탕으로 클로저 로직이 시작되기에 엄청 중요...!
        
      # 함수의 스코프(Scope)를 정하는 기준
         1. 렉시컬 스코프(Lexical Scope) = 정적 스코프(Static Scope)
             : 함수가 어디에 '선언'되었는지에 따라 변수의 스코프가 정적으로 결정되는 것을 의미
               (= 다시 말해, 신분제처럼 함수는 작성되는 순간부터 자신의 소속 {}영역이 정해지는 걸 의미함)
                   -> (중요) 클로저(Closure)는 이에 따르면, 자신이 생성될 때의 환경(렉시컬 스코프)을 기억하는 함수로 정의가 가능!

         2. 동적 스코프(dynamic Scope) <->  렉시컬 스코프(Lexical Scope)
             : 함수가 '호출'하였는지에 따라 변수의 스코프가 동적으로 결정되는 것을 의미
                -> (주의) 단.. 일부 언어만 따르는 기준임

      # EMCA5 까지의 변수의 스코프(Scope)
         : EMCA5 까지는 var 타입 변수를 쓰는데, 이 녀석의 통용 범위는 function의 {}이 기준이 됨..
           (= for나 if같은 조건문의 {}는 전혀 스코프의 영역조차 되지 못함)
               -> EMCA6 이후, 블럭 스코프(block scope)의 등장과 let 변수의 등장 이유

      # EMCA6부터의 변수의 스코프(Scope)
         : 지역변수적 요소를 구현하고자 임의적으로 유저는 {}를 통해 결계로 구분되는 영역을 만들수 있게 되고. 그 안에 쓰는 변수 let 혹은 const는 그 안에서만 통용되는 지역변수처럼 적용됨
           (= 이를 통해 드디어 js는 for나 if같은 조건문의 {}를 지역변수를 위한 영역으로 구별할 수 있게 됨)

  @ 클로저(closure)개념
     : 포함한다(enclose)라는 개념에서 온 용어로.. js의 함수의 경우 자기 자신의 {} 영역(scope)을 가지고 있지만, 다른 한편으로는 자신의 선언 당시 포함된 환경(렉시컬 스코프)인 {}영역(scope)이 어디인지까지 또한 포함해서(enclose) 기억하는 특성을 의미하는 개념...
       (= 그렇기에, 자신을 감싼 {}영역 안의 변수나 객체를 기억하고, 심지어 내부함수라면 외부함수의 실행이 끝나도 외부함수의 변수에 접근이 가능함을 의미하다는 걸 알 수 있음)
           -> (중요) 이 특성이.. 'js의 1급 객체 함수' 개념과 '렉시컬 스코프(Lexical Scope)' 개념과 결합하면 어마어마한 모듈 패턴을 만들어 낼 수 있음  

      # 주의점
         : 클로저(closure) 사용을 통한 내부함수의 외부변수 참조가 시작되면, 설령 외부함수의 실행이 끝나더라도 가비지 콜렉터에 의해 메모리가 해제되지 않음
            -> (중요!) 클로저를 할당한 변수에 null을 할당해줌으로써 메모리를 해제

            ex) const outerFunc = () => {
                		let x = 10;

                		const innerFunc = (y) => {
                				x = x + y;
                				console.log(x);
                		}
                		return innerFunc;
                }
                let addFunc = outerFunc();
                addFunc(5);
                addFunc = null;        <- 메모리 회수 가능 지점

      # 클로저(closure) 응용사례
         1) 함수를 통한 캡슐화와 은닉화
             : 무명함수를 통해서 getter, sette 등을 흉내낼 수 있음

               ex) const user = () => {
                   		let userName = ''; // private
                   
                   		return {
                   				getUserName: function() {
                   						return userName;
                   				},
                   				setUserName: function(_userName) {
                   						userName = _userName;
                   				}
                   		};
                   }
                   
                   const user1 = user();
                   user1.getUserName(); 
                   user1.setUserName('Chojs');
                   user1.getUserName(); 

         2) 부분 적용 함수 구현 가능
             : return에 독립적인 무명함수를 반환하는 경우라도, 외부 함수의 변수를 클로저 개념을 통해 끝까지 참고 가능하기에..
               (= parameter의 일부는 나중에 받아 처음에는 null로 나중에 값을 받음으로최종적인 결과만 출력하게 할 수 있음)
                   -> react의 state가 로딩이 되기 전까지 null로 유지했다, 값 받으면 다른거로 바뀌게 하는거도 이런 지연 실행적 특성에 기인

         3) 커링(curring) 함수(function(a, b, c) ->  function(a)(b)(c)로 실행가능하게 함)를 구현 가능
             : 부분 적용 함수 구현과 마찬가지로 결국 일부 paramter를 나중에 받는걸 순차적으로 받아 지연 실행하는거로 바꾼거와 같음
                -> 2)번과 연계하여, 중간의 값에 따라 출력값을 바꿔 보내는 '미들웨어'와 '로그'의 구현에도 기여

                ex) const reduxThunk = (store) => (next) => (dispatch) => {
		                  return typeof action === "function" ? 
                        action(dispatch, store.getState) : next(action);
                    }
 
  @ 1급 객체(first-class object)
     : 다른 객체들에 일반적으로 적용 가능한 연산을 모두 지원하는 객체라는 의미로 객체의 권한이나 호환성 관련된 프로그래밍적 개념
       (= js의 함수는 기본적으로 일반 변수와 같은 방식으로 사용이 가능해, 어마어마한 경우의 수로 응용이 가능함)

      # 1급 객체(first-class object)라면 가능한 4가지의 특성
         1. 변수에 할당될 수 있는 타입의 객체 (= js에서는 함수도 변수에 할당해서 쓸 수 있음)
         2. 함수 호출시 parameter로 전달 가능 (= 그래서 js에서 callback이나 무명함수를 연계시켜 실행도 가능)
         3. 함수의 return 문에 가입가능 (= 기본적인 함수간 연쇄작용이 가능함... 특히 2번 특성과 결합하면...)
         4. 동적으로 생성 및 파괴가 가능


  @ js 모듈러 시스템
     : HTML의 script 태그에서 다른 스크립트 파일들을 src속성을 통해 불러올 때, 해당 script 코드들이 1개의 단일영역에 적혀있는 것처럼 작동하는 것을 막고, js 모듈을 기준으
         -> 다시 말해, Class 내 변수를 쓰려고 할 때 이들을 불러오는 문법이 있듯, 모듈 내의 변수들을 구분해서 불러오는 구문이 따로 필요하다는 것 의미
             -> 이렇게 js의 모듈을 불러오는 방식을 '모듈 시스템(module system)'으로 명칭함

      # 블럭 스코프(block scope)
        : js(es6 이후로 추정)에서 지역변수적 요소를 구현하고자 쓰는 결계로 그 안에 쓰는 변수 let 혹은 const는 그 안에서만 통용되는 지역변수처럼 적용됨
           -> {}를 통해 결계를 치고, 그 안에 쓴 변수 let 혹은 const는 그 안에서만 통용되는 지역변수화가 됨 (반대로, 안에서는 전역변수들을 만나는게 가능한 함수에서의 {}와
              (단! var는 그런거 적용 안 되니 쓰지 않도록 한다)

      # 자주 사용되는 2가지의 모듈 시스템
         1. ES Module (사실상의 승자)
             : JS ES6(ES2015)에 도입된 자바스크립트 자체의 모듈 시스템 방식 (과거 제작된 react에서 많이 보이는 녀석)
                -> (중요) NodeJS 13.2부터 ES모듈 시스템에 대한 정식 지원이 시작 = node.js에서도 babel같은거 없이 사용 가능 
                      -> package.json에서 type = "module" 선언화면 바로 사용 가능하게 조치 
                         (= package.json와 연관있는 react 또한 이를 사용함을 유추 가능...)
                             ->  정확히는 함수 component를 쓸 때, 해당 기능을 강화시키는 hooks 모듈을 불러올 때 사용)

              - ES Module 사용법
                : (from 사용할 모듈) export 구문을 입력 -> (to 가져오는 파일) import구문을 통해 불러옴

                1) ES Module 내보내기 : export 구문

                    a. export default 내보내고 싶은 변수명;
                        : import시 특별한 변수명을 적지 않으면(= 보통 import a구문 사용시), 이 때 지명한 변수를 가져옴
                          (단! 한번 사용 가능함.. 기본으로 출력할 변수를 부르기 때문)

                    b. export default { 내보내고 싶은 변수명(여러개도 가능) };
                        : import시 특별한 변수명을 적지 않으면(= 보통 import a구문 사용시), 이 때 지명한 변수들을 가져옴
                          (a와 마찬가지로 한번 사용 가능함.. 기본으로 출력할 변수를 부르기 때문)

                    c. export let(const) 내보내고 싶은 변수명;
                        : 이를 통해 여러개의 변수들을 직관적으로 지명 가능
                            -> 그나마 가장 범용성이 좋은 방법 

                2) ES Module 불러오기 : import 구문

                    a. import 지은 변수명 from '불러오는 모듈 경로'
                        : 모듈에서 변수 하나만 가져오는 방법  
                            -> export defalut {여려변수들} 을 사용한다면, b구문처럼 '지은 변수명'을 객체명처럼 사용 가능 

                    b. import * as 지은 변수명 from '불러오는 모듈 경로';
                        : 모듈에서 모든 변수를 가져오는 방법 
                          (*의 의미 : SQL에서 모든 변수 가져오는것 의미.. -> 이걸 '지은 변수명'으로 통칭해 객체명화 하는 것)
                            -> '별칭.프로퍼티' or '별칭.메서드명(파라미터....)'' 를 통해 값을 지칭해서 불러옴

                    c. import { 가져올 변수명(여러개도 가능) } from '불러오는 모듈 경로';
                        : 모듈에서 1개 ~ 여러개 변수를 가져오는 방법
                            -> 그나마 가장 범용성이 좋은 방법 

         2. CommonJs
             : NodeJS 환경에서 자바스크립트 모듈을 사용하기 위해 만들어진 모듈 시스템 
                -> 일부 내용은 ES Module과 기능상 호환되는 부분이 존재함

              - CommonJs 사용법
                 : (from 사용할 모듈) 사용할 변수 앞에 export.변수명 입력 or module.export { } 구문 입력- > (to 가져오는 파일) require('파일경로'); 구문을 통해 불러옴

                 1) CommonJs 모듈 내보내기 : export.변수명 및 module.export 구문

                     a. export.내보내고 싶은 변수명;
                         : 내보내고 싶은 js 변수 앞에 'export.' 를 일일히 붙여서 모듈의 변수로서 블록 스코프에 넣는 것으로 판정 

                     b. module.export { 내보내고 싶은 변수명(여러개도 가능) };
                         : 이를 통해 여러개의 변수들을 직관적으로 지명 가능
                             -> 그나마 가장 범용성이 좋은 방법 

                 2) CommonJs 모듈 불러오기 : require 구문

                     a. let or const { 불러오고 싶은 변수명(여러개도 가능) } = require('파일경로');
                         : 모듈에서 1개 ~ 여러개 변수를 가져오는 방법
                             -> 그나마 가장 범용성이 좋은 방법 

                     b. let or const 지은 변수명(= 별칭) = require('파일경로');
                         : 모듈에서 모든 변수를 '지은 변수명'으로 통칭해 객체명화 하여 가져오는 방법 
                             -> '별칭.프로퍼티' or '별칭.메서드명(파라미터....)'' 를 통해 값을 지칭해서 불러옴  


  @ (중요) Concurrency(동시성) & Parallelism(병렬성)
     : 여러가지의 프로그래밍 작업의 동시 수행에 대한 프로그래밍 개념으로... 논리적 vs 물리적인 관점으로 구분된 용어
        -> 각각 '비동기 작업처리', '병렬 작업처리'의 개념과 직결되는 관련성이 있는 용어로 제대로 모르면, 두 처리방식의 차이점을 알수 없음
           (= 이 두가지 방식은 시스템을 구성할 때 양립불가능한 요소가 아니라는 점 명심)

       1. Concurrency(동시성) => (중요) [비동기 작업 처리]와 연관
           : 여러가지의 프로그래밍 작업을 동시에 수행하는 것에 대한 논리적인 개념
              -> 비동기적으로 빠르게 프로세스 및 컨텍스트들을 전환하며 여러 작업을 수행하면? 거의 동시에 여러 작업이 실행되는 것으로 보여짐
                 (= 사실 비동기 작업처리는 운영체제의 복잡 정교한 스케줄링 정책에 의해 실행되는 방식으로, 물리적으로 동시적 프로그래밍 작업을 수행하진 않기에 논리적인 동시적 작업을 충족하여 Concurrency한 task로 인정)

                 ex) 프로세서의 프로세스 스케쥴링(process scheduleing), 쓰레드의 컨텍스트 스위치(context switch)
                     
       2. Parallelism(병렬성) => (중요) [병렬 작업 처리]와 연관
           : 여러가지의 프로그래밍 작업을 동시에 수행하는 것에 대한 물리적인 개념
              -> 실제로도 완벽하게 동시에 프로그래밍 작업이 수행하는 경우에만 한정함

                 ex) 멀티 CPU코어(Multi-Processor), 멀티 쓰레드(Multi-thread)를 통한 다중 프로세싱 (Multiprocessing), 다중 쓰레딩 (Multithreading)


      # 컨택스트(context)                     vs          쓰레드(thread)
        - 동시성(concurrency) 관여                        - 병렬성(Parallelism) 관여 + 동시성(concurrency)도 부분적 강화
        - 비동기적 작업 처리                               - 멀티 쓰레드(multi thread)를 통한 병렬 처리
        - 실행 중 프로세스, 스레드의 상태 정보              - 프로세스 내에서 실행되는 독립적인 실행 단위


      # 동기화 문제
         : Concurrency(동시성) & Parallelism(병렬성)한 task에서나 둘 다 동시기에 공유된 자원에 경쟁적으로 접근(race condition)하게 되었을떄, 작업 과정 자체가 매번 달라지고 작업 결과의 신뢰성에 문제가 발생
            -> 세부적 분류
               1) 어떻게 프로세스 간 공유 자원(프린터,통신망 등)을 배타적(한 순간에 1개의 프로세스 만 사용)으로 사용하게 할거냐?
                  (= 어떻게 화장실에 1명만 들어가게 할거냐?)
                    -> 공유변수구역 or 임계구역(critical section) 의 상호배제(mutual exclusion) 문제 
                     
               2) 혹시라도 두 프로세스가 서로 다음 작업이 서로 점유중인 공유변수구역을 필요로 해서, 병행 프로세스의 다음 작업 자체가 진행이 안된다면 어쩔거냐?
                  (= 혹시라도 1명만 들어가야 하는 샤워실, 화장실에 들어간 사람들이 다음에 들어갈 곳이 서로가 있는 곳일떄는 어떻게 위치 교환을 하게 할거냐?)
                    -> 교착상태 (Deadlock) 문제

               3) 그렇다면 어떤 식으로 다수의 프로세스들에게 명령을 전달하여 1), 2)의 문제를 피하고자 할거냐?
                  (= 사람들을 어떤식으로 통제해서, 화장실을 질서정연하게 이용하게 할거냐?)
                    -> 자료 교환을 위한 메세지 전달 방식 상의 통신 (Communication) 문제

               4) 실행 과정이 약간 변동이 생겨도 작업 결과의 신뢰성은 보증 가능하냐?
                  (= 화장실 가는 순서가 약간 변동이 생겨도, 결국 미래는 비슷하게 흘러갈거냐?)
                    -> 실행순서와 관계없이 항상 같은 결과를 얻어야하는 결정성 (Determinacy) 문제


      # 'Concurrency(동시성) : Parallelism(병렬성) = 비동기 처리 : 병렬 처리'의 CS의 역사
         1. 싱글 프로세서 시스템 (Single-Processor Systems)
            : 초기 컴퓨터는 싱글 프로세서(Single-Processor) + 1개의 프로세스(process)만이 실행이 가능함
               -> 시스템의 최소 실행단위는 프로세스(process)이며, 1개의 프로세스만 실행이 가능
                  (= 코드 작업을 순차적으로 1요청에는 1응답이 되기까지 다음을 작업을 진행하지 않는 '동기적 프로그래밍' 방식을 사용)

            - 용어 사전
               1) 프로세스
                   : 현재 컴퓨터에서 메모리에 instance로서 객체화 되어 올라가 실행중인 프로그램를 통칭하는 용어
                      -> 과거에는 컴퓨터에 여러개의 프로그램을 실행한다는 개념이 없는 '프로세스 기반의 시스템'이 주류
                         (= 당연히 비동기 작업처리라는 개념이 없었음)

               2) 프로세서(= CPU)
                  : 프로세스를 실제로 수행하는 주체를 의미하는 장치로 일명 중앙처리장치.. 
                     -> 단일 프로세서(Single-Processor) = 1코어 cpu
                     -> 다수 프로세서(Multi-Processor)  = 멀티코어 cpu
                         : (IF) 프로세서의 수가 많으면?
                             -> 다중 프로세싱 (Multi processing) 가능
                                 : 여러 개의 프로세서가 동시에 다양한 작업을 처리하는 기술, 각 프로세서는 독립적인 실행 단위인 프로세스를 처리
                                   (= 물리적으로 병행 프로세스를 수행하는 병렬 처리의 효율이 늘어남)
   
                             -> 다중 쓰레딩 (Multithreading) 가능
                                 : 멀티코어를 멀티쓰레드로 사용하게 설계된 프로세스(= 프로그램)의 경우 퍼포먼스가 늘어날 수 있음

         2. 멀티 프로그래밍 (Multi-Programming) (= 동시성(Concurrency) 관점의 비동기적 프로세스 처리 가능한 시대의 등장)
            : 1960년대 후반 컴퓨터의 성능이 여러개의 프로세스를 띄울 수 있을 정도로 발전함
               -> 이제는 싱글 프로세서(Single-Processor) 환경에서 다중 처리(Multi-Processing) 시스템을 구현할 필요성이 생김
                  (= 싱글 프로세서(Single-Processor)라서 진짜로 물리적으로 동시에 코드를 처리하는 병렬처리는 불가능하지만.. 여러개의 프로세스를 어떻게든 동시간대에 실행하게 해서, 언제라도 유저가 조작하면 반응에 응할 수 있도록 컴퓨터를 설계해야 함)  
                      -> How to solve?
                          : 어차피 CPU 1개라서 병렬성(Parallelism)한 병렬처리는 불가능? 그럼 동시성(Concurrency)한 관점에서 CPU가 시간차로 플래쉬보다 ㅈㄴ 빠르게 여러 프로세스의 처리를 번갈아가며 처리하면? 동시에 프로세스를 실행하는거처럼 보이니 문제없겠네?
                             -> '시분할 시스템'을 통해 '동시성 프로세스(Concurrent Process)' 방식을 구현한, '프로세스 스케줄링(process scheduleing)'으로 비동기적 멀티태스킹(multi tasking) 구현
                                (= 프로세스 처리의 상태 기록을 위해서 컨텍스트(context) 개념이 도입 + 프로세스 간 통신을 위해 IPC 프로세서 사용 + 프로세스 동기화(processs Synchronization)를 통한 경쟁상태 문제 해결)
                      -> 결론
                          : 동시성(Concurrency) 측면에서는 진전이 있었지만, But 병렬성(Parallelism) 병렬처리에는 한계


            - 동시적 태스크 동기화 (Concurrent task Synchronization) 문제
               : 다수의 프로세스가 동시성(Concurrent)을 가지는 업무들(tasks)을 함께 수행함에 따라, 동시기에 공유된 자원에 경쟁적으로 접근(race condition)하게 되었을떄, 작업 과정 자체가 매번 달라지고 작업 결과의 신뢰성에 문제가 발생
                  -> 프로세스 동기화(processs Synchronization)를 통해 해결 가능

            - 용어 사전
               1) 다중처리(Multi-Processing)
                  : 컴퓨터 시스템이 동시에 여러 작업을 처리할 수 있는 능력을 의미... '처리방식', '사용자', '태스크(프로세스 실행개수)' 등 관점에 따라 구분하는 방식이 다양함
   
                     a. 싱글 태스킹 (Single-Tasking)
                         : 하나의 태스크 만을 전념 실행  
   
                     b. 멀티 태스킹 (Multi-Tasking)
                         : 여러 태스크들을 동시에 실행시킴

               2) 프로세스 스케줄링(process scheduleing)
                  : 프로세서(= CPU)가 아주 빠르게 주기적으로 각 프로세스의 주도권을 오가며 실행하는 계획안으로 이를 통해 싱글 프로세서(Single-Processor)로 다수의 프로세스들을 실행 가능하게 함
      
               3) 동시성 프로세스(Concurrent Process)
                  : '프로세스 스케줄링(process scheduleing)'을 통해, 동시성(Concurrency) 관점에서 비동기적으로 여러 프로세스들을 실행하는 것처럼 보이게 하는 방식
   
                    a. 독립적 프로세스 (Independent process)
                        : 여러 프로세스들이 '프로세스 스케줄링(process scheduleing)'을 통해 각각 독립적으로 동시성 수행(= 멀티태스킹)되는 개념
                          (= 개별 프로세스들은 다른 프로세스들에게 영향을 주지도, 받지도 않고, 데이터를 공유하지도 않음)
      
                    b. 협력 프로세스 (cooperaitng process)
                        : 다른 프로세스의 실행에 영향을 주는 여러 프로세스들이 '프로세스 스케줄링'을 통해, 동시성 수행(= 멀티태스킹)되는 개념
                          (= 각 프로세스들은 동일한 시스템을 기반에 두고 작동하기에, 동일한 메모리 공간에서 변수, 파일, 메세지 등을 공유하기에 나타나는 현상)
                              -> IPC(Inter-Process Communication) 프로세스를 사용해서 프로세스 상호 간 통신하여.. 공유될 데이터를 주고받음

               4) 프로세스 동기화(processs Synchronization)
                  : 입출력장치나 메모리와 같은 자원 한 순간에 하나의 프로세스만 이용하도록 제어하는 임계구역(critical section) 의 상호배제(mutual exclusion)를 구현
                     -> 이를 통해 경쟁상태(race condition)를 해소하고 공유자원의 일관성을 보장해 주는 것


         3. 컨텍스트 (Context) 개념을 활용한 프로세스(process) 내부의 비동기 작업 (= 프로세스 내부의 동시성(concurrency) 개념의 등장)
            : 1960 ~ 1970년대 개별 프로세스의 코드처리도 굳이 1요청에 1응답의 동시성 프로그래밍을 고집할 필요가 없어질 정도로 컴퓨터의 성능이 향상
               -> 이제는 싱글 프로세서(Single-Processor) 개별 프로세스(process) 내부의 코드를 단일 처리 흐름(후에 single thread로 불림)으로 동시성(Concurrent)을 가지도록 비동기로 작업 처리할 수 있게 해야 함
                   -> How to solve?
                       : 컨텍스트 스위칭(Context swiching)을 통해 해결
                          -> 프로세스 스케쥴링(process scheduleing)을 통해 프로세스 간 비동기적 멀티태스킹(multi tasking) 구현했던걸 응용하면 되잖아?
                             (= 프로세스(process)에서 비동기로 작업될 코드를 만나면? 해당 되는 프로세스 내부의 비동기 작업 상태 정보를 가지는 컨텍스트(Context)를 생성되게 함 + 이를 비동기 작업의 단위로 삼아 프로세스 처리 흐름이 돌아올 수 있게 하자)

            - 용어 사전
               1) (중요!) 컨텍스트(context) 
                  : 실행 중인 프로세스(process)나 스레드(thread)의 상태를 나타내는 정보 집합 (레지스터 값, 프로그램 카운터 등의 정보 존재)
                     -> 프로세스 간의 실행 순서와 동시성을 관리할 수 있기에, 프로세스 및 쓰레드 간의 스위칭이 가능해져 멀티태스킹이 실현
                        (= 정확히는 프로세스 스케쥴링과 프로세스 내부의 비동기 작업, 병렬 처리에 전부 사용될 수 밖에 없음)
                            -> (중요) js의 promise 객체 또한 정확히는 이 프로세스의 컨텍스트(context)에 대한 내용을 담는 개념임

               2) 컨텍스트 스위칭(context switing) 
                  : 현재 실행 중인 프로세스 or 쓰레드의 상태를 저장하고 다음 실행할 프로세스 or 쓰레드의 상태를 복원하는 과정
                    (= Concurrency(동시성) & Parallelism(병렬성) 양쪽 모두와 연관이 깊은 개념)


         4. 쓰레드(thread) 개념의 등장 (= 프로세스 내부의 '유사' 병렬성(Parallelism) 개념 (= 결국 동시성(concurrency)의 등장)
             : 1970년대 컴퓨터의 발전은 싱글 프로세서(single processor) 환경임에도, 더 이상 프로세스를 프로그래밍의 최소 처리 흐름 단위로 둘 이유가 없을 정도로 발전함
               (= 개별 프로세스의 처리에 있어, 동시성(Concurrency)을 넘어서 병렬성(Parallelism)을 기반으로 한 병렬처리가 가능할 수 있도록, 프로그래밍의 새로운 최소 처리 흐름 단위가 필요)
                   -> 프로세스 내에서 실행되는 각각의 독립적인 실행 단위인 '쓰레드(thread)'의 등장
                      (= 쓰레드를 여러개를 쓰는 멀티 쓰레드(multi thread)를 통해, 병렬성(Parallelism)에 입각한 프로세스의 병렬처리가 가능해짐)


            - 쓰레드(thread)의 특징
               1) 개별 thread는 각각 독립된 실행 흐름과 스택(stack)을 가짐
                  (= 다른 thread와 처리 영역이 겹치는 고생을 하지 않기에, 동시성 문제를 방지하는 측면이 존재)

               2) 개별 thread는 프로세스 안에서의 전체적인 실행 흐름과 힙(heap)영역은 공유를 함
                  (= 각자 하는 일이 전체를 향하는 일괄적인 흐름을 가진 작업이 됨)

               3) 개별 thread도 context가 존재하여, context switching의 대상이 될 수 있음

               4) 한 프로세스(process)의 여러개의 쓰레드(thread)가 존재 가능함

               5) 기본적으로 쓰레드는 평행성(Parallelism)을 근거로 한 물리적으로 동시적 프로그래밍 처리를 하는 병렬처리를 위해 만들어짐
                   -> (주의!) 단! 진정한 평행성(Parallelism)은 멀티코어 cpu를 사용한 멀티 프로세서 환경에서 실현됨 = 싱글 프로세서 환경에서는 멀티 쓰레드 해봐야 동시성(concurrency) 기반 작업이 됨


               6) 쓰레드는 한편으로는 동시성(concurrency) 또한 강조한 개념임
                  (= 여러개의 쓰레드는 프로세스의 context swiching 작업 또한 더 빠르게 처리하여 공유 자원을 또한 더 효율적으로 사용하기에, 비동기 처리 또한 더 빠르게 수행하게 해줌)


         5. 다중 프로세싱(multi processing)의 등장 (= 프로세스 단위로 진정한 병렬성(Parallelism) 개념과 병렬처리 가능한 시대)
             : 소위 말하는 듀얼 코어 CPU의 등장으로 프로세스들을 동시성(Concurrency)에 근거한 비동기가 아닌 병렬성(Parallelism) 병렬처리가 가능해짐
               (= 추후 이 멀티 코어가 쓰레드와 하드웨어적 소프트웨어적으로 더 연계되어... 개별 프로세스의 퍼포먼스 향상에도 프로세서의 모든 역량을 집중하는게 또 가능해짐)


  @ 컨텍스트(context) with 동시성(concurrency)
     : 실행 중인 프로세스(process)나 스레드(thread)의 상태를 나타내는 정보 집합 (레지스터 값, 프로그램 카운터 등의 정보 존재)
        -> 프로세스 간의 실행 순서와 동시성(concurrency)을 관리할 수 있기에, 프로세스 및 쓰레드 간의 스위칭이 가능해져 멀티태스킹이 실현
           (= 정확히는 프로세스 스케쥴링과 프로세스 내부의 비동기 작업, 병렬 처리에 전부 사용될 수 밖에 없음)
               -> (중요) js의 promise 객체 또한 정확히는 이 프로세스의 컨텍스트(context)에 대한 내용을 담는 개념임


  @ 쓰레드(thread) with 평행성(Parallelism)
     : 프로세스(= 컴퓨터에서 메모리에 instance로서 객체화 되어 올라가 실행중인 프로그램)마다 최소 1개는 존재하는 한 단계 더 낮은 프로그램의 최소 실행 흐름 단위
       (= 쉽게 말해, 쓰레드는 실행 중인 개별 프로세스 안에 속해서, 개별적으로 코드를 읽고 실행하는 주체로 이해하면 되며, 당연히 프로세스를 실행하기 위해서는 최소 실행 주체가 1개는 필요하다는 점에서 매우 상식적인 말임)
           -> ex) 프로세스(process) : 개별 건설현장 = 쓰레드(thread) : 현장 노동자
                  (= 건설 현장에서 업무를 수행하기 위해서는? 당연히 최소 1명의 노동자가 필요함)

      # 쓰레드(thread)의 특징
         1) 개별 thread는 각각 독립된 실행 흐름과 스택(stack)을 가짐
            (= 다른 thread와 처리 영역이 겹치는 고생을 하지 않기에, 동시성 문제를 방지하는 측면이 존재)

         2) 개별 thread는 프로세스 안에서의 전체적인 실행 흐름과 힙(heap)영역은 공유를 함
            (= 각자 하는 일이 전체를 향하는 일괄적인 흐름을 가진 작업이 됨)

         3) 개별 thread도 context가 존재하여, context switching의 대상이 될 수 있음

         4) 한 프로세스(process)의 여러개의 쓰레드(thread)가 존재 가능함

         5) 기본적으로 쓰레드는 평행성(Parallelism)을 근거로 한 물리적으로 동시적 프로그래밍 처리를 하는 병렬처리를 위해 만들어짐
             -> (주의!) 단! 진정한 평행성(Parallelism)은 멀티코어 cpu를 사용한 멀티 프로세서 환경에서 실현됨 = 싱글 프로세서 환경에서는 멀티 쓰레드 해봐야 동시성(concurrency) 기반 작업이 됨

         6) 쓰레드는 한편으로는 동시성(concurrency) 또한 강조한 개념임
            (= 여러개의 쓰레드는 프로세스의 context swiching 작업 또한 더 빠르게 처리하여 공유 자원을 또한 더 효율적으로 사용하기에, 비동기 처리 또한 더 빠르게 수행하게 해줌)


      # 다중 쓰레드(multi thread) with 병렬처리
         : 실행 중인 개별 프로세스에서 개별적으로 코드를 읽고 실행하는 주체가 여럿인 경우인 프로세스 환경을 의미하는 것으로.. 평행성(Parallelism)에 입각한 병렬처리가 가능해짐
            -> 쓰레드(thread)의 개수가 많으면, 평행성(Parallelism)이 context swiching을 더 효율적으로 수행하게 하여 동시성(concurrency)을 강화하기에, 프로세스의 비동기 코드 처리를 더 빠르게는 할수 있음..
                -> (중요) BUT! 쓰레드의 갯수는 비동기 작업 가능 여부와 1도 상관 X

         1) 다중 쓰레드(multi thread) + 동기적 프로그래밍 처리를 하는 경우
             : 싱글 쓰레드 환경과 마찬가지로.. 해당 작업이 완료될 때까지 다른 작업들이 블로킹 됨.. 
               (= 1요청 1응답이 완료 될 때까지 다른 쓰레드가 논다는 말씀...)

         2) 다중 쓰레드(multi thread) + 비동기적 프로그래밍
             : 싱글 쓰레드 일때?  
                -> 진행중인 비동기 코드의 컨택스트(context)을 번갈아가며 수행하는 컨텍스트 스위칭(context switing)으로 커버

             : 쓰레드의 수가 많을 때 
                -> 비동기 코드의 컨택스트(context)들을 실제로 동시에 다른 쓰레드들이 같이 처리해 줌 
                   (= 컨텍스트 스위칭(context switing)의 수가 적어짐)


      # (중요) 다중 쓰레드(multi thread) & 프로세서(processor)의 갯수에 따른 Concurrency(동시성) & Parallelism(병렬성) 관계
         : 다중 쓰레드(multi thread)의 Parallelism(병렬성)에 기반한 병렬 처리는 오직 다중 코어 CPU를 사용한 다중 프로세서(multi processor) 환경에서만 가능!
            <-> 싱글 프로세서(single processor) 환경에서는 멀티 쓰레드를 사용해봐야, 결국 다양한 작업들을 동시에 조율하고 번갈아가며 실행함으로써 마치 동시에 처리되는 것처럼 보이는 동시성(concurrency)에 기반한 기반 일종의 비동기 작업이 됨
                (= 그럼에도 이를 쓰는 이유는 이를 통해 응답없음으로 인한 블로킹을 피할수가 있음)


  @ 비동기 작업 VS 동기 작업
     : 요청(request)를 수행할 시, 응답(resonse)을 받을 때까지 다음 코드로 넘어가는가 넘어가지 않는가 여부에 따라 갈림

        1. 동기 작업 (순차적 작업)
           : 1요청(request)과 1응답(resonse)은 하나의 작업처리 단위(transaction) 세트로서 동시에 일어나는걸 전제로 하여, 프로세스의 흐름를 1차선적으로 수행하는 것을 동기라고 함
              -> 대충 노빠꾸 one way 전략에 위에서 까라면 밑에서는 일방적으로 까는 것과 비슷..
                 (= 2인 3각 릴레이 계주처럼, 한 팀의 작업이 끝날때까지 다른팀들은 보고만 있어야 함)
                     -> 쉽게 설계할 수 있지만, 결과가 주어질 때까지 아무것도 못하고 대기해야 함
  
        2. 비동기 작업(비순차적 작업) with 동시성(concurrency)
           : 요청(request)과 응답(resonse)이 동시에 일어나지 않는 별개의 작업처리 단위(transaction)로서, 동시성(concurrency)을 기반으로 동시 다발적으로 발생가능하고, 다른 작업을 시작할 수 있도록 제어가 반환되어 요청과 응답이 다른 시간대 존재해도 되는 작업 처리 방식을 비동기라고 함
             (= 프로세스의 작업처리 상태값을 가진 컨텍스트(context)를 통해, 비동기 코드를 수행중인 thread들이 어디에 비동기 코드가 있는지와 처리 여부를 체크가능)
                 -> 쉽게 말해, 개별 요청과 응답은 전체프로세스와 별개로 독립적이면서 병렬적으로 수행되며, 어떤 요청단위가 수행되고 나면 응답이 오는거랑 상관없이 다른 프로세스는 진행됨
                    (= 메인 쓰레드가 아닌 다른 쓰레드로 비유 가능한 계열사들이 본사의 의지랑 상관없이 자신의 비즈니스를 수행하고 계약하는 독립채산제나 현실의 회사생활에서 직원을 출장보내도 본사는 굴러가는걸 생각해보면 간단함)


      # 비동기 작업처리의 장, 단점    
         1) 장점
             : 결과가 주어지는데 시간이 걸리더라도, 동시기에 다른 작업 또한 동시에 할 수 있으므로 자원을 효율적으로 사용

         2) 단점
             : 제대로 신경을 쓰지 않으면, 한 프로세스의 작업처리 단위(transaction)들이 전부 비동기적으로 수행되어 일처리가 뒤죽박죽하게 됨
               (= 비동기적 작업방식을 통해 제대로 된 효율을 내기 위해서는 복잡한 설계도 감안해야 함..)
                  -> 비동기적 작업처리 프로세스 또한 통제를 위해서는.. 개별 비동기 코드들을 작업흐름(workflow) 용도를 기준으로 그루핑을 한 뒤, 그 그룹들이 각각 하나의 작업처리 단위(transaction)로서 하나의 컨텍스트(context)에 근거해 각각 동기적(= 순차적) 방식으로 단계적으로 수행될 수 있어야 한다는 결론 도출  
                      -> (중요) 여기서의 '컨텍스트(context) 단위'는 프로세스 내부의 업무들을 큰 틀에서 독립성을 가진 기준으로 짜여 있다 생각하자                                    


      # 비동기적으로 작동하는 코드들이 큰 틀에서 동기적(= 순차적)으로 단계적 동작하게 하는 방법(?)
         : 쉽게 말해, 비동기 작업처리 코드로 이뤄진 프로세스의 작동 로직을 기준으로 순번을 책정한 집단들을 컨텍스트(context) 단위로 세우고, 각 그룹에 해당하는 비동기 코드들을 분류 후 컨텍스트(context) 단위로 코드들의 실행타이밍을 통제함으로서, 그룹기준으로 순차적 처리가 가능하게 한다고 생각하면 됨
            -> 해당 프로세스의 논리적 작업흐름(workflow)의 개별 단위들을 기준으로 실제 프로세스 로직의 작업처리 단위(transaction)들을 분류하고, 그렇게 분류된 작업처리 단위(transaction)에 소속된 컨텍스트(context) 단위들은 자신이 소속된 작업흐름(workflow)가 실행될 타이밍에 맞춰 동시성(concurrency)을 가지고 수행됨
               (= 이를 통해 무질서하게 수행되는 개판 5분전을 방지하고, 비동기 코드의 실행 메커니즘을 인간의 시각을 기준으로 설계할 수 있게 됨)

               ex) 페이지 리로드 기능에 속하는 컨텍스트(context) 단위의 workflow 분류
                    (1단계) -> 필요한 페이지의 html파일들을 다운로드 하는 로직(해당 로직에 속한 작업처리 단위(transaction) 비동기적으로 실행)
                    (2단계) -> (1단계 완료시) 다운로드 받은 html파일들을 랜더링(해당 로직에 속한 작업처리 단위(transaction) 비동기적으로 실행)


         - 세부적 설명
            1단계) 프로세스의 내부 기능들을 업무 독립성 측면에서 분류하여 컨텍스트(context) 단위로 나누고, 해당 프로세스의 개별 컨텍스트(context) 단위의 비동기 코드들을 분류함
            2단계) 각 컨텍스트(context) 단위에 해당하는 기능별 로직들을 순차적인 작업흐름(workflow)의 집합으로 간주하고 나눔
            3단계) 해당 작업흐름(workflow)을 단위(= 시스템 입장에서는 작업처리 단위(transaction)로 간주)들을 기준으로 각 컨텍스트(context) 그룹의 비동기 코드들을 2차 그룹화를 시킴
            4단계) 각 그룹 내의 모든 비동기 코드들을 1개의 작업처리 단위(transaction)로서 간주, 작업흐름(workflow)의 순서를 기준으로 microtask queue에 넣어 실행타이밍 통제함
                   (= 시스템 입장에서의 작업흐름(workflow) 단위 == 작업처리 단위(transaction)로 간주)
             
         - 용어 설명
            1) 컨텍스트(context) 단위
               : 프로세스의 내부 기능들을 업무 독립성 측면에서 분류하여, 해당 프로세스의 개별 컨텍스트(context) 단위의 비동기 코드들을 1차적으로 분류하는 집단 기준
                 (= 대충... Promise 객체의 연쇄 호출에서 Promise 덩어리 전체를 떠올리면 됨)
                  -> 이를 통해 그 기능의 작업 상태를 하나의 컨텍스트(context)에 근거할 수 있고, 작업처리 단위(transaction) 별로 2차 분류된 비동기 코드들을 통제 가능

            2) 작업흐름(workflow) 
               : 비동기적 코드로 이루어진 프로세스의 로직을 업무로 추상화한 내용적 논리로 바라보는 인간의 관점을 분류(catagorize) 기준으로 삼아서, 큰 틀에서 작은 업무 단위들을 구분하여 질서정연하게 순차적으로 수행되는 업무 단위로 도식화한 결과물 
                 (= 작업처리 단위(transaction) == 시스템 입장에서의 보는 작업흐름(workflow) 단위)

            3) 작업처리 단위(transaction)
               : 도출된 개별 작업흐름(workflow)을 메커니즘적인 작업흐름의 단위로 간주하여, 그 개별 작업흐름(workflow) 단위(unit)를 기준으로 컨텍스트(context) 단위에 속한 원맨아미 같은 비동기 코드들을 2차적으로 분류하는 집단 단위 
                 (= 대충... Promise 객체의 연쇄 호출에서 개별 then() 단위나, await에 속한 코드를 떠올리면 됨)
                    -> 같은 분류기준으로 묶였을 경우 원래 한 몸이었던 것처럼 일괄적으로 조작 및 통제가 가능해지기에 작업처리 단위(transaction)라고 부름
       
            
         - (중요!) js에서도 이같은 작업흐름(workflow) 개념을 기점으로 비동기 프로세스의 작업처리 단위(transaction) 순서를 통제할 방식이 필요해서 등장한게 promise 객체
            -> Promise 객체의 상태값은 이 작업흐름(workflow)개념을 바탕으로 비동기 프로세스의 내부에서 순차적으로 작업처리 단위(transaction)의 수행되는 각 단위의 업무 처리 현황 및 결과가 기준이 됨


  @ Promise 객체
     : ECMA6 이후 JS로 작성된 프로세스의 내부 작업의 비동기 처리를 위해, 프로세스의 비동기 코드 작업 상태에 대한 정보(= 상태값)를 가지는 컨텍스트(context) 단위의 역할을 수행하는 promise 객체
        -> 거대한 비동기 프로세스을 '작업흐름(workflow)을 기준으로 작업처리 단위(transaction)'를 순차적으로 나눈 뒤, 그 영역의 성공/실패 여부를 상태값을 통해 통제하는 방식으로 의 무분별한 비동기적 컨텍스트(context)의 생성을 방지하여 프로세스의 안정적 실행을 가능하게 함
           (= 비동기 작업에 따른 상태값의 구현은 내부에서 비동기 작업의 (각 처리단계를) 성공여부를 boolean으로 잡으면.. 그 값에 따라서 Promise 객체 생성자의 parameter로 들어가는 무명함수의 parameter인 2개의 parameter로 놓은 2개의 callback(일반적으로 resolve, reject 불림) 중 하나를 실행하는 방식)
               -> 그렇기에, 순차적으로 동적하는 js에서 ajax 같은 비동기로 각각 병렬적으로 동작하는 기능을 구현이 가능함
                  -> 일반적으로 비동기처리를 통해 전체적인 작업의 처리시간(leading time)을 줄일 수 있음
                     (= 비동기 작업은 일반적으로 서버와의 데이터 통신이나 파일 읽기와 같이 시간이 오래 걸리는 작업을 의미)


      # (중요) Promise 객체가 각 비동기 작업처리 단위(transaction)의 성공/실패 여부를 판단하는 로직
         : (이름은 상관없지만) Promise 객체 생성자의 parameter로 들어가는 무명함수의 parameter로 들어가는 2개의 callback함수(일반적으로 resolve, reject 불리는)를 넣으면.. 내부에서 비동기 작업 성공여부를 boolean으로 기록되게 하면
            -> 비동기 작업 성공시 (= promise객체의 상태값 : fulfilled) : resolve를 실행
            -> 비동기 작업 실패시 (= promise객체의 상태값 : rejected)  : reject를 실행
         
               ex) const promise = new Promise((resolve, reject) => {

                     // 비동기 작업 수행 성공여부를 따지는 로직
                     if (isResolved == true) {
                       resolve("Success");   <- 성공적으로 처리될 경우 무명함수의 parameter 중 resolve를 callback함수로 호출
                     } else {
                       reject("Error");      <- 거부될 경우 무명함수의 parameter 중 reject를 callback함수로 호출
                     }
                     
                   });

      # (중요) Promise 객체의 비동기 작업처리 단위(transaction) 처리 결과 상태값 3가지
         : 비동기 프로세스 내부의 진행되는 로직들은 순차적으로 진행되는 작업처리 단위(transaction)의 성공/실패 여부를 기록한 각 Promise객체의 상태값에 따라 후속처리가 분기처리함
            -> (중요) 이 Promise객체의 상태값(pending, fulfilled, rejected)은 추후 비동기작업 처리 및 현재 단계 동기작업 처리의 성공/실패의 후속 처리 로직에 관여
               (= 각 단계의 비동기 작업처리 단위(transaction)의 성공/실패에 따른 후속 처리 로직은 상태값의 도출을 순차적으로 기다려야 함 == 비동기 작업의 일부 로직을 순차적인 동기적 처리로 처리함)   
                  -> 추후 fetch()나 axios 등 js에서 비동기로 서버와 통신한 ajax 통신 결과에 따른 분기처리를 가능하게 함

         1) 대기(pending)
            : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 수행이 아직 완료되지 않은 상태
               -> 상태값이 pending으로 유지됨 =  다음 단계의 then(), catch(), finally() 패턴 및 async, await에서 다음 단계의 await 구문의 실행을 억제하는데 사용
                  (= '상태값이 pending -> 다른 상태로 변화'가 비동기 작업의 일부 로직이 동기적으로 처리되게 유도하는 일종의 트리거 역할)
 
         2) 이행(fulfilled)
            : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 수행이 성공적으로 완료된 상태
                -> then(), catch(), finally() 패턴의 .then()와 async, await에서 패턴에서 await를 구현하는데 사용
                   (= 상태값이 fulfilled로 전환되는 순간, 해당 코드들이 순차적으로 실행)

         3) 거부(rejected)
            : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 수행이 실패한 상태
                -> then(), catch(), finally() 패턴의 .catch()을 구현하는데 사용
                    -> (중요!) async, await에서도 비동기작업이나 현재 await 작업의 실패 후의 처리는 .catch()가 맡게 됨
                       (= async, await와 then(), catch(), finally()는 공존이 가능하다는 결론이 나옴...)


      # ajax와 axios, fetch API와 Promise 객체의 관계
         : 추후 ajax 기능을 수행하는 axios와 fetch API 또한 promise 객체의 상태값을 기반으로 동작하는 비동기 작업
           (= js의 비동기적 정보 교환 기법은 각 작업처리 단위(transaction) 수행에 따른 결과값을 가진 Promise 객체를 return함)
            -> (중요) 그들의 요청에 대한 응답 내용 또한 비동기 프로세스의 개별 작업처리 단위 수행 결과의 후속을 처리하는 하단의 then(), catch(), finally()와 async / await을 이용하여 처리할 수 있음


  @ Promise API
     : Promise 객체에는 5가지 정적 멤버함수들이 존재하며, 프로세스 안의 여러개의 비동기 작업 코드들에 대한 통제를 더 의도(semantic)를 가지고 정확하게 할 수 있음

        1. Promise.all( iterable 객체 ) 
            : (중요) promise 객체들이 여러개 있고, 그들의 작업을 동시성을 가지고 진행시키고, 이들이 끝나기 전까지 다음 작업을 처리하지 않고 기다려야 하는 경우 사용하는 함수
                -> 쉽게 말해, 각 업무를 기준으로 구분한 비동기 작업 코드로 이뤄진 컨텍스트(context) 집단들 여러개를 더 큰 틀에서 일괄적으로 동시성(concurrency)을 가지고 동작하도록 통제하기 위한 방법

                ex) Promise.all( [promise 객체1, ... promise 객체n])
                     : (중요) 함수의 결과값은 안에 존재하는 promise 객체들의 처리가 '전부 성공' or '하나라도 실패'의 경우로 나뉨

                         - iterable 객체 안의 promise 객체의 비동기 작업 전부 성공시?
                             : 각 promise 객체가 가진 작업처리 성공에 대한 결과값의 배열형식으로 변환되어, 새로운 promise 객체의 상태값으로 반환

                               ex) Promise.all의 성공 결과값 예시
                               
                                   [promise 객체1 성공상태값, ... , promise 객체n 성공상태값]
                                     -> (주의) 해당 배열의 순서는 parameter로 들어간 iterable 내부의 index 그대로임

                               ex) 모든 비동기 처리 성공한 Promise.all 예시

                                   // 1, 2, 3이 새로운 promise 객체의 상태값으로 반환
                                   Promise.all([
                                     new Promise(resolve => setTimeout(() => resolve(1), 3000)), // 1
                                     new Promise(resolve => setTimeout(() => resolve(2), 2000)), // 2
                                     new Promise(resolve => setTimeout(() => resolve(3), 1000))  // 3
                                   ]).then(alert); 


                         - iterable 객체 안의 promise 객체의 비동기 작업 하나라도 실패시?
                             : 그 즉시 Promise.all 전체가 거부 처리 되어서 .catch 구문이 실행됨...
                                -> (주의) 그렇다고 다른 promise 객체를 통한 비동기 작업까지 중지되진 않음.. 단지 다른 비동기 처리결과에 따른 promise 객체의 상태값이 그 뒤 어쩄든 상관없이 완전히 무시됨

                               ex) 비동기 처리 중 하나라도 작업처리 실패가 나는 Promise.all 예시

                                   // Error: 에러 발생!
                                   Promise.all([
                                     new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
                                     new Promise((resolve, reject) => setTimeout(() => reject(new Error("에러 발생!")), 2000)),
                                     new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
                                   ]).catch(alert); 


            # Promise.all( iterable 객체 ) 특징
               1) parameter로 들어간 iterable 객체 안의 promise 객체들은 일괄적인 타이밍에 비동기로 실행됨
               2) (중요) Promise.all() 함수의 결과값은 안에 존재하는 promise 객체들의 처리에 따라 all or nothing같은 개념
               3) Promise.all() 함수의 결과값이 성공처리 되었는데, iterable 객체에 일반값이 있는경우.. 성공값에 해당하는 배열에 그 일반값이 들어감

                  ex) Promise.all([ new Promise((resolve, reject) => { setTimeout(() => resolve(1), 1000) }), 2, 3 ]).then(alert); 
                       -> 결과값 : [1, 2, 3]

               4) parameter는 iterable 객체면 뭐든 ㅇㅋ임
                  (= promise 객체가 아닌 일반값도 넣을 수 있음)
                      -> 물론 대개는 promise 객체 배열이 들어감

               5) Promise 객체에는 '취소’라는 개념이 없어서, Promise.all도 프라미스를 취소하지 않움
                  (= catch() 뜨는걸 원하지 않아서, 해당 Promise 객체에 속한 작업을 취소할 수 없다는 말)
                     -> 만약 각 비동기 작업의 실패/성공 응답을 받고 싶으면 Promise.allSettled을 쓰자


        2. Promise.allSettled( [promise 객체1, ... promise 객체n])
            : Promise.all과 비슷하나... all or nothing 개념이 아니라.. 각 promise의 처리에 대한 결과값을 응답으로 각각 반환해줌

              ex) let urls = [
                    'https://api.github.com/users/iliakan',
                    'https://api.github.com/users/Violet-Bora-Lee',
                    'https://no-such-url'
                  ];
                  
                  Promise.allSettled(urls.map(url => fetch(url)))
                    .then(results => { 
                      results.forEach((result, num) => {
                        if (result.status == "fulfilled") {
                          alert(`${urls[num]}: ${result.value.status}`);
                        }
                        if (result.status == "rejected") {
                          alert(`${urls[num]}: ${result.reason}`);
                        }
                      });
                    });

                  ------------------------------------------------------------------
                  [ {status: 'fulfilled', value: ...응답...},
                    {status: 'fulfilled', value: ...응답...},
                    {status: 'rejected', reason: ...에러 객체...} ] 형식으로 반환
                  ------------------------------------------------------------------

              - 응답이 성공할 경우 : {status:"fulfilled", value:result} 형식으로 해당 promise 결과값 리턴
              - 에러가 발생한 경우 : {status:"rejected", reason:error} 형식으로 해당 promise 결과값 리턴

        3. Promise.race( [promise 객체1, ... promise 객체n])
            : Promise.all과 비슷하나, 다만 가장 먼저 처리되는 프라미스의 결과(혹은 에러)만을 반환

               ex) 다음 작업은 1번쨰 promise 객체의 비동기 작업이 가장 빨리 나왔기에, 1번쨰 promise의 결과값만 출력

                   Promise.race([
                     new Promise((resolve, reject) => setTimeout(() => resolve(1), 1000)),
                     new Promise((resolve, reject) => setTimeout(() => reject(new Error("에러 발생!")), 2000)),
                     new Promise((resolve, reject) => setTimeout(() => resolve(3), 3000))
                   ]).then(alert); // 1

        4. Promise.resolve( value )
            : (async/await 등장 이후 사장) value 에 해당하는 parameter 값으로 작업 상태값이 성공 상태인 promise 객체를 생성
              -> (중요!) 상단 promise객체 생성과 하단 then() 구문에서 지겹게 보는 무명함수의 1번쨰 parameter인 callback함수명이 이 녀석

        5. Promise.reject( error )
            : (async/await 등장 이후 사장) error에 해당하는 parameter 값으로 작업 상태값이 실패 상태인 promise 객체를 생성
              -> (중요!) 상단 promise객체 생성과 하단 then() 구문에서 지겹게 보는 무명함수의 2번쨰 parameter인 callback함수명이 이 녀석

               ex) const promise = new Promise((resolve, reject) => {

                     if (isResolved == true) {
                       resolve("Success");   <- 성공적으로 처리될 경우 무명함수의 parameter 중 resolve를 callback함수로 호출
                     } else {
                       reject("Error");      <- 거부될 경우 무명함수의 parameter 중 reject를 callback함수로 호출
                     }
                     
                   });

                   promise.then(
        
                     (result) => {
                       console.log("Resolved:", result);
                     },
                     (error) => {
                       console.error("Rejected:", error);
                     }
                   )


  @ then(), catch(), finally()
     : 비동기 프로세스의 개별 작업처리 단위(transaction)를 기준으로, 각 작업이 진행완료 될 때까지(pending) 기다린 뒤 그 성공(fulfilled)과 실패(rejected) 결과를 바탕으로 경우의 수에 따른 수행할 분기 구조를 구현하는데 사용되는 promise 객체의 멤버함수들
       (= 비동기 작업 시도를 try로 보면 try ~ catch와 유사 + 비동기 작업의 일부를 동기적인 것으로 만듦)
           -> (중요) then(), catch(), finally()는 전부 무명의 콜백함수를 parameter로 가짐
                : but! 몇개의 callback 함수가 parameter로 들아가는지가 다름
                   => then()의 경우?    2개의 무명의 콜백함수를 parameter로 가지고, 그 콜백함수는 각각 2개의 object(일반적으로 result, error라고 불림)를 parameter로 가짐 
                   => catch()의 경우?   1개의 무명의 콜백함수를 parameter로 가지고, 그 콜백함수는 1개의 object(일반적으로 error라고 불림)를 parameter로 가짐 
                   => finally()의 경우? 무명의 콜백함수는 parameter로 가지지 않음

               ex) const promise = new Promise((resolve, reject) => {
        
                     // 비동기 작업 수행 성공여부를 따지는 로직
                     if (isResolved == true) {
                       resolve("Success");   <- 성공적으로 처리될 경우 무명함수의 parameter 중 resolve를 callback함수로 호출
                     } else {
                       reject("Error");      <- 거부될 경우 무명함수의 parameter 중 reject를 callback함수로 호출
                     }
        
                   });
        
                   // 상단의 promise객체를 통한 비동기작업이 끝난 이후 then(), catch(), finally() 함수는 수행
                   promise.then(
        
                     (result) => {
                       console.log("Resolved:", result);
                     },
                     (error) => {
                       console.error("Rejected:", error);
                     }
        
                   ).catch((error) => {
                     console.error("Caught an error:", error);
        
                   }).finally(() => {
                     console.log("Finally");
                   });


         1) then()
            : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction)의 성공/실패 후, 분기에 따라 자신의 parameter인 2개의 무명의 콜백함수(각각 result, error로 알려진 object를 parameter로 가져감) 중 하나를 실행함
               -> (중요) 2개의 무명함수 parameter로 선언만해두고 사용 안 해도 무방함
         
              a. (1번째 무명함수 parameter) result
                  : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 결과가 성공이면, 그 성공의 결과값을 가지는 object
         
              b. (2번째 무명함수 parameter) error
                  : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 결과가 실패이면, 그 실패의 결과값을 가지는 object
                     -> catch()로도 구현가능!
         
         2) catch()
            : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 결과의 실패가 감지되면, 자신의 parameter인 무명의 콜백함수(error로 알려진 object만 parameter로 가져감) 중 실행함
              (= catch() == then()의 실패 케이스만 특정한 Promise 객체의 멤버함수)
                  -> 따라서, then()은 비동기처리 성공시에만 동작하게 쓸 수도 있음
         
         3) finally()
            : (비동기 프로세스의) 현제 작업처리 단위(transaction) 결과의 성공/실패와 상관없이, 자신의 parameter인 무조건 무명의 콜백함수를 실행함
               -> finally()의 parameter인 무명의 콜백함수는 parameter를 가지지 않음


      # then(), catch(), finally() 비동기 프로세스 처리 패턴의 약점 및 한계
         : 작업처리 단위(transaction)안의 작업처리 단위(transaction)의 등장으로 인한 callback hell 문제로 인해 코드가독성이 메챠쿠챠...
            -> 이를 해결하기 위해 등장한게 async / await 패턴과 React hooks라고 보면 됨

               ex) promise.then(
                     (result) => {

                        promise.then(
                           (result) => { 

                              promise.then((result) => { 내용 })
                               .catch((error) => { 내용 })
                               .finally(() => { 내용 })
                        })
                        .catch((error) => { 내용 })
                        .finally(() => { 내용 }
                     }

                   ).catch((error) => {
                     console.error("Caught an error:", error);
                   }).finally(() => {
                     console.log("Finally");
                   });


  @ async / await
     : (then(), catch(), finally()의 callback hell 문제를 막기 위해) Promise의 상태값을 기반으로 특정 함수를 기반으로 비동기 프로세스로서 병렬적으로 처리하기 위한 비동기 프로세스 처리 패턴
        -> 특정 함수를 비동기 프로세스로서 병렬적으로 처리하기 위한 예약어로 async를 사용, 그 {} 안에 특정 코드가 작업처리 단위(transaction)의 기점으로서 요청에 대한 응답이 나올떄까지 대기하도록 하기 위한 이정표 역할의 예약어로서 await를 사용
           (= async 함수명{ await코드; 코드 ~~  await 코드;} 이런식으로 사용)

         1) async
            : 어떤 함수를 비동기 프로세스로서로 병렬적으로 코드를 처리하라고 표기하기 위한 목적의 예약어
               -> 비동기 프로세스 작업 처리 결과의 성공/실패에 대한 상태값을 가진 promise 객체를 return함

         2) await   
            : async로 비동기 방식 처리 간판이 붙은 함수 작업영역의 코드 중, 수행결과가 나올 떄까지 기다려야 하는 작업처리 단위(transaction)의 기점이 될 코드를 의미하는 표식을 의미하는 예약어가 await
                -> (중요!) await는 이전 await의 다음 코드 ~ 현재 await 코드의 범위인 해당 작업처리 단위(transaction)의 처리결과가 성공이었을 때만, 다음 await까지의 작업처리 단위(transaction)를 진행함
                   (= 작업처리 단위(transaction의 결과가 성공시에만 진행되는 then() 패턴을 공식적으로 다른 방식으로 구현한 것에 가까움)


      # (중요) async / await 작업처리 단위(transaction)의 실패 후의 처리는 .catch()가 맡게 됨
         : then(), catch(), finally()와 async / await는 공존이 가능함을 암시함.. 
            -> 전자는 promise 객체의 메서드고, 후자는 promise객체를 기반으로 동작하기 때문에 호환됨

               ex) async function fetchData() {
                  
                     try {
                       const response = await fetch('https://api.example.com/data');
                       const data = await response.json();
                       
                       const userResponse = await fetch('https://api.example.com/user/' + data.userId);
                       const userData = await userResponse.json();
                       
                       console.log('Order:', orderData);

                     } catch (error) {
                       console.error('Error:', error);
                     }
                   }



  @ Ajax(Asynchronous JavaScript and XML)
     : 프로그래밍 언어인 JavaScript와 마크업 언어인 XML을 이용해서, 브라우저에서 새로고침을 하지 않고도 서버에 GET, POST 요청을 통해 데이터를 주고받을 수 있게 도와주는 브라우저 차원에서 지원되는 비동기적 정보 교환 기법
       (= 쉽게 말해, 웹페이지를 개발할 때, JavaScript를 이용해서 서버에 GET, POST 요청을 새로고침이 없이 비동기적인 연속성을 가지고 보내고, 받고 할 수 있음을 의미)
          <-> 과거 html태그 중 form 태그가 이런 서버에 대한 데이터 요청을 'http메서드(get, post에 한정) + url형식'을 통해 http API 방식으로 티키타카를 할 수 있게 하였으나..? 티키타카할 떄마다 화면이 새로고침이 되어 모든 html요소와 데이터를 다시 받아오는걸 피할 수 없었음


      # 관련 개념 간단 설명 및 정리

         1. 서버
             : 유저가 데이터달라고 요청(request)을 서버가 정한 API 규격(요청 방법 : 어떤 자료 = http메서드 : url형식)에 맞게 하면, 이를 알아먹고 요청에 맞는 데이터를 보내주는(response)하는 간단한 프로그램을 실행하는 컴퓨터

                ex) 유튜브 서버     = 유저가 영상 달라고 하면 영상 보내주는 프로그램을 돌리는 컴퓨터
                    네이버웹툰 서버 = 유저가 웹툰 달라고 하면 웹툰 보내주는 프로그램을 돌리는 컴퓨터

         2. http 메서드
             : 월드 와이드 웹(World Wide Web)에서 사용되는 Hypertext Transfer Protocol(HTTP)을 통해 서버에 요청을 보내는 방법을 정의하는 명령어
               (= 쉽게 말해, client(유저)가 서버로 하여금 일부 자원(resource)에 대한 자료를 보내면, 이를 이용해 수행해야 할 구체적인 동작 방식 종류를 핀포인트로 지정하는 것이라 보면 됨)
                   -> 대충 어떤 url에 딸려 있는 자원(resource)을 어떻게 작업(http 메서드)을 쳐라라는 동사적인 의미를 가지고 있음  

              - http 메서드의 종류

                 1) GET (원년 멤버)
                     : 서버에서 보낸 데이터를 단순 조회하기 위해 사용하는 http 메서드
                        -> (중요) 요청시 http의 head 부분에 client(유저)가 보낸 parameter가 url과 함께 보이는 특징 존재
                        -> 동일한 요청을 연속적으로 수행해도, 같은 결과가 나옴 = 데이터가 변조되지 않기에 안전한 http 메서드

                 2) POST (원년 멤버)
                     : 서버로 일부 데이터를 보내면, 이를 이용해서 서버로 하여금 새로운 데이터들을 생성/변조/삭제하기 위해 사용하는 http 메서드 
                        -> (중요) 요청시 http의 head 부분에는 url과 http메서드만 보일 뿐, client(유저)가 보낸 parameter는 body 부분에 놓여있어 보이지 않음
                        -> PUT, PATCH, DELETE를 대체할 수 있는 범용성 높은 http 메서드
                        -> 동일한 요청을 연속적으로 수행하면, 여러 리소스가 생성될 수 있음 = 데이터가 변조되기에 안전 X한 http 메서드

                 3) PUT
                     : 서버로 보낸 내용이 기존 리소스의 모든 데이터를 빈 칼럼값까지 완벽하게 대체하여 수정하는 데 사용하는 http 메서드
                        -> (중요) 업데이트 하는 내용이 유저가 보낸 내용과 완전히 동일함 = 동일한 요청을 연속적으로 수행해도, 같은 결과가 나옴 = 데이터가 변조되지 않기에 안전한 http 메서드

                 4) PATCH
                     : 서버의 기존 리소스를 부분적으로 업데이트하는 데 사용되는 http 메서드
                        -> (중요) 업데이트 하는 내용이 부분적으로 지정되어 있음 = 동일한 요청을 연속적으로 수행해도, 같은 결과가 나옴 = 데이터가 변조되지 않기에 안전한 http 메서드

                 5) DELETE
                     : 서버에서 데이터를 제거할 때 사용하는 http 메서드
                        -> (중요) 삭제할 데이터는 특정한 값을 기준으로 정해져 있음 = 동일한 요청을 연속적으로 수행해도, 같은 결과가 나옴 = 데이터가 변조되지 않기에 안전한 http 메서드


              - http 메서드가 get, post 이외로 더 생기는 이유

                 1) http 메서드의 갯수가 많아지면, 메서드명 자체에 의미적(semantic)인 부분을 고려할 수 있게 되고, 유저나 개발자가 해당 http API의 의도를 더 쉽게 파악할 수 있음
                 2) 같은 url이라도 http 메서드가 다르면, 동사적인 의미(semantic)자체가 달라지기에, 다른 http API로 구분될 수 있기 때문
                     -> class에 따른 집합의 존재로 같은 변수명들의 구분이 가능하여, 변수명 짓기의 스트레스에서 쉽게 벗어나는 같과 같이, url 설계에서도 스트레스가 많이 사라지게 됨


      # JS기반 언어에서 Ajax(Asynchronous JavaScript and XML) 사용하는 방법

         1. XMLHttpRequest라는 옛날 고전적인 js에서의 ajax 문법 사용
         2. js ECMA6 이후 등장한 fetch() 사용
         3. axios라는 js 외부 라이브러리 사용


      # axios VS fetch

         1. 공통적인 부분
             1) 둘 다 JS의 promise가 상태를 관리하여 다른 코드가 비동기적으로 실행될 수 있도록 만드는 객체인 Promise 객체의 API를 기반으로 사용하여 구현된 기능
             2) 둘 다 JS의 사용자가 서버로 http 메서드 + url로 요청을 보내는 짓은 비동기로 병렬적 실행을 하지만, 각 요청은 요청에 대한 결과가 나올 때까지 기다려야 함..
                 -> 각 http 메서드를 통한 요청에 대한 결과를 기다린 뒤에는? 
                     a. then(), catch(), finally() 함수
                         : 비동기 작업의 '성공 or 실패 or 무조건 실행' 이라는 조건에 맞춰 try, catch, finally와 유사한 느낌으로 then(), catch(), finally() 함수를 연쇄적으로 사용해서 시도에 대한 성공 실패여부를 따지는 조건분기 진행루트를 만들 수 있음
                        (= try ~ catch가 switch 문법 기반이니 만큼, then(), catch(), finally() )
                 
             3) (둘 다 ajax 방식으로 서버와 통신하기에) 받아오는 데이터는 json이나 html종류를 받아옴
             4) (둘 다 ajax 방식으로 서버와 통신하기에) 비동기식으로 병렬적으로 코드를 수행함 = 연달아 들어오는 fetch()나 axios 구문이 있으면, 거의 시간차 없이 수행된다 보면 됨
                 -> 그래도... 동시에 수행하는건 아니기에.. 어쩄든 진짜 여러 ajax 요청들을 최대한 동시기에 비동기적으로 보내기 위해 사용하는게, js의 Promise 객체의 정적 함수 임 
        
         2. 차이점

             - axios 특성
               1) 장점
                   a. 받아오는 json 형식의 데이터를 사용자가 보기 좋게 자동으로 array로 변환해 줌
                   b. http메서드를 단순히 axios 객체의 멤버함수로 제공해서 쓰게 함으로서, 개발자로 하여금 직관적으로 http 메서드를 사용하게 함

               2) 단점 : 외부 js 라이브러리이기에 어쩄든 개발자가 조금이라도 번거로워지고, 서비스에서 로딩시간 증가에 영향을 줄 소지는 있음

             - fetch()
               1) 장점
                   a. ECMA6에서 기본으로 지원되는 함수라서, 별 다른 과정없이 그냥 써먹을 수가 있음

               2) 단점
                   a. 받아오는 json 형식의 데이터를 자동으로 array로 변환해주진 않아서, 요청이 성공해서 데이터를 받으면 이를 변환하는 코드가 추가되어야함
                   b. axios 라이브러리 처럼, http메서드를 단순히 axios 객체의 멤버함수로 제공해서 쓰게 하는게 아니라... 2번쨰 parameter로 js객체 형식으로 옵션값을 통해 http 메서드의 속성들을 하나하나 지정해줘야 함


  @ axios 라이브러리

      # axios 라이브러리 설치 및 모듈 불러오기 명령어
         : npm install axios
           import axios from 'axios'


      # axios 특성
        1) 장점
            a. 받아오는 json 형식의 데이터를 사용자가 보기 좋게 자동으로 array로 변환해 줌
            b. http메서드를 단순히 axios 객체의 멤버함수로 제공해서 쓰게 함으로서, 개발자로 하여금 직관적으로 http 메서드를 사용하게 함

        2) 단점 : 외부 js 라이브러리이기에 어쩄든 개발자가 조금이라도 번거로워지고, 서비스에서 로딩시간 증가에 영향을 줄 소지는 있음

   
      # axios로 http 메서드 요청을 보내는 문법
         1) axios.get('url명')  
             : 해당 url명으로 get요청을 하게하는 axios 라이브러리의 멤버함수
   
         2) axios.post('url명', {name : 'kim'})
             : post는 요청자가 데이터를 보내면, 그걸 서버가 가공한 후 response를 보냄
   
         3) 요청에 대한 리턴이 등장하면.. promise 객체의 상태값에 따라 후속 처리를 하면 됨
             -> 상단의 then(), catch(), finally()나 async, await 구문 참고


      # axios 사용시 주의사항
         1) json으로 돌아온 응답값은 axios에서는 json -> object array 형태로 자동 변경해 줌..
         2 '결과값명.data'로 사용자가 원하는 object array 데이터 꾸러미를 받고, 가공할때는 array에서 멤버객체를 지정해 시작하자
             -> 안 그러면, 사용자가 바라는 요청데이터 이외에, 어마어마한 상태값을 가지는 object나 array가 그냥 통쨰로 들어오고 타입에러가 생김

  @ fetch()
     : 비동기 작업으로 네트워크를 통해 리소스를 가져오는 ajax 기능을 수행하는데 사용되는 Promise API를 기반으로 작성된 JS함수, 기본적으로 return의 결과로 Promise를 반환하여 각 작업들은 결과에 따른 분기 처리도 가능함

      # fetch() 특성
         1) 장점
             a. ECMA6에서 기본으로 지원되는 함수라서, 별 다른 과정없이 그냥 써먹을 수가 있음
 
         2) 단점
             a. 받아오는 json 형식의 데이터를 자동으로 array로 변환해주진 않아서, 요청이 성공해서 데이터를 받으면 이를 변환하는 코드가 추가되어야함
             b. axios 라이브러리 처럼, http메서드를 단순히 axios 객체의 멤버함수로 제공해서 쓰게 하는게 아니라... 2번쨰 parameter로 js객체 형식으로 옵션값을 통해 http 메서드의 속성들을 하나하나 지정해줘야 함

      # fetch() 함수 호출로 http 메서드 요청을 보내는 문법구조..
         : 크게 '요청' -> '응답' -> '결과값으로 가공' 이렇게 3개의 단계를 가지며.. 요청에 대한 응답에서 문제가 생기면, 그냥 catch()를 통한 에러처리..
       
         1) fetch() 함수를 사용하여 http '요청' 보내기
             : 함수의 parameter로 url 주소는 필수로 입력해야 함
               (= headers나 method와 같은 멤버가 있는 객체타입 파라미터인 options는 필수는 아님)

               - options 객체 parameter의 멤버

                  a. headers 멤버객체
                      : http요청에 설정할 header 영역 정보 가짐

                  b. method 멤버변수
                      : get 이외의 메서드 사용시 적어야 함

                  c. body 멤버변수
                      : post 메서드와 같이 요청시 서버에 '문자열' or Form 데이터, blob 등의 값을 보내는게 있을시 사용 
                         -> (주의) 본문이 문자열일 때 Content-Type 헤더가 text/plain;charset=UTF-8로 기본 설정 
                                  (= json같은거로 응답 받으려면, 헤더에 Content-Type 에 대한 값을 'application/json;charset=utf-8'로 작성해 야함 )
 
              ex) fetch('url명', { headers : { 멤버1 : 값1 , ... , 멤버n : 값n} ,
                                   method  : '메서드명' ,
                                   body    : '문자열' or Form 데이터, blob 등  });

         2) 서버로 부터 데이터를 받은 '응답' ->'결과값' 가공
             : 요청에 대한 응답이 도착했으면, then()이나 await 를 사용하여 응답으로 받은 값을 소위 response(이름은 뭘로해도 상관없음.. 단지 요청에 대한 결과를 품는 promise객체를 의미하면 됨) 메서드라는 promise기반 함수를 통해 원하는 타입으로 변경하는 후속처리 감행
               (= axios는 이 부분에 대해 기본적으로 json() 함수로 변형을 하고, 이걸 또 object array로 자동으로 변형해주는 셈)

               - response 메서드
                 : 응답값 본문을 원하는 타입으로 바꿔줘서 후속처리를 할 수 있게 도와주는 promise기반 함수
                    -> (주의) input 자체가 애초에 object만을 대상으로 하기에, response.text().json() 이런식으로 중첩사용이 안 됨

                    a. response.text()        : 응답값을 text로 변환해 반환
                    b. response.json()        : 응답값을 JSON 형태로 파싱해 변환해 반환
                    c. response.formData()    : 응답값을 FormData 객체 형태로 변환해 반환
                    d. response.blob()        : 응답값을 Blob(타입이 있는 바이너리 데이터) 형태로 변환해 반환
                    e. response.arrayBuffer() : 응답값을 ArrayBuffer(바이너리 데이터를 로우 레벨 형식으로 표현한 것) 형태로 변환해 반환
                    f. response.body          : 응답값을 본문을 청크 단위로 읽을 수 있음
                 
                  ex) await 방식
    
                      let response = await fetch('https://api.github.com/repos/javascript-tutorial/ko.javascript.info/commits');
                      let commits = await response.json();
                      alert(commits[0].author.login); 
    
                  ex) then() 방식
    
                      fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
                      .then(response => response.json())
                      .then(commits => alert(commits[0].author.login));

               - response의 멤버객체 header
                 : 요청시 option 객체에 header에 대한 멤버변수 정보를 보냈으면, 응답시 해당 header 값에 대한 정보도 같이 나오는데.. 이를 response객체를 통해 호출 가능
                    -> (참고) 멤버변수 : 멤버값 형식으로 저장되기에 key, value 형식으로 꺼내쓰기도 됨

                  ex) await 방식
    
                      let response = await fetch('https://api.github.com/repos/javascript-tutorial/ko.javascript.info/commits');
                      let header = await response.headers.et('요청할 header명');
                      alert(header); 

                      for (let [key, value] of response.headers) {
                        alert(`${key} = ${value}`);
                      }
    
                  ex) then() 방식
    
                      fetch('https://api.github.com/repos/javascript-tutorial/en.javascript.info/commits')
                      .then(response => response.get('요청할 header명'))
                      .then(header => alert(header));


               - 그 외 response의 멤버변수들
                  a. response.status : 응답의 HTTP 코드
                  b. response.ok     : 응답 상태가 200과 299 사이에 있는 경우 true           



                                   
  @ localStorage & sessionStorage
     : 웹 브라우저에서 데이터를 저장하는 데 사용되는 옵션들
       (= 서버가 아닌 client 쪽에 저장해서 사용할 로직과 이에 필요한 데이터를 저장하는 공간)      

      # localStorage & sessionStorage 공통 특징
         1) 문자열만 저장 가능
         2) key, value 형식 저장
         3) 수정 불가 (= 삭제 후 생성 다시 해야..)   

      # localStorage & sessionStorage 차이점
         1) 데이터 수명
             - localStorage   : 사용자가 정리하기 전까지 유지
             - sessionStorage : 사용자와의 현재 세션이 유지되는 동안만 유지 (= 탭이나 브라우저 종료되면 삭제)      

         2) 접근 범위
             - localStorage   : 동일한 도메인(사이트) 내의 모든 웹 페이지에서 공유됨 (= 그 이외의 웹페이지에서는 참고 불가)
             - sessionStorage : 사용자와의 현재 세션이 유지되는 동안 모든 탭 간에 공유가 가능      

         3) 용도
             - localStorage   : 지속적인 상태 정보(ex : 유저 설정, 로그인 정보)
             - sessionStorage : 임시 정보 (ex : 장바구니 정보)     
              
         4) 저장 크기
             - localStorage   : 도메인(사이트)마다 5MB
             - sessionStorage : 20MB      

      # localStorage & sessionStorage 메서드

        - localStorage & sessionStorage.setItem(key값, value값)
           : 브라우저의 localStorage 항목에 key, value를 저장하기 위한 localStorage 객체의 내부함수  

        - localStorage & sessionStorage.getItem(key값)
           : 브라우저의 localStorage 항목의 해당 key에 있는, value를 추출 위한 localStorage 객체의 내부함수    

        - localStorage & sessionStorage.removeItem(key값)
           : 브라우저의 localStorage 항목에 해당 key에 해당하는 key, value를 삭제 위한 localStorage 객체의 내부함수     

    JSON 전역 객체
     : JS에서 JavaScript Object Notation(JSON)을 분석하거나 값을 JSON으로 변환하는 메서드를 가지는 전역객체  

      # JavaScript Object Notation(JSON)
         : Javascript 객체 문법을 따르는 문자열 기반의 데이터 포맷으로.. 베이스가 된 문법이 JS의 object일뿐 어디서나 쓸수 있는 범용적 데이터 포맷
            -> JSON의 특성
               1) JSON은 순수히 데이터 포맷 (= 멤버변수 O , 메서드 X)
               2) 프로퍼티와 값을 구분시, 큰 따옴표("") 만 사용해서 구분할 수 있음
               3) JSON은 '문자열'로서 JSON은 그 전체에 해당하며, 이를 파싱(paring)하여 JS Object로 쓸 수 있게 변환함
                  (= JSON 형식 데이터 그 자체로는 JS object 마냥 객체명.프로퍼티명 or 객체명['프로퍼티명']; 이런식으로 쓸 수 없음)      

      # JSON 메서드
        - JSON.stringify(array/object 변수)
           : paramter의 array/object -> JSON 변환하여 문자열로서 저장 가능하게 하는 JSON 객체의 내부 함수
              -> 선택 사항으로 특정 속성만 포함하거나, 사용자 정의 방식으로 속성을 대체 가능      
              
        - JSON.parse(JSON 형식 구문)
           : paramter의 JSON 형식 문자열을 JSON으로서 구문 분석하여, JSON구문 -> array/object나 숫자 문자 반환
              -> 선택적으로 분석 결과의 값과 속성을 변환해 반환
                  -> BUT! object의 함수는 받아주지 못함


           





