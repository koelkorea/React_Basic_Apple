 [functional component를 기준으로 작성된 설명임을 밝힘]
   -> class component도 하단에 언급함.... 추후 class -> function으로 넘어가기까지의 역사나 hooks에 관련된 역사적 부분까지 정리할 예정

 react 라이브러리 사용시 jsx 형식을 사용하며, 그 내부에서 사용자지정 HTML 태그와 같은 <App>으로 명명되는 HTML conponent를 제작.. 
  -> react 라이브러리는 index.js에서 ReactDOM.createRoot(document.getElementById('root')).render 함수 안에 이런 conponent를 조립해서 블록으로 장난감 만들듯 구성한 페이지
     -> ReactDOM 라이브러리의 static함수인 render API를 통해, 이를 최종적으로 index.html의 root라는 id의 div태그에 전달함으로서, 브라우저가 rendering을 하게 함

 - jsx(java script extention)란 무엇인가?
    : js에 자체적인 확장 문법을 곁들은 형식의 언어로 이를 통해서 react는 프로그래머에게 코딩의 직관성과 편의성을 강력하게 제공함
       -> 1. js에서 HTML component 작성을 통해, html 구성의 기본 벽돌과도 같은 component를 html 형식의 문법 거의 그대로 사용해서 쉽게 만들 수 있음
              : 일단 component를 만들어두고, 모듈러를 통해 가져온다면 <컴포넌트명> 형식으로 작성하여, 작성한 html 코드를 쉽게 재사용이 가능함
                 -> (주의!) 단! 반드시 component는 하나의 <div> 태그만을 최상위 부모로 가지고 있어야 함
                            (= 병렬의 div를 짜지 말라는 말... component는 말 그대로 jsx를 통해 작성하는 html의 최소단위라고 보면 됨)
       -> 2. 어떤 component를 구성하는 특정 html 태그의 이벤트핸들러 안에서만 통용되는 스코프를 {}를 통해서, 해당 html component가 사용자의 조작에 반응하는 반응형 componen
              -> 해당 html영역에서만 통용되는 js변수를 선언하고, component에서 선언한 js변수를 쉽게 {}안의 js변수(보통은 state)와 대입함으로서 'DOM조작 명령어 없이' 해당 c
                  : 이를 추후 서버로 부터 데이터를 받는 것 + state의 set함수를 통한 변경시 조건부 랜더링이라는 특성과 props를 통해 이를 타 compoenent에 전달하는 법을 조합
       -> 3. 시멘틱 + get, set 캡슐화 구현 + 변경시 rendering 자동 수행되는 state와 다른 자식 component에 '일괄적'으로 html 속성을 넣는 형식으로 다양한 형태의 값들을 전달
              - state : 해당 페이지 안에서만 쓸 지역변수로서의 목적을 가지고 선언한 get, set 로직이 적용된 변수
              - props : '부모 component -> 자식 component'로 '일괄적'으로 html 속성을 넣는 형식으로 다양한 형태의 값들을 전달하기 위한 목적을 가지는 js객체
                        (= props의 핵심은 부모 component에서 속성을 적고, 그 값으로 부모 component의 state값을 넣어 또한 전송할 수 있다는 점에 있음!)
                           -> 누군가의 자식인 component는 component들은 'props'의 역할(일반적으로는 props라 지음)을 하는 parameter를 단 1번만 받음

  # js가 아나라 jsx(java script extention)를 쓰는 이유?
    : 순수 js만 써서하려면... 그냥 React.createRoot 함수를 짤없이 써야하는데, 이거보단 그냥 html 흉내라도 내게 하는게 더 직관적이라 jsx를 씀
       -> babel 같은 ECMA5 JS 이전 버전으로 호환성 맞추는 컴파일러를 쓰면 다 확인이 어느정도 가능함을 확인 가능

  # (주의!!) jsx(java script extention)도 엄밀하게는 js를 기반으로 함
     1. js에서 예약어로 쓰이는 단어인데, HTML component에서도 속성으로 사용하는 단어가 있는 경우는 이를 다르게 쓸수 밖에 없음을 명심해야.
        -> 그 대표적 CASE가 class로.. js에서는 class 타입을 선언할 때 사용하며, html에서는 html 요소의 속성으로 사용되기에... 그 양자는 서로 구분될수 있어야함
           ex) class -> className
     2. style 속성도 작성시 'style = { {key : 'value' , key : 'value' } }' 형식으로 작성해야 한다는 불편함이 존재함    
        -> 엄밀하게는 js지 html이 아니기에 style을 기존 html 형식으로 ""안에 통쨰로 작성하면, js 문법으로는 도저히 해석하도록 코딩하기가 어렵기에..
            -> 그래서 js 객체 형식인 {key : value}을 이용해서 style이 jsx 형식에서 코딩 가능하도록 구현
     3. style 속성의 세부 속성들 중 font-size 같이 '-'가 들어 간 녀석들은 fontSize 값이 일종의 camalCase 형식으로 바꿔야함
         -> js에서 -은 -연산자로서 작동하기 때문
           ex) <h1 style= "color : red", font-size : '16px'>  ->  <h1 style={ {color : 'red' , fontSize : '16px'} }>

 - {}문법의 포텐셜
     : 스코프{} 영역은 고립된 js 지역변수들의 영역이기에, 여기서 js변수를 선언해서 손쉽게 component 차원에서 선언된 JS변수(state, props와 연관)에 값을 대입하기만 하면,
        ->  HTML 그 어떤 요소(속성, contents 등 어디를 불문하고) 에서라도 data binding(= 내용이 자동으로 반영)됨
            -> (중요!) 최종적으로 state, props객체의 전달값 변경과 연동된 render API를 통해, DOM조작 없이 내용을 바꾸면서 자동으로 render되게 만드는 시발점이 됨

  # js 변수가 있는데, state변수나 props객체를 써야 하는 이유?
     : 1. 분명한 용도적 의미를 가지며
       2. js의 구조 분해 할당(destructuring assignment) 문법을 통해 구현한 getter setter 로직을 써서 캡슐화를 구현함
       3. (가장 핵심적인 이유!) state 변수 , props객체의 멤버변수의 값 변경 = 자동 rendering의 트리거 조건
          (= 기존 js 변수들처럼 이벤트핸들러 같은 짓으로 DOM조작 코드를 짜지 않아도, 값 변경시 이들과 연관된 html 태그만 rendering이 자동으로 실행되는 기적을 맛 볼수 있
 - state 
    : 해당 페이지 안에서만 쓸 지역변수로서의 목적을 가지고 선언한 get, set 로직이 적용된 변수 + state값의 변경이 감지시 해당 html 재rendering 
      (= 해당 component에서 값이 변경되었을때, html에 자동으로 내용이 반영되고 rendering되게하고 싶을 떄? state를 사용 ㅇㅋ) 

    # (중요) state 과거사
       : state도 원래는 props와 마찬가지로 object 속성이며, functional component 기준으로 구조분해 할당과 useState 함수를 통해 만들어진 개별 state들은 state객체의 멤버속성

    # state 사용법
       1. 변수타입 [getter함수의 별칭, setter함수의 별칭] = useState('변수가 담을 value값'); 작성
           -> 참고로 parameter로 들어갈 내용을 []을 통해 여러개 담아도 사용가능함

       2. {} 문법을 통해 conpent의 원하는 자리에 사용함

           @ getter함수의 별칭
              : 해당 state값을 조회하고 싶을때 사용하는 변수명
                 (state getter함수의 사용법) 
                   : getter함수의 별칭
                      -> state 배열을 사용했을 경우?
                          : 'getter함수의 별칭[index]'로 원하는 state요소에 접근 가능

           @ setter함수의 별칭
              : 해당 state값을 수정 + 변경된 state값을 반영한 html영역을 다시 rendering 하도록 조치하고 싶을때 사용하는 변수명
                 -> 이 setter 역할의 함수는 비동기방식(= 병렬로 다음코드를 계속 처리)으로 재rendering 처리되어서, rendering의 결과가 당장에 반영되지 않고, 화면에는 늦게 반
                 (state setter함수의 사용법) 
                   : setter함수의 별칭(state가 될 value or 연산식 or 변수명);
                      -> (중요) set함수를 쓰지 않아도, state를 바꿀수는 있지만...
                                자동 rendering의 작동 트리거는 set함수를 통해 state를 변경하는 것이기에 state에 set을 안쓰는건 react를 사용할 의미가 없다는 점과 같음을 명
                      -> (중요) state 배열을 사용했을 경우? 
                          : 'setter함수의 별칭(배열변수 or 배열 그 자체)' 와 같이 parameter로 배열이 들어가게 해야함
                              -> 이 또한 js의 구조분해 할당 문법의 원리로 작동
                                 (= '주는쪽 배열의 요소개수 != 받는 쪽 배열의 요소개수'  ->   대입이 가능한 index에 해당하는 요소들만 대입하고, 나머지 index는 관련 X)
                              1. setter함수의 별칭(배열 그 자체)를 통한 state 배열 수정
                                  : 'setter함수의 별칭[수정내용1, 수정내용2 , ... ]'로 배열 그 자체를 parameter로 투입해서 원하는 state요소를 순차적으로 일괄 변경도 가능함
                                      -> But! 이렇게 state 배열을 사용하면서 setter 또한 배열로 parameter를 줘서 사용하면.. 유지보수나 확장성이 아예 병신이 되므로 추천은 
                              2. setter함수의 별칭(배열변수)를 통한 state 배열 수정
                                  : let 배열명 = [...타 배열변수명]'로 스프레드 문법(spread syntax)을 통한 state 배열을 깊은복사를 한 뒤,
                                    배열명[index] = '원하는 value값' 과 같은 식으로 새로 선언된 배열의 원하는 index의 요소에 원하는 값을 대입하고,
                                    'setter함수의 별칭(배열명)' 과 같은 식으로 원하는데로 값이 수정된 state배열로 수정 
           
                                 ex) let [states, setStates] = useState(['내용1', '내용2', '내용3']);
                                      : 여기서 states라는 state는 state배열로 선언되었고, component에 2번째 요소인 '내용2'에 대한 부분을 담고 싶은 html 태그가 있다면?
                                          -> getter의 경우 : { states[1] }; 이런식으로 작성함
                                          -> setter의 경우 : 
                                              1. 배열 그 자체 parameter로
                                                  : { setStates(['내용1', '내용4', '내용3']); } 이런식으로 set 함수를 통해 변경 
                                              2. 깊은복사한 배열변수 parameter로 
                                                  : let copyArray = [... state]; 로 스프레드 문법(spread syntax)을 통한 state 배열을 깊은복사를 한 뒤
                                                    copyArray[1] = '내용4';
                                                    setStates(copyArray); 이런식으로 작성
 - props 
    : '부모 component -> 자식 component'로 html 속성을 넣는 형식으로, 부모 component의 {} 제한을 넘어 '일괄적'으로 다양한 형태의 값(일반문자도 가능)들을 전달하기 위한 목적
      (= props의 핵심은 부모 component에서 속성을 적고, 이를 통해 부모 component의 state값 또한 전송할 수 있다는 점에 있음!)
         -> 해당 component에서 부모 componont에서 값들을 받아 사용하고 싶고, 변경사항이 생길시 자동으로 다시 전달되어 내용이 반영되고 rendering되게하고 싶을 때? props를 사
       
    # props 사용법
      1. <자식components props속성명1 = { state명 } props속성명2 = "속명2 내용" props속성명 = {속성3 속성값} /> 형식으로 'props속성명'과 그에 해당하는 값을 { js객체명 }이
      2. 자식components의 function에 'props'에 해당하는 parameter를 적음
      3. 자식components 안에서 { props.속성명 } 형식으로 부모 component로 부터 전달받은 props 속성을 골라서 사용 
         ex) function App (){
               let [글제목, 글제목변경] = useState(['남자코트 추천', '강남 우동맛집', '파이썬독학']);
               return (
                 <div>
                   </ Modal 글제목전달={글제목}         <- 부모 component <App>에서, 자식 component <Modal>에 '글제목전달'이란 속성명에 '글제목' 이란 부모의 state값을 대입
                            color = "blue"     >      <- 부모 component <App>에서, 자식 component <Modal>에 'color'이란 속성명에 'blue'란 문자열 값을 대입해서 props객체의 
                 </div>
               )
             }
             
             function Modal(props){
               return (
                 <div className="modal" style={{ background : props.color }}>     <- 자식 component <Modal>은 부모가 전달한 props객체에서 'color'라는 멤버변수의 값을 꺼내
                   <h4>{ props.글제목[0] }</h4>                                    <- 자식 component <Modal>은 부모가 전달한 props객체에서 '글제목'이라는 부모의 state값인 
                   <p>날짜</p>
                   <p>상세내용</p>
                 </div>
               )
             }
  
    # props객체 핵심적인 특성 및 전달 방식의 장, 단점
       : props 객체는 부-자 component에서만 통용되는 일종의 지역객체 + 부모 -> 자식 편도적 전송 흐름 + 전송의 대상도 부-자 component에만 한정
          -> 단점인 노가다로 인한 개발자의 실수를 줄이고자, 일부 자주 사용되는 props로 전달되는 값을 아예 전역변수로서 관리하자는 취지의 의견 등장
              -> redux 라이브러리의 탄생
  
          @ (장점) 
             : 개발자가 생각해야 할 side effect가 적음
                1) 지역변수로서 다른 component에 영향 X 
                2) component간 값의 흐름을 예측하기 쉬움 
                3) 전송되는 값이 개발자가 적은것에 한정되어 딱 정해짐 
  
          @ (단점)
             : 값의 지속성이 일시적 + 전달 시 값의 나열도 일일히 해줘야해서 노가다가 심하기에 관리하기가 힘듦...
                1) 자신의 영역에서만 살아있는 지역변수를 계속 쓰려면 다른 component에 전달, 전달의 연속  
                2) 자주 사용되는 값일수록, 노가다를 통해 매번 개별 다른 자식 component의 속성으로 나열해서 props객체로 값을 보내야 하는 반복의 노가다를 맛봐야 함
                3) 철저히 1:1 구조의 component간 일방적 전송이라... 그 밑의 후손들에게 전달할거면 마찬가지로 2)의 노가다를 또 겪어야 함..
  
    # (중요) props 의 특성
       : 순수 react의 props객체의 전달 대상은 '부모 -> (개별) 자식' +  자동으로 더 후손 component로 전달도 X 라서... 
          -> 전달할 props객체의 멤버변수와 자식 component의 머리수가 많아지면? 그거 관리하는게 사실상 노가다에 가깝고, 개발자의 실수로 인해 많은 삽질이 발생할 소지가 있음
             (= 대부분의 component들이 쓰는 공통의 속성값의 경우, 전역객체 props를 통해 관리되어야 할 필요성 존재)
                 -> redux의 등장
  
      1. props를 통해 부모 component는 함수나 클래스 {}제한을 넘어, 사실상 다른 함수나 클래스 {}에 속한 자식 component에 값을 전달할 수 있음
      2. (중요!) 반드시 '부모 -> (개별) 자식' 으로만 일방적으로 전달됨
           -> 자식 -> 부모, 형제끼리 props객체 전송 같은건 불가능
               -> 따라서, 어떤 state를 사용하는 component그룹이 있다면, 거기서 가장 상위의 선조 component에게 state를 선언해두는게 좋음
               
      3. 각 props객체를 구성하는 멤버변수들은 개별 component만을 기준으로 일종의 지역변수 개념으로 작성됨
         (= component만 다르면 속성명 겹쳐도 상관 없음)  
  
      4. (3번의 지역변수 개념에 의거..) props객체는 개별 component 단위로 전송되며, props에 들어갈 멤버변수는 반드시 해당 자식 component에 속성형식으로 일일이 열거되어야 
         (= 자식 component가 자신의 아들 및 후손 component에 값을 보내고 싶으면, component마다 props객체의 멤버로서 전달할 속성을 일일히 기입하는 노가다를 뛰어야 함) 
            -> 그거 ㅈ같아서 몇몇 변수는 전역객체 props로 전달해서 쓰기위해 만든 라이브러리가 redux!
  
    # props 사용시 유의점
      1. 부모 component 측에서 props로 전송 가능한 속성의 갯수는 제한이 없음
      2. props 객체의 멤버변수로 들어가는 속성에 들어갈 수 있는 값의 자료형 또한 제한이 없음
         (= 부모 component의 state값 또한 전송가능한 수많은 자료형의 일부에 지나지 않음)
            -> (중요!) 심지어 함수도 전송이 가능!
  
      3. props 객체를 전송받는 자식 component는 parameter로 받는 props객체를 객체 그 자체로 1번만 받고, 거기서 필요한 멤버변수를 꺼내서 그 값을 component 구현에 사용함
          -> parameter명에 props라고 이름까지 정해져 있진 않지만, 일반적으로 props로 적음  
  
      4. 자식 component로 전달된 props객체는 값의 수정을 위한 접근이 일반적으로는 불가능함
         (= 전달된 props객체는 일종의 값들이 새겨진 앍기전용의 상수 창고로서, 값의 복사는 가능해도 수정은 불가능하다 생각하면 이해가 쉬움)
  
      5. (중요!) 하지만! props객체를 통해 전달된 setstate 함수를 통해서, 부모의 state 변수 자체를 수정하는 방식으로 부모 component의 값을 통제하는 것은 가능함!
           -> 애초에 props를 통해 부모 component의 state를 이용한 권장사항이기 때문에 당연히 잘되는게 당연함
  
      6. (중요!) 그렇지만, props객체에 유저가 수정을 위한 접근이 불가능할 뿐이지, 5번 이외의 이유로도 변동이 생기면, 재rendering이 시작되고 반영된다는 점은 명심해야 함
           -> props객체로 전달된 setState로 부모 component의 state값을 통제하여 rerendering을 유도하고, 그로 인해 props객체가 다시 값을 가져와야 할 필요로 인한 변화는 의도
              (= props객체의 전달값 중 부모의 state값에 해당되는 부분이 수정되어 변해서 다시 전달되는거 상황말고, 다른 props값에 해당하는 부모 component의 속성값이 직접 수
  
                 ex) function ParentComponent() {
                       let color = 'red';
                     
                       setTimeout(() => {
                         color = 'blue';             <- setTimeout()을 통한 props객체에 포함되는 속성값의 강제 수정을 유도하여, props객체의 변화까지 인위적으로 이끌어내는 
                       }, 1000);
                     
                       return <ChildComponent color={color} />;
                     }
                     
                     function ChildComponent(props) {
                       return <div style={{ background: props.color }}>Hello, World!</div>;        <- props.color의 값 변경으로 ChildComponent가 rerendering
                     }
  
    # 자식 -> 부모, 형제 -> 형제 끼리 component 전송이 불가능한 이유에 대한 추론?
       : 애초에 호출된 component을 react팀은 자식 component라 정의하고, 거기에 html 속성 형식으로 사용자가 적은 값들에 대해서는 부모 component가 타 component를 호출하는 것
         (= 애초에 component 호출을 통한 접점 관계를 부모 - 자식이라 명명함 + 형제관계나 자식 - 부모 관계는 그렇게 값을 전달할 방법이 로직적으로 존재하지 않음)


 - component 란?
    : react 라이브러리에서 JSX(JavaScript XML) 문법을 사용해서, 웹페이지의 상태(state)와 속성(properties)와 이벤트 핸들링을 수행하는 User Interface에서 rendering의 기본 단
       -> 쉽게 말해.. 다음과 같은 성질을 전부 가짐
           1. component는 js를 기반으로 작성된 일종의 HTML 요소로서, react에서는 rendering 기본 블록같은 단위를 의미
           2. component는 그 자체가 상태(state)와 속성(properties)을 가지고 이벤트헨들링까지 독립적(stand alone)으로 수행 가능함
           3. React.Component를 기반으로 그 자식 class로서 구체적인 component가 작성될 수도 있지만, 함수처럼 호출하면 즉시 관련 component를 return해주는 방식으로 사용도 가
           4. JSX(JavaScript XML) 문법 라는 특수 문법으로 구현
           5. component는 독립적으로 동작 가능 =  일단 만들어두면 다른 component에 가져다 붙여서 확장 가능 (= component tree 구조)
               -> 코드의 재사용성과 유지보수성을 높여줌 + 확장성이 뛰어나서, 복잡한 UI를 구현할 수 있음

           6. 다른 component에 호출된 하위 component는 호출한 component와 '부모 : 자식' 관계를 가지며, parameter를 통해 부모 component로부터 state들을 모은 js객체(= props)

    # component 사용의 주의점
       1. component는 일종의 rendering 가능한 html 요소 단위로서 1개의 component는 단 1개의 최상위 선조격 div만 가지고 있어야 함
          (= 애초에 component를 왜 쓰는지에 대한 semantic한 부분을 생각하고, 해당 component를 개발자가 왜 조각으로 만드는지 생각해야 함) 
             -> 굳이 써야 한다면? 빈 태그( <> <compoenent></compoenent> </>)로 나머지를 감싸는 fragment 문법을 쓰자

       2. component간 상태(state)는 공유 불가능이며, 부모-자식 간의 속성(properties)만 전달이 가능할 뿐임
          (= 쓸데없이 component를 쪼갰다가, 개발자 입장에서 인지 불가능한 수준으로 스파게티코드를 맛볼 수 있음)

       3. component만으로 구성된 배열을 만들수 있음
          (= 애초에 js에서 html 태그도 마찬가지로 배열로 만들 수 있음)
          ex) [<div>안녕</div>, <div>안녕</div>, <div>안녕</div>]       <- js에서 가능
              [<Modal/>, <Modal/>,  <Modal/>]                          <- jsx에서만 가능

       4. (중요) objects are not valid as a react child (found: object with keys { 문제있는 key명 }) 오류 주의!
            : react에서는 component를 rendering 하는 과정에서, 화면에 출력할 때 필요한 state나 props객체의 멤버변수가 가지고 있는 값이 '객체(object)' 자료형일 경우 renderi
               -> 문제의 핵심은 현재 rendering하라고 던져준 변수가 key : value 형식의 object라, react 상에서 뭘 화면에 띄어줘야 할지 모르는것에 있음
                  (= error 메시지가 어떤 key명이 문제의 쟁점인지 파악 후, 그런 key를 가지고 있을법한 object 객체를 가진 component가 무엇인지 찾아서, 그 객체가 자신의 value
                     ex) <h4>{ 글입력배열[i] }</h4>   ->   <h4>{ 글입력배열[i].입력값 }</h4>
                           : 글입력배열[i] 자체가 key : value를 가진 object라, 이를 문자열인 value만 가져올 수 있도록 '배열.key명' 문법으로 객체의 멤버변수를 지정함

    # component는 언제 쓸까?
       1. 반복적으로 잘 쓰이는 html요소
       2. 값이 자주 변경되어, state와 props가 필히 필요해서 관리해줘야 하는 html 요소들
          (= 너무 component를 잘게 쪼게면, 관리 단위로서 component가 의미가 없으며, state관리가 더 복잡해짐)
       3. 페이지가 큰 html 요소 

    # (중요) component의 Lifecycle (생명주기)
        : react의 화면 구성의 기초가 되는 component는 크게 'mount(생성) - update(vdom의 rerendering을 통한 부분적 변경) - unmount(삭제)'의 3단계의 상태에 해당하는 시기를 거친다는 것을 의미하는 용어
          (= 정확히는 component는 mount와 unmount 2가지 상태를 지니는데, component를 갱신하는 update = 'mount(생성) - unmount(삭제) - mount(생성)의 과정을 따르는 것과 같음을 기억하자')
              -> (중요) 해당개념이 중요한 이유
                   : component의 관련 기능을 구현하는 과정에서 lifecycle의 개념을 사용하는 'lifecycle 메서드'가 이와 연관되어 있으며, 그 중 어떤 내용을 component의 rendering 후가 되거나 제거 전에 수행하라는 코드를 삽입하는 'lifecycle hook'을 사용할 수 있기 때문
                     (= lifecycle hook의 존재는 개발자가 확실히 특정 코드의 실행 시기를 사실상 완벽하게 통제할 수 있음을 의미함)
                         -> (중요!) rendering 완료 전, 후라는 시점은 별거 아닌거 같아도, 어떤 요소나 데이터가 로딩이 되지 않아 에러가 나거나, 성능이 쓸데없이 낮아지게 되는 원인이 된다는점에서 아주 중요함!
    

    # (중요) component의 lifecycle method와 lifecycle hook

        1) lifecycle method
           : class component에서 lifecycle을 기준으로, 상태 관리와 lifecycle 관리 및 부수 효과 처리(side effect 처리) 등 다양한 리액트 기능들을 사용할 수 있게하는 위한 함수들의 집합

             ex) setState() : 상태관리 멤버함수
                 componentDidMount() :
                 componentDidUpdate() : lifeCycle 상태를 트리거 삼아 호출되는 멤버함수
                 componentWillUnmount() : 
                 shouldComponentUpdate() : 리렌더링을 진행할지 여부를 결정함수

        2) lifecycle hook  
            : class component의 lifeCycle의 특정 시점에 실행되는 멤버함수 componentDidMount, componentDidUpdate, componentWillUnmount 통칭하는 함수집합
               -> hook의 의미는 일종의 이벤트헨들러와 연쇄되는 이벤트 내용처럼, component의 Lifecycle의 상태변화를 트리거 삼아 같이 실행되도록 갈고리를 건다는 의미를 가지고 붙여진 이름
                  (= 쉽게 말해, componentDidMount, componentDidUpdate, componentWillUnmount의 안에 적힌 내용들은 lifeCycle 상태에 따라 해당 함수들이 실행되면, 실행되게 설정된 코드들)
                 

              @ class component 시절 Lifecycle hook 관련 코드 구현
                 : componentDidMount(), componentDidUpdate(), componentWillUnmount()라는 class component의 멤버함수를 통해 해당 함수 스코프에 원하는 내용을 집어넣어서 사용
                    -> (중요!) Mount, Update는 rendering 후가 실행 시점의 기준 <-> Unmount는 component 해제 전이 실행 시점의 기준임을 명심해야 함

                   ex) class Detail2 extends React.Component {   
                           componentDidMount(){ Detail2 component 생성시 이 안의 코드가 실행 }                 <- component는 등장 후에 이것좀 해줘
                           componentDidUpdate(){ Detail2 component가 rerendering 될 시 이 안의 코드가 실행 }   <- component는 업데이트 되고나서 이것좀 해줘
                           componentWillUnmount(){ Detail2 component가 삭제 될 시 이 안의 코드가 실행 }         <- component는 '사라지기 전'에 이것좀 해줘
                       }

              @ function component에서 Lifecycle 관련 코드를 사용가능하게 된 시기의 구현
                 : function component의 기능을 강화하는 react hooks 중 하나인 useEffect() 함수를 통해 구현함
                    -> useEffect()
                        : lifecycle hook계열의 함수 기능을 function component 구조에서도 쓸 수 있게 하는 react hooks 함수
                           -> 기능 구현 자체는 lifeCycle hook처럼 lifeCycle 시점에 매핑되는 함수를 만들지 않고..
                              useEffect() 함수의 parameter나 내용을 통해, 내용 작동의 '시점'과 '반응할 state변수'를 설정함으로서 유저가 원하는 lifeCycle hook의 내용을 세밀하게 작성할 수 있게 해둠
                              (= 실행 시점을 세세하게 나눌수 있다는 점이 서비스의 성능과 체감에 영향을 줄 수 있음)

                              ex) useEffect( () => {

                                   (함수 내부 구조1) component rendering 시 실행되는 코드 (필수)
                                   ---------------------------------------------------------------------------------------------------
                                    해당 부분의 코드는 component의 rendering과 연관된 lifeCycle인 'mount(생성)', 'update(rerendering 변경)'와 연관되어, lifecycle hook 함수 componentdidmount(), componentDidUpdate()과 연관됨
                                    (= 해당 component가 mount(생성), update(rerendering으로 인한 수정)시, html rendering이 완료되고 나서! 해당 무명 함수의 내용이 실행됨)
                                       -> rendering이 끝나고 실행된다는 건, 주로 어렵고 복잡한 연산을 수행하거나, 서버에서 데이터를 가져오는 등 수행 시간이 오래걸리거나, 모든게 로딩과 rendering이 끝나고 가장 나중에 처리되어야 할 내용을 useEffect()에서 짬처리를 하게 됨을 의미
                                          (= 함수명을 핵심기능이 아닌 부가기능이라 중요성이 떨어지는 것을 의미하는 side effect에서 따왔음을 짐작가능한 이유를 알 수 있음)

                                       -> 정확히는 아래의 내부구조3에 [state 배열]을 어떻게 적었냐에 따라서, 어떤 state변수의 변경에만 componentDidUpdate()의 구현 타이밍을 통제할 수 있음
                                          (= component 생성 후에 실행되는 componentdidmount()는 무조건 실행됨)
                                   ---------------------------------------------------------------------------------------------------
     
                                   
                                   (함수 내부 구조2) clean up function 영역 = 존재하는 component를 해제(및 새로 갱신)하기 전에 실행되는 코드 (필수 X)
                                   ---------------------------------------------------------------------------------------------------
                                   return () => {

                                    clean up function 내부의 코드는 lifeCycle 중 이미 존재하는 component의 'unmount(삭제)'와 연관되어, lifecycle hook 함수 componentWillUnmount()과 연관됨
                                      -> 정확히는 아래의 내부구조3에 [state 배열]을 어떻게 적었냐에 따라서, state변경에 따른 'update(rerendering 변경)' 상황이 벌어지기 전에도 해당 코드의 작동 여부를 통제할 수 있음
                                         (= 뭔 수를 쓰더라도 완전한 component 해제 전에 실행되는 componentWillUnmount()는 무조건 실행됨...)
                                             -> [] 부분을 아예 배제하거나, [state 배열]을 적으면, 완전한 component 해제가 아닌 component update(갱신) 상황에서도 해당 코드는 작동함
                                                (= component update(갱신)과정에도 component unmount(해제)가 엄밀하게는 포함되기 때문 )

                                      -> clean up function 내부 내용은 보통 수행한 작업들을 정리하고 리소스를 해제하는 불필요한 리소스 사용을 방지하고 메모리 관리에 활용함
                                          ex) timer 제거, socket 연결요청제거, ajax요청 중단 (서버 db에 데이터 요청 중단)

                                      -> clean up function이 update(갱신)와 연관이 되는 이유?
                                          : component의 update(갱신) 상태라는건 component가 다시 rendering 될 때, 기존에 존재하는 component는 unmount(해제)시키고, 갱신된 component를 다시 mount시키는 개념이기 때문

                                   } 
                                   ---------------------------------------------------------------------------------------------------
     
                                  }
     
                                  (함수 내부 구조3) 해당 useEffect()에 유효한 state 변수배열 적기 (필수 X)
                                  ----------------------------------------------------------------------------------------------------
                                  , []   <- (중요!) state 변수를 배열요소로 적음 = 해당 useEffect() 함수는 여기 적힌 state 변수의 변경에만 작동함
                                              -> 해당 parameter는 필수적으로 적는 부분은 아님 

                                                  - []를 비움
                                                     : 모든 state의 변화에 반응하지 않음
                                                       (= mount와 unmount에 1번씩만 useEffect()함수를 작동시킴)
    
                                                  - []부분을 쓰지 않음
                                                     : 모든 state의 변화에 반응함

                                                  - []안에 state변수들을 적음
                                                     : 해당하는 state변수들의 변화에만 useEffect() 함수는 반응하여 작동함
                                                       (= state 변수가 많아지면 개발자의 대갈통이 깨질 수 있음)
                                  ----------------------------------------------------------------------------------------------------
                                  )  


                                 [case1] 만약 useEffect 안의 내용에 대해 'mount(생성)' 후에만 실행을 원한다면?
                                   : useEffect( () => {내용}, [] )
                                      -> 어떤 state가 변화해서 rerendering이 되던 말던, 해당코드를 실행하지 않는다는 것을 의미
                                         (= 최초 1회 component를 mount(생성)할때면 useEffect()의 내용을 실행해라)
                                 
                                 [case2] 만약 useEffect 안의 내용에 대해 update(rerendering으로 인한 수정)를 하더라도 특정 state의 변화에만 변경되게 만들고 싶다면?
                                   : useEffect( () => {내용}, [state변수에 대한 배열요소] )
                                      -> 배열 안에 존재하는 state 요소들의 경우만 변화하여 rerendering이 되는 경우만, 해당코드를 실행하게 함
                                         (= 조건부 componentdidupdate() 실행과 같음)
                                 
                                 [case3] 근데 useEffect() 쓰는데, 만약 무조건 component update(갱신) 전에 실행하고 싶은 코드가 있다면 어떻게 함?
                                   :  useEffect( () => { 내용에 'return () => {내용}' })
                                       -> component의 update로 인한 rerendering 직전이나, component의 unmount시 해당 코드가 실행됨
                                          (정확히는 'return () => {내용}' 부분에 해당하는 부분이 unmount와 연관된 부분으로, 과거 class component 시절 lifecycle hook 계열 함수 중 
                                 
                                 [case4] 그럼 useEffect() 쓰는데, 만약 useEffect() unmount 전에만 실행하고 싶은 코드가 있으면?
                                   : useEffect( () => {return () => {내용} }, [] )
                                     (= 사실상의 componentWillUnmount() 함수 부분을 대체 구현)
                                       -> 비워둔 []   : state 변화에 대해 해당 useEffect()는 작동 X
                                       -> return 코드 : useEffect 본 내용 실행전에 해당 코드 실행
                                 
                                 [case5] 그럼 useEffect() 쓰는데, 특정 component update(갱신) 전에 실행하고 싶은 코드가 있다면 어떻게 함?
                                   : useEffect( () => {return () => {내용} }, [state변수에 대한 배열요소] )
                                     (= 'return 코드를 어떤 state변화에도 반응하지 말라'는 내용의 명령어로 unmount시에만 실행되는 코드를 구현할 수 있음)
                                       -> [state변수에 대한 배열요소]   : 해당 state 변화에 대해서만, 해당 useEffect()는 작동함
                                       -> return 코드                  : useEffect 본 내용 실행전에 해당 코드 실행


 - (중요) class component
    : 원래 react의 component를 작성할때는 객체지향관점에서 class 자료형으로 component를 작성하고 이를 객체화하여 호출함
      (= React class의 Component라는 class를 상속받음)

    # class component가 도태 된 이유?
       : 더 쓰기 편하면서, 직관적이면서, 코드량도 적은 functional component가 class component가 할수 있는 모든 기능을 가지고 있기 때문
         -> 정확히는 16.8에서 functional component도 state나 여러기능을 쉽게 사용하게 하는 react hook의 등장으로 functional 방식으로 코딩하는게 유리해졌기에 class componen

    # class component를 통해 유추가능한 중대한 사실들
       1) (중요) props도 객체지만, state도 원래는 객체
          (= functional component에서 구조분해할당 문법을 통해 생성해 준 개별 state명들은 사실 state객체의 객체 안의 1개의 멤버변수)
             -> 그래서, functional component에서 만든 state에서 hooks문법인 usestate() 안에 제대로 된 자료형을 안 넣으면, 자동으로 그 state는 object 형식으로 지정되는 것..

       2) setState 함수는 개별적으로 존재하며, 그 목표는 state라는 객체 자신의 멤버변수를 변경하는 것이기에, '멤버명 : 값' 형식으로 parameter를 지정함
          (= functional component에서 구조분해할당 문법을 통해 생성해 준 개별 setState함수들은 사실 일종의 alias(별칭)으로서, 'setState(지정 state멤버변수)'와 비슷하게 치

       3) 조상인 Component class의 render 함수를 해당 component에 맞춰 override함
          (= Component render 기능의 인터페이스화는 이미 class component 시절부터 시작된 전통임)
              -> render 함수는 해당 html DOM요소를 브라우저에서 쉽게 랜더링이 가능하도록 react 차원에서 jsx형식을 우리가 아는 그 형식으로 푸는 함수로 interface화 되어있음
 

 - (종합) react를 통해 동적인 UI를 만들려면?
  1. class나 function component를 만들어서 html 구조를 만들고, 거기에 맞는 css로 디자인을 확정함

  2. 해당 component UI의 상태를 제어할 flag 변수의 역할을 하는 state선언를 선언함

  3. component 내에서 3항 조건문을 활용하여, 앞서 선언한 flag state에 따라 해당 component를 어떻게 보일지를 작성함
      -> 해당 조건문의 작동의 key가 되는 state변경을 위해서는, react의 이벤트핸들러 속성 + {}를 통해 앞서 선언한 state변수들에 접근하여 이를 조작함

  # (중요) JSX에서 조건문이 필요하다면?
     : 반드시! 3항 연산자를 통한 true와 false문을 통한 패턴화로 해결하면 됨
        -> (주의) 조건식에는 state값도 당연히 사용이 가능함 + null을 사용하면 그 자리에 아무것도 출력하지 않을수 있음
        
  # (중요) JSX에서 반복문이 필요하다면?
     : js 지역 스코프 {}에 js 배열(state배열도 포함)객체의 멤버함수 map()을 이용하고, 배열 안에 component를 담도록 하자 
       (= for 문법은 JSX 안에서 사용할 수 없음)
         -> (참고) map 반복문으로 반복생성한 html 요소들에는 이렇게 반복 생성된 요소들을 구분하기 위한 key 속성을 추가해야 warning이 뜨지 않음 

            ex1) function App (){
                   return (
                     <div>
                       { 
                         글제목.map(function(a){                 <- 첫번째 parameter a = 해당 index순번의 배열요소
                           return (
                           <div className="list" key={i}>
                             <h4>{ a }</h4>
                             <p>2월 18일 발행</p>
                           </div> )
                         }) 
                       }
                     </div>
                   )
                 }

            ex2) function App (){
                   return (
                     <div>
                       { 
                         글제목.map(function(a, i){              <- 두번째 parameter i = 해당 index의 값 그 자체
                           return (
                           <div className="list" key={i}>
                             <h4>{ 글제목[i] }</h4>
                             <p>2월 18일 발행</p>
                           </div> )
                         }) 
                       }
                     </div>
                   )
                 }

  # 만약 반복되는 html요소를 구현하는데 for문이 굳이 쓰고 싶다면?
     : component의 return 부분은 jsx 부분이므로, 그 윗 라인 영역인 js 영역에서 for문을 사용하여, 배열 안에 html요소를 대입한 후 이를 jsx의 conponent return 영역에서 호출

       ex) function App (){
             var 어레이 = [];
             for (var i = 0; i < 3; i++) {
               어레이.push(<div>안녕</div>)         <- 이런식으로 배열에 html요소를 대입
             }
             return (
               <div>
                 { 어레이 }
               </div>
             )
           }


 - react 사전이해에 필요한 JS지식
  @ 구조 분해 할당(destructuring assignment)?
     : ECMA6에서 새로 공개된 배열 또는 객체의 속성을 쉽게 추출하여 개별 단일 변수에 할당하는 방법으로.. 
       -> 배열이나 객체의 요소를 일일히 접근하여 변수에 할당하는 대신, 구조 분해 할당을 사용하여 한 번에 여러 변수에 값을 할당 가능 + []와 {}의 차이만 있을 뿐, 문법이 서
           -> 해당 컴포넌트의 지역변수 역할을 하는 state에 get, set 로직을 구현하는데 사용됨
       ex) 배열 구조 분해 할당
           const numbers = [1, 2, 3, 4, 5];
           const [a, b, ...rest] = numbers;         <- numbers의 배열요소의 값들을 각 개별변수에 일괄적으로 대입 가능
           const [e, f] = numbers;                  <- (중요) 값을 제공하는 배열 numbers의 요소의 개수 > 값을 받는 배열의 개수?
                                                         : 이 경우는 1, 2만 e, f에 대입
           console.log(a);    // 1
           console.log(b);    // 2
           console.log(rest); // [3, 4, 5]
           console.log(e);    // 1
           console.log(f);    // 2
        ex) 객체 구조 분해 할당
           const person = { name: 'John', age: 30, city: 'New York' };
           const { name, age, city } = person;      <- 객체 person의 멤버변수 값들을 각 개별변수에 일괄적으로 대입 가능
           console.log(name); // 'John'
           console.log(age);  // 30
           console.log(city); // 'New York'

  @ 스프레드 문법(spread syntax)
     : '...배열명 or 객체명'을 통해, 배열(array)이나 객체(object)에 존재하는 각 요소 또는 멤버변수들을 해당 컨테이너명을 사용하여 개별적인 값으로 쉽게 확장하는 작성하는 
        (= 이걸 쓰면 귀찮게 배열, 객체의 각 모든 요소들을 일일히 기입하지 않아도 되며, 함수의 선언부에 parameter의 갯수에 따른 오버로딩 또한 노가다 없이 rest parameter형
            -> 다시 말해 배열, 객체의 깊은 복사가 쉬워짐
               ex) const numbers = [1, 2, 3];
                   const copiedNumbers = [...numbers];
                   console.log(copiedNumbers); // [1, 2, 3]
                   const person = { name: 'John', age: 30 };
                   const copiedPerson = { ...person };
                   console.log(copiedPerson); // { name: 'John', age: 30 }

  @ html 이벤트핸들러 속성
    : js의 이벤트핸들러를 html에서 사용가능하게 속성으로 구현한 것.. 속성값으로는 행동 function명이나, 익명함수로 원하는 로직을 입력함녀 됨. onClick이 대표적

  @ 일급 객체 function
    : js의 function이란 변수에 대입이 가능하며, 다른 함수의 return으로 가능한 대상이자, 다른 함수의 parameter로도 사용이 가능함
      (= 특정 변수에 익명함수를 입력해서 저장시키거나, 다른 함수를 대입하는 것도 가능하며, callback 함수를 사용가능한 근원이 되는 js의 특성임)

  @ array/object를 다룰 때의 주의사항
    1. 배열명 / 객체명 그들 자신 자체는 reference 타입의 변수
       (= 배열요소 / 객체맴버변수 데이터를 보존하는게 아니라, 해당 배열이나 객체가 어떤 메모리 주소에 위치해 있는지에 대한 위치값(= 포인터)을 가지고 있음)
           -> 그래서, 'let 변수명 = 배열/객체명;' 과 같은 식의 코드는 의도대로 배열이나 객체의 값이 변수명에 복사되지 않고, 배열/객체명의 메모리 주소를 대입하는 '얕은 복
 
    2. 배열 / 객체는 다룰 때 원본을 보존하는 것이 좋기에, 완전히 다른 메모리주소를 할당한 후 값을 할당하는 '깊은 복사'를 쓰는게 좋음    
 
  @ 3항 연산자(ternary operator)
    : '조건식 ? true일시의 실행 : false일시의 실행' 형식으로 작성하는 조건문... 
        -> 이를 사용하면, if else if else 범벅보다, 1줄로 간편하면서도 때때로 직관적인 코드를 짤 수 있음
  
  @ 논리 부정 연산자 !
     : true, false의 각자 반대값을 출력하도록 함
 
  @ 배열object의 멤버함수 map
     1. [요소1, 요소2, ... , 요소n].map( function() { 내용 } )
         : 해당 배열 요소들의 개수만큼, 내부 무명함수의 내용을 반복해 줌

     2. [요소1, 요소2, ... , 요소n].map( function() { return '내용' )
         : 해당 배열 요소들의 개수만큼, 해당 횟차만큼의 index 위치에 있는 배열요소에 return에 존재하는 '내용'을 기입

           ex) [1,2,3].map(function(){
                 return 123           <- 123을 배열의 index마다 반복해서 기입 [123, 123, 123]
               });
 
     3. [요소1, 요소2, ... , 요소n].map( function(변수a) { 내용(변수a를 사용) } )
         : 해당 배열 요소들의 개수만큼, 내부 무명함수의 내용을 반복하되, 변수a에 해당하는 부분은 해당 횟차만큼의 index 위치에 있는 배열요소를 사용함

           ex) [1,2,3].map(function(a){
                 console.log(a);          <- 1, 2, 3을 log에 순차적으로 출력
               });

     4. [요소1, 요소2, ... , 요소n].map( function(변수a) { return (변수a를 사용) } )
         : 해당 배열 요소들의 개수만큼, 내부 무명함수의 내용을 반복하되, return에 해당하는 부분도 변수a에 해당하는 부분은 해당 횟차만큼의 index 위치에 있는 배열요소를 사

           ex) [1,2,3].map(function(a){
                 return a*100            <- 각 배열의 index에 위치한 요소 * 100에 해당하는 값을 배열의 각 index에 반복해서 기입 [100, 200, 300]
               });

     5. [요소1, 요소2, ... , 요소n].map( function(변수a, 변수i) { 내용(변수a와 i를 사용) } )
         : 해당 배열 요소들의 개수만큼, 내부 무명함수의 내용을 반복하되, 변수a에 해당하는 부분은 해당 횟차만큼의 index 위치에 있는 배열요소를 사용 + 변수i는 해당 index에
 
           ex) [1,2,3].map(function(a, i){
                 return a*i              <- 각 배열의 index에 위치한 요소 * 각 index의 값에 해당하는 값을 각 index에 반복해서 기입 [1, 4, 9]
               });

  @ HTML 이벤트핸들러 속성
     : HTML에는 자체적인 명세서에 동적인 웹페이지를 구성하도록 하기 위한, js의 자주 쓰이는 이벤트핸들러들을 DOM 속성 형식으로 쉽게 쓸 수 있기 지원함
        -> 이벤트핸들러가 전역변수로 노출 + 복수 이벤트핸들러를 설정하는 문법이 X + 사용자 정의 이벤트를 설정 불가능.. 이 3콤보로 요즘은 사장..
            -> 그렇지만 react에서는 이러한 형식의 친숙함을 차용하여, react방식의 매커니즘에서도 dom조작 없이 state의 변경을 통한 이벤트를 구현하였음
                -> 단! 이미 html DOM기반 이벤트핸들러는 존재하기에, 기존에 존재한 이벤트핸드러 속성을 'camalCase' 형식으로 표기하여 동일한 속성을 피함
                    -> 물론! 그렇다고, onClick으로 구현한 react의 유사 이벤트핸들러의 구현이 onclick과 절대 같지는 않음
                       (= 아마, 형식만 html DOM기반 이벤트핸들러 형식으로 작성된 react 이벤트 속성이 감지되면, 내부적으로 구현되는 로직이 존재할듯)

  @ 이벤트 객체 e
     : 이벤트핸들러에 들어가는 함수에 넣는 parameter로, 이는 객체로서 현재 발생하는 이벤트와 관련한 유용한 기능들을 제공하는 일종의 변수로 생각하면 됨
        - e.target            : 현재 이벤트가 발생한 곳을 알려줌
        - e.target.value      : 현재 이벤트가 발생한 곳의 값을 출력함
        - e.preventDefault()  : 해당 이벤트의 기본 동작을 막아줌
        - e.stopPropagation() : 가장 최상단의 조상 HTML DOM요소부터 해당 HTML DOM요소에 접근하는 호출 stack을 구성해 위치를 찾은 후, stack을 해제하는 과정에서 접근하게 

  @ 이벤트버블링
     : 어떤 HTML 요소에 이벤트가 발생하여 이벤트핸들러가 동작하고, 이어서 부모 요소부터 가장 최상단의 조상 요소에 이르기까지 같은 종류의 이벤트핸들러가 동작하는 개념을 
        -> HTML 요소 접근을 위한 stack 회수 과정에서 구현하였기에, 편도행에는 문제가 생기게 하지 않을 수 있다고 생각함
           (= e.stopPropagation()을 통해, 본 이벤트 발생 이후의 다른 HTML DOM요소들의 이벤트의 통제 또한 가능함)

  @ object(객체) 타입
     : js의 자료형 중 하나로 '속성 : 속성값 = key : value'구조를 가지는 멤버들이 여러개로 구성되어 있는 일종의 구조체(construct) 같은 자료형
        -> let 객체명 = {속성1 : 속성값, ... , 속성n : 속성값n} 형식으로 작성
      # (주의) react에서는 render할 component에 있는 출력값이 object 타입이면, 에러를 뿜으니... 유의하도록 하자 

  @ js 모듈러 시스템
     : HTML의 script 태그에서 다른 스크립트 파일들을 src속성을 통해 불러올 때, 해당 script 코드들이 1개의 단일영역에 적혀있는 것처럼 작동하는 것을 막고, js 모듈을 기준으
         -> 다시 말해, Class 내 변수를 쓰려고 할 때 이들을 불러오는 문법이 있듯, 모듈 내의 변수들을 구분해서 불러오는 구문이 따로 필요하다는 것 의미
             -> 이렇게 js의 모듈을 불러오는 방식을 '모듈 시스템(module system)'으로 명칭함

      # 블럭 스코프'(block scope)
        : js(es6 이후로 추정)에서 지역변수적 요소를 구현하고자 쓰는 결계로 그 안에 쓰는 변수 let 혹은 const는 그 안에서만 통용되는 지역변수처럼 적용됨
           -> {}를 통해 결계를 치고, 그 안에 쓴 변수 let 혹은 const는 그 안에서만 통용되는 지역변수화가 됨 (반대로, 안에서는 전역변수들을 만나는게 가능한 함수에서의 {}와
              (단! var는 그런거 적용 안 되니 쓰지 않도록 한다)

      # 자주 사용되는 2가지의 모듈 시스템
         1. ES Module (사실상의 승자)
             : JS ES6(ES2015)에 도입된 자바스크립트 자체의 모듈 시스템 방식 (과거 제작된 react에서 많이 보이는 녀석)
                -> (중요) NodeJS 13.2부터 ES모듈 시스템에 대한 정식 지원이 시작 = node.js에서도 babel같은거 없이 사용 가능 
                      -> package.json에서 type = "module" 선언화면 바로 사용 가능하게 조치 
                         (= package.json와 연관있는 react 또한 이를 사용함을 유추 가능...)
                             ->  정확히는 함수 component를 쓸 때, 해당 기능을 강화시키는 hooks 모듈을 불러올 때 사용)

              - ES Module 사용법
                : (from 사용할 모듈) export 구문을 입력 -> (to 가져오는 파일) import구문을 통해 불러옴

                1) ES Module 내보내기 : export 구문

                    a. export default 내보내고 싶은 변수명;
                        : import시 특별한 변수명을 적지 않으면(= 보통 import a구문 사용시), 이 때 지명한 변수를 가져옴
                          (단! 한번 사용 가능함.. 기본으로 출력할 변수를 부르기 때문)

                    b. export default { 내보내고 싶은 변수명(여러개도 가능) };
                        : import시 특별한 변수명을 적지 않으면(= 보통 import a구문 사용시), 이 때 지명한 변수들을 가져옴
                          (a와 마찬가지로 한번 사용 가능함.. 기본으로 출력할 변수를 부르기 때문)

                    c. export let(const) 내보내고 싶은 변수명;
                        : 이를 통해 여러개의 변수들을 직관적으로 지명 가능
                            -> 그나마 가장 범용성이 좋은 방법 

                2) ES Module 불러오기 : import 구문

                    a. import 지은 변수명 from '불러오는 모듈 경로'
                        : 모듈에서 변수 하나만 가져오는 방법  
                            -> export defalut {여려변수들} 을 사용한다면, b구문처럼 '지은 변수명'을 객체명처럼 사용 가능 

                    b. import * as 지은 변수명 from '불러오는 모듈 경로';
                        : 모듈에서 모든 변수를 가져오는 방법 
                          (*의 의미 : SQL에서 모든 변수 가져오는것 의미.. -> 이걸 '지은 변수명'으로 통칭해 객체명화 하는 것)
                            -> '별칭.프로퍼티' or '별칭.메서드명(파라미터....)'' 를 통해 값을 지칭해서 불러옴

                    c. import { 가져올 변수명(여러개도 가능) } from '불러오는 모듈 경로';
                        : 모듈에서 1개 ~ 여러개 변수를 가져오는 방법
                            -> 그나마 가장 범용성이 좋은 방법 

         2. CommonJs
             : NodeJS 환경에서 자바스크립트 모듈을 사용하기 위해 만들어진 모듈 시스템 
                -> 일부 내용은 ES Module과 기능상 호환되는 부분이 존재함

              - CommonJs 사용법
                 : (from 사용할 모듈) 사용할 변수 앞에 export.변수명 입력 or module.export { } 구문 입력- > (to 가져오는 파일) require('파일경로'); 구문을 통해 불러옴

                 1) CommonJs 모듈 내보내기 : export.변수명 및 module.export 구문

                     a. export.내보내고 싶은 변수명;
                         : 내보내고 싶은 js 변수 앞에 'export.' 를 일일히 붙여서 모듈의 변수로서 블록 스코프에 넣는 것으로 판정 

                     b. module.export { 내보내고 싶은 변수명(여러개도 가능) };
                         : 이를 통해 여러개의 변수들을 직관적으로 지명 가능
                             -> 그나마 가장 범용성이 좋은 방법 

                 2) CommonJs 모듈 불러오기 : require 구문

                     a. let or const { 불러오고 싶은 변수명(여러개도 가능) } = require('파일경로');
                         : 모듈에서 1개 ~ 여러개 변수를 가져오는 방법
                             -> 그나마 가장 범용성이 좋은 방법 

                     b. let or const 지은 변수명(= 별칭) = require('파일경로');
                         : 모듈에서 모든 변수를 '지은 변수명'으로 통칭해 객체명화 하여 가져오는 방법 
                             -> '별칭.프로퍼티' or '별칭.메서드명(파라미터....)'' 를 통해 값을 지칭해서 불러옴  


  @ (중요) Concurrency(동시성) & Parallelism(병렬성)
     : 여러가지의 프로그래밍 작업의 동시 수행에 대한 프로그래밍 개념으로... 논리적 vs 물리적인 관점으로 구분된 용어
        -> 각각 '비동기 작업처리', '병렬 작업처리'의 개념과 직결되는 관련성이 있는 용어로 제대로 모르면, 두 처리방식의 차이점을 알수 없음
           (= 이 두가지 방식은 시스템을 구성할 때 양립불가능한 요소가 아니라는 점 명심)

       1. Concurrency(동시성) => (중요) [비동기 작업 처리]와 연관
           : 여러가지의 프로그래밍 작업을 동시에 수행하는 것에 대한 논리적인 개념
              -> 비동기적으로 빠르게 프로세스 및 컨텍스트들을 전환하며 여러 작업을 수행하면? 거의 동시에 여러 작업이 실행되는 것으로 보여짐
                 (= 사실 비동기 작업처리는 운영체제의 복잡 정교한 스케줄링 정책에 의해 실행되는 방식으로, 물리적으로 동시적 프로그래밍 작업을 수행하진 않기에 논리적인 동시적 작업을 충족하여 Concurrency한 task로 인정)

                 ex) 프로세서의 프로세스 스케쥴링(process scheduleing), 쓰레드의 컨텍스트 스위치(context switch)
                     
       2. Parallelism(병렬성) => (중요) [병렬 작업 처리]와 연관
           : 여러가지의 프로그래밍 작업을 동시에 수행하는 것에 대한 물리적인 개념
              -> 실제로도 완벽하게 동시에 프로그래밍 작업이 수행하는 경우에만 한정함

                 ex) 멀티 CPU코어(Multi-Processor), 멀티 쓰레드(Multi-thread)를 통한 다중 프로세싱 (Multiprocessing), 다중 쓰레딩 (Multithreading)


      # 컨택스트(context)                     vs          쓰레드(thread)
        - 동시성(concurrency) 관여                        - 병렬성(Parallelism) 관여 + 동시성(concurrency)도 부분적 강화
        - 비동기적 작업 처리                               - 멀티 쓰레드(multi thread)를 통한 병렬 처리
        - 실행 중 프로세스, 스레드의 상태 정보              - 프로세스 내에서 실행되는 독립적인 실행 단위


      # 동기화 문제
         : Concurrency(동시성) & Parallelism(병렬성)한 task에서나 둘 다 동시기에 공유된 자원에 경쟁적으로 접근(race condition)하게 되었을떄, 작업 과정 자체가 매번 달라지고 작업 결과의 신뢰성에 문제가 발생
            -> 세부적 분류
               1) 어떻게 프로세스 간 공유 자원(프린터,통신망 등)을 배타적(한 순간에 1개의 프로세스 만 사용)으로 사용하게 할거냐?
                  (= 어떻게 화장실에 1명만 들어가게 할거냐?)
                    -> 공유변수구역 or 임계구역(critical section) 의 상호배제(mutual exclusion) 문제 
                     
               2) 혹시라도 두 프로세스가 서로 다음 작업이 서로 점유중인 공유변수구역을 필요로 해서, 병행 프로세스의 다음 작업 자체가 진행이 안된다면 어쩔거냐?
                  (= 혹시라도 1명만 들어가야 하는 샤워실, 화장실에 들어간 사람들이 다음에 들어갈 곳이 서로가 있는 곳일떄는 어떻게 위치 교환을 하게 할거냐?)
                    -> 교착상태 (Deadlock) 문제

               3) 그렇다면 어떤 식으로 다수의 프로세스들에게 명령을 전달하여 1), 2)의 문제를 피하고자 할거냐?
                  (= 사람들을 어떤식으로 통제해서, 화장실을 질서정연하게 이용하게 할거냐?)
                    -> 자료 교환을 위한 메세지 전달 방식 상의 통신 (Communication) 문제

               4) 실행 과정이 약간 변동이 생겨도 작업 결과의 신뢰성은 보증 가능하냐?
                  (= 화장실 가는 순서가 약간 변동이 생겨도, 결국 미래는 비슷하게 흘러갈거냐?)
                    -> 실행순서와 관계없이 항상 같은 결과를 얻어야하는 결정성 (Determinacy) 문제


      # 'Concurrency(동시성) : Parallelism(병렬성) = 비동기 처리 : 병렬 처리'의 CS의 역사
         1. 싱글 프로세서 시스템 (Single-Processor Systems)
            : 초기 컴퓨터는 싱글 프로세서(Single-Processor) + 1개의 프로세스(process)만이 실행이 가능함
               -> 시스템의 최소 실행단위는 프로세스(process)이며, 1개의 프로세스만 실행이 가능
                  (= 코드 작업을 순차적으로 1요청에는 1응답이 되기까지 다음을 작업을 진행하지 않는 '동기적 프로그래밍' 방식을 사용)

            - 용어 사전
               1) 프로세스
                   : 현재 컴퓨터에서 메모리에 instance로서 객체화 되어 올라가 실행중인 프로그램를 통칭하는 용어
                      -> 과거에는 컴퓨터에 여러개의 프로그램을 실행한다는 개념이 없는 '프로세스 기반의 시스템'이 주류
                         (= 당연히 비동기 작업처리라는 개념이 없었음)

               2) 프로세서(= CPU)
                  : 프로세스를 실제로 수행하는 주체를 의미하는 장치로 일명 중앙처리장치.. 
                     -> 단일 프로세서(Single-Processor) = 1코어 cpu
                     -> 다수 프로세서(Multi-Processor)  = 멀티코어 cpu
                         : (IF) 프로세서의 수가 많으면?
                             -> 다중 프로세싱 (Multi processing) 가능
                                 : 여러 개의 프로세서가 동시에 다양한 작업을 처리하는 기술, 각 프로세서는 독립적인 실행 단위인 프로세스를 처리
                                   (= 물리적으로 병행 프로세스를 수행하는 병렬 처리의 효율이 늘어남)
   
                             -> 다중 쓰레딩 (Multithreading) 가능
                                 : 멀티코어를 멀티쓰레드로 사용하게 설계된 프로세스(= 프로그램)의 경우 퍼포먼스가 늘어날 수 있음

         2. 멀티 프로그래밍 (Multi-Programming) (= 동시성(Concurrency) 관점의 비동기적 프로세스 처리 가능한 시대의 등장)
            : 1960년대 후반 컴퓨터의 성능이 여러개의 프로세스를 띄울 수 있을 정도로 발전함
               -> 이제는 싱글 프로세서(Single-Processor) 환경에서 다중 처리(Multi-Processing) 시스템을 구현할 필요성이 생김
                  (= 싱글 프로세서(Single-Processor)라서 진짜로 물리적으로 동시에 코드를 처리하는 병렬처리는 불가능하지만.. 여러개의 프로세스를 어떻게든 동시간대에 실행하게 해서, 언제라도 유저가 조작하면 반응에 응할 수 있도록 컴퓨터를 설계해야 함)  
                      -> How to solve?
                          : 어차피 CPU 1개라서 병렬성(Parallelism)한 병렬처리는 불가능? 그럼 동시성(Concurrency)한 관점에서 CPU가 시간차로 플래쉬보다 ㅈㄴ 빠르게 여러 프로세스의 처리를 번갈아가며 처리하면? 동시에 프로세스를 실행하는거처럼 보이니 문제없겠네?
                             -> '시분할 시스템'을 통해 '동시성 프로세스(Concurrent Process)' 방식을 구현한, '프로세스 스케줄링(process scheduleing)'으로 비동기적 멀티태스킹(multi tasking) 구현
                                (= 프로세스 처리의 상태 기록을 위해서 컨텍스트(context) 개념이 도입 + 프로세스 간 통신을 위해 IPC 프로세서 사용 + 프로세스 동기화(processs Synchronization)를 통한 경쟁상태 문제 해결)
                      -> 결론
                          : 동시성(Concurrency) 측면에서는 진전이 있었지만, But 병렬성(Parallelism) 병렬처리에는 한계


            - 동시적 태스크 동기화 (Concurrent task Synchronization) 문제
               : 다수의 프로세스가 동시성(Concurrent)을 가지는 업무들(tasks)을 함께 수행함에 따라, 동시기에 공유된 자원에 경쟁적으로 접근(race condition)하게 되었을떄, 작업 과정 자체가 매번 달라지고 작업 결과의 신뢰성에 문제가 발생
                  -> 프로세스 동기화(processs Synchronization)를 통해 해결 가능

            - 용어 사전
               1) 다중처리(Multi-Processing)
                  : 컴퓨터 시스템이 동시에 여러 작업을 처리할 수 있는 능력을 의미... '처리방식', '사용자', '태스크(프로세스 실행개수)' 등 관점에 따라 구분하는 방식이 다양함
   
                     a. 싱글 태스킹 (Single-Tasking)
                         : 하나의 태스크 만을 전념 실행  
   
                     b. 멀티 태스킹 (Multi-Tasking)
                         : 여러 태스크들을 동시에 실행시킴

               2) 프로세스 스케줄링(process scheduleing)
                  : 프로세서(= CPU)가 아주 빠르게 주기적으로 각 프로세스의 주도권을 오가며 실행하는 계획안으로 이를 통해 싱글 프로세서(Single-Processor)로 다수의 프로세스들을 실행 가능하게 함
      
               3) 동시성 프로세스(Concurrent Process)
                  : '프로세스 스케줄링(process scheduleing)'을 통해, 동시성(Concurrency) 관점에서 비동기적으로 여러 프로세스들을 실행하는 것처럼 보이게 하는 방식
   
                    a. 독립적 프로세스 (Independent process)
                        : 여러 프로세스들이 '프로세스 스케줄링(process scheduleing)'을 통해 각각 독립적으로 동시성 수행(= 멀티태스킹)되는 개념
                          (= 개별 프로세스들은 다른 프로세스들에게 영향을 주지도, 받지도 않고, 데이터를 공유하지도 않음)
      
                    b. 협력 프로세스 (cooperaitng process)
                        : 다른 프로세스의 실행에 영향을 주는 여러 프로세스들이 '프로세스 스케줄링'을 통해, 동시성 수행(= 멀티태스킹)되는 개념
                          (= 각 프로세스들은 동일한 시스템을 기반에 두고 작동하기에, 동일한 메모리 공간에서 변수, 파일, 메세지 등을 공유하기에 나타나는 현상)
                              -> IPC(Inter-Process Communication) 프로세스를 사용해서 프로세스 상호 간 통신하여.. 공유될 데이터를 주고받음

               4) 프로세스 동기화(processs Synchronization)
                  : 입출력장치나 메모리와 같은 자원 한 순간에 하나의 프로세스만 이용하도록 제어하는 임계구역(critical section) 의 상호배제(mutual exclusion)를 구현
                     -> 이를 통해 경쟁상태(race condition)를 해소하고 공유자원의 일관성을 보장해 주는 것


         3. 컨텍스트 (Context) 개념을 활용한 프로세스(process) 내부의 비동기 작업 (= 프로세스 내부의 동시성(concurrency) 개념의 등장)
            : 1960 ~ 1970년대 개별 프로세스의 코드처리도 굳이 1요청에 1응답의 동시성 프로그래밍을 고집할 필요가 없어질 정도로 컴퓨터의 성능이 향상
               -> 이제는 싱글 프로세서(Single-Processor) 개별 프로세스(process) 내부의 코드를 단일 처리 흐름(후에 single thread로 불림)으로 동시성(Concurrent)을 가지도록 비동기로 작업 처리할 수 있게 해야 함
                   -> How to solve?
                       : 컨텍스트 스위칭(Context swiching)을 통해 해결
                          -> 프로세스 스케쥴링(process scheduleing)을 통해 프로세스 간 비동기적 멀티태스킹(multi tasking) 구현했던걸 응용하면 되잖아?
                             (= 프로세스(process)에서 비동기로 작업될 코드를 만나면? 해당 되는 프로세스 내부의 비동기 작업 상태 정보를 가지는 컨텍스트(Context)를 생성되게 함 + 이를 비동기 작업의 단위로 삼아 프로세스 처리 흐름이 돌아올 수 있게 하자)

            - 용어 사전
               1) (중요!) 컨텍스트(context) 
                  : 실행 중인 프로세스(process)나 스레드(thread)의 상태를 나타내는 정보 집합 (레지스터 값, 프로그램 카운터 등의 정보 존재)
                     -> 프로세스 간의 실행 순서와 동시성을 관리할 수 있기에, 프로세스 및 쓰레드 간의 스위칭이 가능해져 멀티태스킹이 실현
                        (= 정확히는 프로세스 스케쥴링과 프로세스 내부의 비동기 작업, 병렬 처리에 전부 사용될 수 밖에 없음)
                            -> (중요) js의 promise 객체 또한 정확히는 이 프로세스의 컨텍스트(context)에 대한 내용을 담는 개념임

               2) 컨텍스트 스위칭(context switing) 
                  : 현재 실행 중인 프로세스 or 쓰레드의 상태를 저장하고 다음 실행할 프로세스 or 쓰레드의 상태를 복원하는 과정
                    (= Concurrency(동시성) & Parallelism(병렬성) 양쪽 모두와 연관이 깊은 개념)


         4. 쓰레드(thread) 개념의 등장 (= 프로세스 내부의 '유사' 병렬성(Parallelism) 개념 (= 결국 동시성(concurrency)의 등장)
             : 1970년대 컴퓨터의 발전은 싱글 프로세서(single processor) 환경임에도, 더 이상 프로세스를 프로그래밍의 최소 처리 흐름 단위로 둘 이유가 없을 정도로 발전함
               (= 개별 프로세스의 처리에 있어, 동시성(Concurrency)을 넘어서 병렬성(Parallelism)을 기반으로 한 병렬처리가 가능할 수 있도록, 프로그래밍의 새로운 최소 처리 흐름 단위가 필요)
                   -> 프로세스 내에서 실행되는 각각의 독립적인 실행 단위인 '쓰레드(thread)'의 등장
                      (= 쓰레드를 여러개를 쓰는 멀티 쓰레드(multi thread)를 통해, 병렬성(Parallelism)에 입각한 프로세스의 병렬처리가 가능해짐)


            - 쓰레드(thread)의 특징
               1) 개별 thread는 각각 독립된 실행 흐름과 스택(stack)을 가짐
                  (= 다른 thread와 처리 영역이 겹치는 고생을 하지 않기에, 동시성 문제를 방지하는 측면이 존재)

               2) 개별 thread는 프로세스 안에서의 전체적인 실행 흐름과 힙(heap)영역은 공유를 함
                  (= 각자 하는 일이 전체를 향하는 일괄적인 흐름을 가진 작업이 됨)

               3) 개별 thread도 context가 존재하여, context switching의 대상이 될 수 있음

               4) 한 프로세스(process)의 여러개의 쓰레드(thread)가 존재 가능함

               5) 기본적으로 쓰레드는 평행성(Parallelism)을 근거로 한 물리적으로 동시적 프로그래밍 처리를 하는 병렬처리를 위해 만들어짐
             -> (중요!) 단! 진정한 평행성(Parallelism)은 멀티코어 cpu를 사용한 멀티 프로세서 환경에서 실현됨 = 싱글 프로세서 환경에서는 멀티 쓰레드 해봐야 동시성(concurrency) 기반 작업이 됨


               6) 쓰레드는 한편으로는 동시성(concurrency) 또한 강조한 개념임
                  (= 여러개의 쓰레드는 프로세스의 context swiching 작업 또한 더 빠르게 처리하여 공유 자원을 또한 더 효율적으로 사용하기에, 비동기 처리 또한 더 빠르게 수행하게 해줌)


         5. 다중 프로세싱(multi processing)의 등장 (= 프로세스 단위로 진정한 병렬성(Parallelism) 개념과 병렬처리 가능한 시대)
             : 소위 말하는 듀얼 코어 CPU의 등장으로 프로세스들을 동시성(Concurrency)에 근거한 비동기가 아닌 병렬성(Parallelism) 병렬처리가 가능해짐
               (= 추후 이 멀티 코어가 쓰레드와 하드웨어적 소프트웨어적으로 더 연계되어... 개별 프로세스의 퍼포먼스 향상에도 프로세서의 모든 역량을 집중하는게 또 가능해짐)


  @ 컨텍스트(context) with 동시성(concurrency)
     : 실행 중인 프로세스(process)나 스레드(thread)의 상태를 나타내는 정보 집합 (레지스터 값, 프로그램 카운터 등의 정보 존재)
        -> 프로세스 간의 실행 순서와 동시성(concurrency)을 관리할 수 있기에, 프로세스 및 쓰레드 간의 스위칭이 가능해져 멀티태스킹이 실현
           (= 정확히는 프로세스 스케쥴링과 프로세스 내부의 비동기 작업, 병렬 처리에 전부 사용될 수 밖에 없음)
               -> (중요) js의 promise 객체 또한 정확히는 이 프로세스의 컨텍스트(context)에 대한 내용을 담는 개념임


  @ 쓰레드(thread) with 평행성(Parallelism)
     : 프로세스(= 컴퓨터에서 메모리에 instance로서 객체화 되어 올라가 실행중인 프로그램)마다 최소 1개는 존재하는 한 단계 더 낮은 프로그램의 최소 실행 흐름 단위
       (= 쉽게 말해, 쓰레드는 실행 중인 개별 프로세스 안에 속해서, 개별적으로 코드를 읽고 실행하는 주체로 이해하면 되며, 당연히 프로세스를 실행하기 위해서는 최소 실행 주체가 1개는 필요하다는 점에서 매우 상식적인 말임)
           -> ex) 프로세스(process) : 개별 건설현장 = 쓰레드(thread) : 현장 노동자
                  (= 건설 현장에서 업무를 수행하기 위해서는? 당연히 최소 1명의 노동자가 필요함)

      # 쓰레드(thread)의 특징
         1) 개별 thread는 각각 독립된 실행 흐름과 스택(stack)을 가짐
            (= 다른 thread와 처리 영역이 겹치는 고생을 하지 않기에, 동시성 문제를 방지하는 측면이 존재)

         2) 개별 thread는 프로세스 안에서의 전체적인 실행 흐름과 힙(heap)영역은 공유를 함
            (= 각자 하는 일이 전체를 향하는 일괄적인 흐름을 가진 작업이 됨)

         3) 개별 thread도 context가 존재하여, context switching의 대상이 될 수 있음

         4) 한 프로세스(process)의 여러개의 쓰레드(thread)가 존재 가능함

         5) 기본적으로 쓰레드는 평행성(Parallelism)을 근거로 한 물리적으로 동시적 프로그래밍 처리를 하는 병렬처리를 위해 만들어짐
             -> (중요!) 단! 진정한 평행성(Parallelism)은 멀티코어 cpu를 사용한 멀티 프로세서 환경에서 실현됨 = 싱글 프로세서 환경에서는 멀티 쓰레드 해봐야 동시성(concurrency) 기반 작업이 됨

         6) 쓰레드는 한편으로는 동시성(concurrency) 또한 강조한 개념임
            (= 여러개의 쓰레드는 프로세스의 context swiching 작업 또한 더 빠르게 처리하여 공유 자원을 또한 더 효율적으로 사용하기에, 비동기 처리 또한 더 빠르게 수행하게 해줌)


      # 다중 쓰레드(multi thread) with 병렬처리
         : 실행 중인 개별 프로세스에서 개별적으로 코드를 읽고 실행하는 주체가 여럿인 경우인 프로세스 환경을 의미하는 것으로.. 평행성(Parallelism)에 입각한 병렬처리가 가능해짐
            -> 쓰레드(thread)의 개수가 많으면, 평행성(Parallelism)이 context swiching을 더 효율적으로 수행하게 하여 동시성(concurrency)을 강화하기에, 프로세스의 비동기 코드 처리를 더 빠르게는 할수 있음..
                -> (중요) BUT! 쓰레드의 갯수는 비동기 작업 가능 여부와 1도 상관 X

         1) 다중 쓰레드(multi thread) + 동기적 프로그래밍 처리를 하는 경우
             : 싱글 쓰레드 환경과 마찬가지로.. 해당 작업이 완료될 때까지 다른 작업들이 블로킹 됨.. 
               (= 1요청 1응답이 완료 될 때까지 다른 쓰레드가 논다는 말씀...)

         2) 다중 쓰레드(multi thread) + 비동기적 프로그래밍
             : 싱글 쓰레드 일때?  
                -> 진행중인 비동기 코드의 컨택스트(context)을 번갈아가며 수행하는 컨텍스트 스위칭(context switing)으로 커버

             : 쓰레드의 수가 많을 때 
                -> 비동기 코드의 컨택스트(context)들을 실제로 동시에 다른 쓰레드들이 같이 처리해 줌 
                   (= 컨텍스트 스위칭(context switing)의 수가 적어짐)


      # (중요) 다중 쓰레드(multi thread) & 프로세서(processor)의 갯수에 따른 Concurrency(동시성) & Parallelism(병렬성) 관계
         : 다중 쓰레드(multi thread)의 Parallelism(병렬성)에 기반한 병렬 처리는 오직 다중 코어 CPU를 사용한 다중 프로세서(multi processor) 환경에서만 가능!
            <-> 싱글 프로세서(single processor) 환경에서는 멀티 쓰레드를 사용해봐야, 결국 다양한 작업들을 동시에 조율하고 번갈아가며 실행함으로써 마치 동시에 처리되는 것처럼 보이는 동시성(concurrency)에 기반한 기반 일종의 비동기 작업이 됨
                (= 그럼에도 이를 쓰는 이유는 이를 통해 응답없음으로 인한 블로킹을 피할수가 있음)


  @ 비동기 작업 VS 동기 작업
     : 요청(request)를 수행할 시, 응답(resonse)을 받을 때까지 다음 코드로 넘어가는가 넘어가지 않는가 여부에 따라 갈림

        1) 동기 작업 (순차적 작업)
           : 요청(request)과 응답(resonse)은 하나의 작업처리 단위(transaction) 세트로서 동시에 일어나는걸 전제로 하여, 프로세스의 흐름를 1차선적으로 수행하는 것을 동기라고 함
              -> 대충 노빠꾸 one way 전략에 위에서 까라면 밑에서는 일방적으로 까는 것과 비슷..
                 (= 2인 3각 릴레이 계주처럼, 한 팀의 작업이 끝날때까지 다른팀들은 보고만 있어야 함)
                     -> 쉽게 설계할 수 있지만, 결과가 주어질 때까지 아무것도 못하고 대기해야 함
  
        2) 비동기 작업(비순차적 작업) with 동시성(concurrency)
           : 요청(request)과 응답(resonse)이 동시에 일어나지 않는 별개의 작업처리 단위(transaction)로서, 동시성(concurrency)을 기반으로 동시 다발적으로 발생가능하고, 다른 작업을 시작할 수 있도록 제어가 반환되어 요청과 응답이 다른 시간대 존재해도 되는 작업 처리 방식을 비동기라고 함
             (= 프로세스의 작업처리 상태값을 가진 컨텍스트(context)를 통해, 비동기 코드를 수행중인 thread들이 어디에 비동기 코드가 있는지와 처리 여부를 체크가능)
                 -> 쉽게 말해, 개별 요청과 응답은 전체프로세스와 별개로 독립적이면서 병렬적으로 수행되며, 어떤 요청단위가 수행되고 나면 응답이 오는거랑 상관없이 다른 프로세스는 진행됨
                    (= 메인 쓰레드가 아닌 다른 쓰레드로 비유 가능한 계열사들이 본사의 의지랑 상관없이 자신의 비즈니스를 수행하고 계약하는 독립채산제나 현실의 회사생활에서 직원을 출장보내도 본사는 굴러가는걸 생각해보면 간단함)
                        -> (장점) 결과가 주어지는데 시간이 걸리더라도, 동시기에 다른 작업 또한 동시에 할 수 있으므로 자원을 효율적으로 사용
                        -> (단점) 제대로 신경을 쓰지 않으면, 한 프로세스의 작업처리 단위(transaction)들이 전부 비동기적(= 병렬적)으로 수행되어 일처리가 뒤죽박죽하게 됨
                                  (= 비동기적 작업방식을 통해 제대로 된 효율을 내기 위해서는 복잡한 설계도 감안해야 함..)
                                      -> 비동기적 작업처리 프로세스에서도 통제를 위해서는 큰 틀에서 이 비동기 코드들이 용도를 기준으로 그루핑되어 각각 동기적(= 순차적) 방식으로 단계적으로 수행될 수 있도록, 하나의 작업처리 단위(transaction)로서 기능할 수 있도록 분류하는 기준점이 필요하다는 결론 도출                                      


      # 비동기적 코드들을 큰 틀에서 동기적(= 순차적)으로 단계적 동작하게 하는 방법(?)
         : 쉽게 말해, 비동기 코드들에게 작업순서를 기준으로 순번을 부여하고 그 순번을 기준으로 이들을 그룹화해서, 각 그룹의 실행타이밍을 통제함으로서 그룹기준으로 순차적 처리가 가능하게 한다고 생각하면 됨
            -> 해당 작업흐름(workflow)을 단위들을 기준으로 비동기적 작업처리 프로세스의 작업처리 단위(transaction)들을 분류하고, 그렇게 분류된 비동기적 코드들은 자신이 소속된 작업흐름(workflow)가 실행될 타이밍에 맞춰 동시다발적 수행됨
               (= 이를 통해 무질서하게 수행되는 개판 5분전을 방지하고, 비동기 코드의 실행 메커니즘을 인간의 시각을 기준으로 설계할 수 있게 됨)


               ex) 페이지 리로드의 비동기식 방식의 workflow 분류
                    (1단계) -> 필요한 페이지의 html파일들을 다운로드 하는 로직(해당 로직의 코드만 비동기적으로 실행)
                    (2단계) -> (1단계 완료시) 다운로드 받은 html파일들을 랜더링(해당 로직의 코드만 비동기적으로 실행)


         - 세부적 설명
            1단계) 프로세스 로직을 순차적인 작업흐름(workflow)의 집합으로 간주하고 나눔
            2단계) 해당 작업흐름(workflow)을 단위(= 시스템 입장에서는 작업처리 단위(transaction)로 간주)들을 기준으로 비동기 코드들을 분류하여 그룹화를 시킴
            3단계) 각 그룹 내의 모든 비동기 코드들을 1개의 작업처리 단위(transaction)로서 간주, 작업흐름(workflow)의 순서를 기준으로 microtask queue에 넣어 실행타이밍 통제함
                   (= 시스템 입장에서의 작업흐름(workflow) 단위 == 작업처리 단위(transaction)로 간주)
             

         - 용어 설명
            1) 작업흐름(workflow) 
               : 비동기 코드로 이루어진 프로세스의 로직을 업무로 추상화한 내용적 논리로 바라보는 인간의 관점을 분류(catagorize) 기준으로 삼아서, 큰 틀에서 순차적으로 수행되는 업무 단위로 도식화한 결과물 

            2) 작업처리 단위(transaction)
               : 도출된 개별 작업흐름(workflow)을 메커니즘적인 작업흐름의 단위로 간주하여, 그 개별 작업흐름(workflow) 단위(unit)를 기준으로 원맨아미 같은 비동기코드들을 분류하여 그룹화 한 결과물의 개별 단위 
                 (= 작업처리 단위(transaction) == 시스템 입장에서의 보는 작업흐름(workflow) 단위)
                    -> 같은 분류기준으로 묶였을 경우 원래 한 몸이었던 것처럼 일괄적으로 조작 및 통제가 가능해지기에 작업처리 단위(transaction)라고 부름
            

         - (중요!) js에서도 이같은 작업흐름(workflow) 개념을 기점으로 비동기 프로세스의 작업처리 단위(transaction) 순서를 통제할 방식이 필요해서 등장한게 promise 객체
            -> Promise 객체의 상태값은 이 작업흐름(workflow)개념을 바탕으로 비동기 프로세스의 내부에서 순차적으로 작업처리 단위(transaction)의 수행되는 각 단위의 업무 처리 현황 및 결과가 기준이 됨


  @ Promise 객체
     : ECMA6 이후 JS로 작성된 프로세스의 내부 작업의 비동기 처리를 위해, 프로세스의 비동기 코드 작업 상태에 대한 정보(= 상태값)를 가지는 컨텍스트(context) 역할을 수행하는 promise 객체
       ->  거대한 비동기 프로세스을 '작업흐름(workflow)을 기준으로 작업처리 단위(transaction)'를 순차적으로 나눈 뒤, 그 영역의 성공/실패 여부를 상태값을 통해 통제/관리 하는 방식으로 의 무분별한 병렬적 코드 실행을 방지하여 비동기 프로세스의 안정적 실행을 가능하게 함
           (= 비동기 작업에 따른 상태값의 구현은 내부에서 비동기 작업의 (각 처리단계를) 성공여부를 boolean으로 잡으면.. 그 값에 따라서 Promise 객체 생성자의 parameter로 들어가는 무명함수의 parameter인 2개의 parameter로 놓은 2개의 callback(일반적으로 resolve, reject 불림) 중 하나를 실행하는 방식)
               -> 그렇기에, 순차적으로 동적하는 js에서 ajax 같은 비동기로 각각 병렬적으로 동작하는 기능을 구현이 가능함
                  -> 일반적으로 비동기처리를 통해 전체적인 작업의 처리시간(leading time)을 줄일 수 있음
                     (= 비동기 작업은 일반적으로 서버와의 데이터 통신이나 파일 읽기와 같이 시간이 오래 걸리는 작업을 의미)


      # (중요) Promise 객체가 각 비동기 작업처리 단위(transaction)의 성공/실패 여부를 판단하는 로직
         : (이름은 상관없지만) Promise 객체 생성자의 parameter로 들어가는 무명함수의 parameter로 들어가는 2개의 callback함수(일반적으로 resolve, reject 불리는)를 넣으면.. 내부에서 비동기 작업 성공여부를 boolean으로 기록되게 하면
            -> 비동기 작업 성공시 (= promise객체의 상태값 : fulfilled) : resolve를 실행
            -> 비동기 작업 실패시 (= promise객체의 상태값 : rejected)  : reject를 실행
         
               ex) const promise = new Promise((resolve, reject) => {

                     // 비동기 작업 수행 성공여부를 따지는 로직
                     if (isResolved == true) {
                       resolve("Success");   <- 성공적으로 처리될 경우 무명함수의 parameter 중 resolve를 callback함수로 호출
                     } else {
                       reject("Error");      <- 거부될 경우 무명함수의 parameter 중 reject를 callback함수로 호출
                     }
                     
                   });

      # (중요) Promise 객체의 비동기 작업처리 단위(transaction) 처리 결과 상태값 3가지
         : 비동기 프로세스 내부의 진행되는 로직들은 순차적으로 진행되는 작업처리 단위(transaction)의 성공/실패 여부를 기록한 각 Promise객체의 상태값에 따라 후속처리가 분기처리함
            -> (중요) 이 Promise객체의 상태값(pending, fulfilled, rejected)은 추후 비동기작업 처리 및 현재 단계 동기작업 처리의 성공/실패의 후속 처리 로직에 관여
               (= 각 단계의 비동기 작업처리 단위(transaction)의 성공/실패에 따른 후속 처리 로직은 상태값의 도출을 순차적으로 기다려야 함 == 비동기 작업의 일부 로직을 순차적인 동기적 처리로 처리함)   
                  -> 추후 fetch()나 axios 등 js에서 비동기로 서버와 통신한 ajax 통신 결과에 따른 분기처리를 가능하게 함

         1) 대기(pending)
            : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 수행이 아직 완료되지 않은 상태
               -> 상태값이 pending으로 유지됨 =  다음 단계의 then(), catch(), finally() 패턴 및 async, await에서 다음 단계의 await 구문의 실행을 억제하는데 사용
                  (= '상태값이 pending -> 다른 상태로 변화'가 비동기 작업의 일부 로직이 동기적으로 처리되게 유도하는 일종의 트리거 역할)
 
         2) 이행(fulfilled)
            : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 수행이 성공적으로 완료된 상태
                -> then(), catch(), finally() 패턴의 .then()와 async, await에서 패턴에서 await를 구현하는데 사용
                   (= 상태값이 fulfilled로 전환되는 순간, 해당 코드들이 순차적으로 실행)

         3) 거부(rejected)
            : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 수행이 실패한 상태
                -> then(), catch(), finally() 패턴의 .catch()을 구현하는데 사용
                    -> (중요!) async, await에서도 비동기작업이나 현재 await 작업의 실패 후의 처리는 .catch()가 맡게 됨
                       (= async, await와 then(), catch(), finally()는 공존이 가능하다는 결론이 나옴...)


      # ajax와 axios, fetch API와 Promise 객체의 관계
         : 추후 ajax 기능을 수행하는 axios와 fetch API 또한 promise 객체의 상태값을 기반으로 동작하는 비동기 작업
           (= js의 비동기적 정보 교환 기법은 각 작업처리 단위(transaction) 수행에 따른 결과값을 가진 Promise 객체를 return함)
            -> (중요) 그들의 요청에 대한 응답 내용 또한 비동기 프로세스의 개별 작업처리 단위 수행 결과의 후속을 처리하는 하단의 then(), catch(), finally()와 async / await을 이용하여 처리할 수 있음


  @ then(), catch(), finally()
     : 비동기 프로세스의 개별 작업처리 단위(transaction)를 기준으로, 각 작업이 진행완료 될 때까지(pending) 기다린 뒤 그 성공(fulfilled)과 실패(rejected) 결과를 바탕으로 경우의 수에 따른 수행할 분기 구조를 구현하는데 사용되는 promise 객체의 멤버함수들
       (= 비동기 작업 시도를 try로 보면 try ~ catch와 유사 + 비동기 작업의 일부를 동기적인 것으로 만듦)
           -> (중요) then(), catch(), finally()는 전부 무명의 콜백함수를 parameter로 가짐
                : but! 몇개의 callback 함수가 parameter로 들아가는지가 다름
                   => then()의 경우?    2개의 무명의 콜백함수를 parameter로 가지고, 그 콜백함수는 각각 2개의 object(일반적으로 result, error라고 불림)를 parameter로 가짐 
                   => catch()의 경우?   1개의 무명의 콜백함수를 parameter로 가지고, 그 콜백함수는 1개의 object(일반적으로 error라고 불림)를 parameter로 가짐 
                   => finally()의 경우? 무명의 콜백함수는 parameter로 가지지 않음

               ex) const promise = new Promise((resolve, reject) => {
        
                     // 비동기 작업 수행 성공여부를 따지는 로직
                     if (isResolved == true) {
                       resolve("Success");   <- 성공적으로 처리될 경우 무명함수의 parameter 중 resolve를 callback함수로 호출
                     } else {
                       reject("Error");      <- 거부될 경우 무명함수의 parameter 중 reject를 callback함수로 호출
                     }
        
                   });
        
                   // 상단의 promise객체를 통한 비동기작업이 끝난 이후 then(), catch(), finally() 함수는 수행
                   promise.then(
        
                     (result) => {
                       console.log("Resolved:", result);
                     },
                     (error) => {
                       console.error("Rejected:", error);
                     }
        
                   ).catch((error) => {
                     console.error("Caught an error:", error);
        
                   }).finally(() => {
                     console.log("Finally");
                   });


         1) then()
            : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction)의 성공/실패 후, 분기에 따라 자신의 parameter인 2개의 무명의 콜백함수(각각 result, error로 알려진 object를 parameter로 가져감) 중 하나를 실행함
               -> (중요) 2개의 무명함수 parameter로 선언만해두고 사용 안 해도 무방함
         
              a. (1번째 무명함수 parameter) result
                  : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 결과가 성공이면, 그 성공의 결과값을 가지는 object
         
              b. (2번째 무명함수 parameter) error
                  : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 결과가 실패이면, 그 실패의 결과값을 가지는 object
                     -> catch()로도 구현가능!
         
         2) catch()
            : (비동기 프로세스의) 현재 처리중인 작업처리 단위(transaction) 결과의 실패가 감지되면, 자신의 parameter인 무명의 콜백함수(error로 알려진 object만 parameter로 가져감) 중 실행함
              (= catch() == then()의 실패 케이스만 특정한 Promise 객체의 멤버함수)
                  -> 따라서, then()은 비동기처리 성공시에만 동작하게 쓸 수도 있음
         
         3) finally()
            : (비동기 프로세스의) 현제 작업처리 단위(transaction) 결과의 성공/실패와 상관없이, 자신의 parameter인 무조건 무명의 콜백함수를 실행함
               -> finally()의 parameter인 무명의 콜백함수는 parameter를 가지지 않음


      # then(), catch(), finally() 비동기 프로세스 처리 패턴의 약점 및 한계
         : 작업처리 단위(transaction)안의 작업처리 단위(transaction)의 등장으로 인한 callback hell 문제로 인해 코드가독성이 메챠쿠챠...
            -> 이를 해결하기 위해 등장한게 async / await 패턴과 React hooks라고 보면 됨

               ex) promise.then(
                     (result) => {

                        promise.then(
                           (result) => { 

                              promise.then((result) => { 내용 })
                               .catch((error) => { 내용 })
                               .finally(() => { 내용 })
                        })
                        .catch((error) => { 내용 })
                        .finally(() => { 내용 }
                     }

                   ).catch((error) => {
                     console.error("Caught an error:", error);
                   }).finally(() => {
                     console.log("Finally");
                   });


  @ async / await
     : (then(), catch(), finally()의 callback hell 문제를 막기 위해) Promise의 상태값을 기반으로 특정 함수를 기반으로 비동기 프로세스로서 병렬적으로 처리하기 위한 비동기 프로세스 처리 패턴
        -> 특정 함수를 비동기 프로세스로서 병렬적으로 처리하기 위한 예약어로 async를 사용, 그 {} 안에 특정 코드가 작업처리 단위(transaction)의 기점으로서 요청에 대한 응답이 나올떄까지 대기하도록 하기 위한 이정표 역할의 예약어로서 await를 사용
           (= async 함수명{ await코드; 코드 ~~  await 코드;} 이런식으로 사용)

         1) async
            : 어떤 함수를 비동기 프로세스로서로 병렬적으로 코드를 처리하라고 표기하기 위한 목적의 예약어
               -> 비동기 프로세스 작업 처리 결과의 성공/실패에 대한 상태값을 가진 promise 객체를 return함

         2) await   
            : async로 비동기 방식 처리 간판이 붙은 함수 작업영역의 코드 중, 수행결과가 나올 떄까지 기다려야 하는 작업처리 단위(transaction)의 기점이 될 코드를 의미하는 표식을 의미하는 예약어가 await
                -> (중요!) await는 이전 await의 다음 코드 ~ 현재 await 코드의 범위인 해당 작업처리 단위(transaction)의 처리결과가 성공이었을 때만, 다음 await까지의 작업처리 단위(transaction)를 진행함
                   (= 작업처리 단위(transaction의 결과가 성공시에만 진행되는 then() 패턴을 공식적으로 다른 방식으로 구현한 것에 가까움)


      # (중요) async / await 작업처리 단위(transaction)의 실패 후의 처리는 .catch()가 맡게 됨
         : then(), catch(), finally()와 async / await는 공존이 가능함을 암시함.. 
            -> 전자는 promise 객체의 메서드고, 후자는 promise객체를 기반으로 동작하기 때문에 호환됨

               ex) async function fetchData() {
                  
                     try {
                       const response = await fetch('https://api.example.com/data');
                       const data = await response.json();
                       
                       const userResponse = await fetch('https://api.example.com/user/' + data.userId);
                       const userData = await userResponse.json();
                       
                       console.log('Order:', orderData);

                     } catch (error) {
                       console.error('Error:', error);
                     }
                   }



  @ Ajax(Asynchronous JavaScript and XML)
     : 프로그래밍 언어인 JavaScript와 마크업 언어인 XML을 이용해서, 브라우저에서 새로고침을 하지 않고도 서버에 GET, POST 요청을 통해 데이터를 주고받을 수 있게 도와주는 브라우저 차원에서 지원되는 비동기적 정보 교환 기법
       (= 쉽게 말해, 웹페이지를 개발할 때, JavaScript를 이용해서 서버에 GET, POST 요청을 새로고침이 없이 비동기적인 연속성을 가지고 보내고, 받고 할 수 있음을 의미)
          <-> 과거 html태그 중 form 태그가 이런 서버에 대한 데이터 요청을 'http메서드(get, post에 한정) + url형식'을 통해 http API 방식으로 티키타카를 할 수 있게 하였으나..? 티키타카할 떄마다 화면이 새로고침이 되어 모든 html요소와 데이터를 다시 받아오는걸 피할 수 없었음


      # 관련 개념 간단 설명 및 정리

         1. 서버
             : 유저가 데이터달라고 요청(request)을 서버가 정한 API 규격(요청 방법 : 어떤 자료 = http메서드 : url형식)에 맞게 하면, 이를 알아먹고 요청에 맞는 데이터를 보내주는(response)하는 간단한 프로그램을 실행하는 컴퓨터

                ex) 유튜브 서버     = 유저가 영상 달라고 하면 영상 보내주는 프로그램을 돌리는 컴퓨터
                    네이버웹툰 서버 = 유저가 웹툰 달라고 하면 웹툰 보내주는 프로그램을 돌리는 컴퓨터

         2. http 메서드
             : 월드 와이드 웹(World Wide Web)에서 사용되는 Hypertext Transfer Protocol(HTTP)을 통해 서버에 요청을 보내는 방법을 정의하는 명령어
               (= 쉽게 말해, client(유저)가 서버로 하여금 일부 자원(resource)에 대한 자료를 보내면, 이를 이용해 수행해야 할 구체적인 동작 방식 종류를 핀포인트로 지정하는 것이라 보면 됨)
                   -> 대충 어떤 url에 딸려 있는 자원(resource)을 어떻게 작업(http 메서드)을 쳐라라는 동사적인 의미를 가지고 있음  

              - http 메서드의 종류

                 1) GET (원년 멤버)
                     : 서버에서 보낸 데이터를 단순 조회하기 위해 사용하는 http 메서드
                        -> (중요) 요청시 http의 head 부분에 client(유저)가 보낸 parameter가 url과 함께 보이는 특징 존재
                        -> 동일한 요청을 연속적으로 수행해도, 같은 결과가 나옴 = 데이터가 변조되지 않기에 안전한 http 메서드

                 2) POST (원년 멤버)
                     : 서버로 일부 데이터를 보내면, 이를 이용해서 서버로 하여금 새로운 데이터들을 생성/변조/삭제하기 위해 사용하는 http 메서드 
                        -> (중요) 요청시 http의 head 부분에는 url과 http메서드만 보일 뿐, client(유저)가 보낸 parameter는 body 부분에 놓여있어 보이지 않음
                        -> PUT, PATCH, DELETE를 대체할 수 있는 범용성 높은 http 메서드
                        -> 동일한 요청을 연속적으로 수행하면, 여러 리소스가 생성될 수 있음 = 데이터가 변조되기에 안전 X한 http 메서드

                 3) PUT
                     : 서버로 보낸 내용이 기존 리소스의 모든 데이터를 빈 칼럼값까지 완벽하게 대체하여 수정하는 데 사용하는 http 메서드
                        -> (중요) 업데이트 하는 내용이 유저가 보낸 내용과 완전히 동일함 = 동일한 요청을 연속적으로 수행해도, 같은 결과가 나옴 = 데이터가 변조되지 않기에 안전한 http 메서드

                 4) PATCH
                     : 서버의 기존 리소스를 부분적으로 업데이트하는 데 사용되는 http 메서드
                        -> (중요) 업데이트 하는 내용이 부분적으로 지정되어 있음 = 동일한 요청을 연속적으로 수행해도, 같은 결과가 나옴 = 데이터가 변조되지 않기에 안전한 http 메서드

                 5) DELETE
                     : 서버에서 데이터를 제거할 때 사용하는 http 메서드
                        -> (중요) 삭제할 데이터는 특정한 값을 기준으로 정해져 있음 = 동일한 요청을 연속적으로 수행해도, 같은 결과가 나옴 = 데이터가 변조되지 않기에 안전한 http 메서드


              - http 메서드가 get, post 이외로 더 생기는 이유

                 1) http 메서드의 갯수가 많아지면, 메서드명 자체에 의미적(semantic)인 부분을 고려할 수 있게 되고, 유저나 개발자가 해당 http API의 의도를 더 쉽게 파악할 수 있음
                 2) 같은 url이라도 http 메서드가 다르면, 동사적인 의미(semantic)자체가 달라지기에, 다른 http API로 구분될 수 있기 때문
                     -> class에 따른 집합의 존재로 같은 변수명들의 구분이 가능하여, 변수명 짓기의 스트레스에서 쉽게 벗어나는 같과 같이, url 설계에서도 스트레스가 많이 사라지게 됨


      # JS기반 언어에서 Ajax(Asynchronous JavaScript and XML) 사용하는 방법

         1. XMLHttpRequest라는 옛날 고전적인 js에서의 ajax 문법 사용
         2. js ECMA6 이후 등장한 fetch() 사용
         3. axios라는 js 외부 라이브러리 사용


      # axios VS fetch

         1. 공통적인 부분
             1) 둘 다 JS의 promise가 상태를 관리하여 다른 코드가 비동기적으로 실행될 수 있도록 만드는 객체인 Promise 객체의 API를 기반으로 사용하여 구현된 기능
             2) 둘 다 JS의 사용자가 서버로 http 메서드 + url로 요청을 보내는 짓은 비동기로 병렬적 실행을 하지만, 각 요청은 요청에 대한 결과가 나올 때까지 기다려야 함..
                 -> 각 http 메서드를 통한 요청에 대한 결과를 기다린 뒤에는? 
                     a. then(), catch(), finally() 함수
                         : 비동기 작업의 '성공 or 실패 or 무조건 실행' 이라는 조건에 맞춰 try, catch, finally와 유사한 느낌으로 then(), catch(), finally() 함수를 연쇄적으로 사용해서 시도에 대한 성공 실패여부를 따지는 조건분기 진행루트를 만들 수 있음
                        (= try ~ catch가 switch 문법 기반이니 만큼, then(), catch(), finally() )
                 
             3) (둘 다 ajax 방식으로 서버와 통신하기에) 받아오는 데이터는 json이나 html종류를 받아옴
             4) (둘 다 ajax 방식으로 서버와 통신하기에) 비동기식으로 병렬적으로 코드를 수행함 = 연달아 들어오는 fetch()나 axios 구문이 있으면, 거의 시간차 없이 수행된다 보면 됨
                 -> 그래도... 동시에 수행하는건 아니기에.. 어쩄든 진짜 동시에 ajax 요청을 보내기 위해 사용하는게, js의 Promise 객체의 all 메서드임 
        
         2. 차이점

             - axios 특성
               1) 장점
                   a. 받아오는 json 형식의 데이터를 사용자가 보기 좋게 자동으로 array로 변환해 줌
                   b. http메서드를 단순히 axios 객체의 멤버함수로 제공해서 쓰게 함으로서, 개발자로 하여금 직관적으로 http 메서드를 사용하게 함

               2) 단점 : 외부 js 라이브러리이기에 어쩄든 개발자가 조금이라도 번거로워지고, 서비스에서 로딩시간 증가에 영향을 줄 소지는 있음

             - fetch()
               1) 장점
                   a. ECMA6에서 기본으로 지원되는 함수라서, 별 다른 과정없이 그냥 써먹을 수가 있음
                   b. 요청 후 받는 데이터를 가공하는 과정에서 then(), catch(), finally() 외에 await 문법을 사용이 가능함

               2) 단점
                   a. 받아오는 json 형식의 데이터를 자동으로 array로 변환해주진 않아서, 요청이 성공해서 데이터를 받으면 이를 변환하는 코드가 추가되어야함
                   b. axios 라이브러리 처럼, http메서드를 단순히 axios 객체의 멤버함수로 제공해서 쓰게 하는게 아니라... 2번쨰 parameter로 js객체 형식으로 옵션값을 통해 http 메서드의 속성들을 하나하나 지정해줘야 함


  @ axios 라이브러리

   - axios 라이브러리 설치 및 모듈 불러오기 명령어
      : npm install axios
         import axios from 'axios'
   
   
   - axios로 http 메서드 요청을 보내는 문법
      : 
      1) get 메서드 요청
   
   axios.get('url명')    <->      axios.post('url명', {name : 'kim'})   <- post는 요청자가 데이터를 보내면, 그걸 서버가 가공한 후 response를 보냄
      : 해당 url명으로 get요청을 하게하는 axios 라이브러리의 멤버함수
         -> .then( (결과값명) => {내용} )
            : 서버를 향한 요청이 성공시 실행할 코드 
               -> '결과값명'은 임의로 붙일수 있고, 서버가 보낸 모든 값(json이나 html)을 지칭함...
                     -> (중요!) json으로 돌아온 응답값은 axios에서는 json -> object array 형태로 자동 변경해 줌..
                        -> 사용자가 바라는 요청데이터 이외에, 어마어마한 상태값을 가지는 멤버변수도 많으니... 
                           '결과값명.data'로 사용자가 원하는 object array 데이터 꾸러미를 받고, 가공할때는 array에서 멤버객체를 지정해 시작하자
         -> .catch( () => {내용} )
            : 요청 실패시 실행할 코드
         -> finally( () => {내용})
            : ajax 성공/실패랑 관계없이 무조건 실행하는 코드


  @ fetch()
     : 비동기 작업으로 네트워크를 통해 리소스를 가져오는 ajax 기능을 수행하는데 사용되는 Promise API를 기반으로 작성된 JS함수, 기본적으로 return의 결과로 Promise를 반환하여 각 비동기 작업들은 결과에 따른 분기 처리도 가능함
       (= )  





