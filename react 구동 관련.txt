- react 웹라이브러리를 써야 하는 이유
 : DOM객체를 통해서, JS가 HTML을 인식하고 동적으로 변경가능하게 해주었던 JQuery의 비효율성 때문
    -> 기본적으로 jQuery는 JS가 HTML을 직접 조작하는 DOM API를 단순히 쓰기만 쉽게 조정한 결과물
        (= 비유하자면, 전문가용 맥가이버 칼을 일반인도 다루기 쉬울 정도로 마개조한 상태...)
            -> 그럼에도 react 라이브러리가 등장하기 전까지는... ㅈㄴ게 편하다는 장점이 있어 angular 프레임워크에 이르기까지 널리 사용되었음..

- react 구동법 정리
  1. node js를 설치함
     -> npm(node package manager)를 이용해서 편하게 react 라이브러리를 이용한 프로젝트를 초기화 하기 위해서 위해서 반드시 필요함
  
  2. (mac, window 둘 다 해당)원하는 폴더를 생성한 뒤, 해당 폴더에서 터미널을 연다..
     -> cmd를 쓰던, powershell을 쓰건, VSCODE를 쓰던 걍 해당 폴더에 터미널을 통해 접근해서 다음 명령어를 실행할 준비를 하면 됨
  
  3. 'npx create-react-app 프로젝트명' 이란 명령어를 입력하면, 알아서 해당 위치에서 초기화 상태의 react 라이브러리 front-end bulid 파이프라인 파일을 다운로드함 
     ->  (npm 5.2+ 이후) 패키지 실행 도구 명령어 npm -> npx
  
  4. 'npm start' 란 명령어를 입력하면, 해당 상태의 react 라이브러리를 사용한 front-end 스크립트를 '로컬' 서버에서 live 상태로 실행함
     -> 이는 react 라이브러리에서 npm 명령어를 사전에 설정했기 때문..
        (= 자세히 알고 싶으면, nodeJS의 npm 명령어를 파야함)
  
  5. App.js 파일에서 Component 내용을 바꾸는 걸로 시작하면 됨
     -> index.js에서 해당 App.js를 모듈 형식으로 가져와서, Rendering 할 component로 설정한 상태
        (= 앞으로 컴포넌트를 제작하면 이런식으로 모듈로 만들어 가져오고, component 형식으로 root.Render 함수의 return 값에 붙이면 그만)
  
        # html을 작성하지 않고, js로 코딩해도 html이 작동하는 이유?
          : component 형식부터 rendering의 인터페이스 화를 구현한 react 라이브러리에 그것이 가능하게 코딩이 되어있고 프로그래머가 이를 끌어들여 해당 기능을 사용하기 때문
            (= API라는거 자체가 사용하는 쪽은 그냥 공급자가 명시하는 형식만 지켜서 쓰면 되고, 내부구조는 몰라도 되는 것을 의미함)

- react 성능개선 팁
   1. lazy import
       : aplication 배포시 모든 component들을 통합하여, 하나의 html, js 파일로 합본해 퉁치는 react 특성 상, 초기 로딩 시간이 약점이 될 수 밖에 없는 구조인데..
          -> 그 약점을 일부 나중에 등장하는 컨포넌트들을 통합 js파일에서 제외시켜, 별도로 import하도록 조치하자는 데서 비롯된 방식
             (= 나중에 늦게 import해줘라는 개념으로 볼 수 있겠다)

        # lazy() 함수
           : react에서 component js를 lazy import 할 떄 사용하는 함수
              -> lazy( () => import('파일 상대경로') ) 

                 ex) const Detail = lazy( () => import('./pages/Detail.js') )
               
        # 특성
          - 장점 : js의 갯수가 늘고, 개별 용량은 줄기에, 시작 js 다운로드 속도가 줄어듬에 따라 시작 속도가 빨라짐
          - 단점 : Detail과 Cart 컴포넌트 페이지 진입시, 당연히 시간이 오래걸림

   2. <Suspense> 태그 
       : 해당 태그로 감싼 component출력 영역은 fallback 속성의 값으로 HTML 태그를 넣으면, 컴포넌트가 로딩되는 동안 이 녀석이 임시적으로 출력됨  
          -> 사용자 경험이 좋아짐

         ex) <Suspense fallback={ <div>로딩중임</div> }>  .... </Suspense>

   3. memo(무명 함수형 컴포넌트 내용)
       : 특정 component가 크고 무겁기에 부모로부터 받은 props 값이 변동되는 것을 제외하고, react의 재랜더링 조건을 회피하고 싶을 떄 사용하는 함수
         (= 조건부로 재랜더링 원칙이 적용된 특수한 component lifeCycle을 가졌다 보자)
            -> memo의 결과값은 let, const, var로 받으며, 그 변수명은 반드시 component명이 되어야 함 
    
          ex) function MemoChild(){                                              let MemoChild = memo(function (){
                console.log('부모 Conponent인 Cart가 랜더링 되면? );       ->         console.log('부모 Conponent인 Cart가 랜더링 되면? );
                return <div></div>;                                                  return <div></div>;
              }                                                                  })
    
        # memo(무명 함수형 컴포넌트 내용)의 로직
           : 재랜더링 대상으로 들어간 컴포넌트 내용에 기존 props와 바뀐 props를 비교하는 연산이 추가로 진행되고, 그것이 다르면 재랜더링 진행함
             (= props가 크고 복잡하면 이거 자체로도 부담이 될 수도 있기에, 전가의 보도처럼 지르지 말고, 잘 판단해서 써야함) 


   4. useMemo( 무명함수, [state 및 props변수에 대한 배열요소])
       : memo() 함수랑 비슷하게, compoenent로드와 동시에 parameter로 들어가 있는 코드(특정 component나 함수)를 특별한 이유 없으면 단! 1번만 수행하라는 의미의 react-hooks 중 하나
         (= memo랑 비슷하게 주로 무거운 코드라, 재랜더링 할 때 반복수행되길 원지 않을 경우 사용)
            -> [state 및 props변수에 대한 배열요소]를 채우면, memo() 함수와 유사하게 특정 state나 props의 값의 변화시에 따른 재랜더링 시에는 반복을 허가함
               (= 해당 배열이 비어있다면... 재랜더링 때마다, 새로 실행..)

          ex) let result = useMemo( () => { return setMemoChildState(useMemoExample()) }, [] );

        # useEffect()  VS  useMemo()
           : (중요!) 코드의 실행시점이 구체적으로 차이가 있으며, 의미적으로도 차이가 있음
              -> useEffect() : component들의 랜더링 이후 실행되는 '사이드이팩트'에 해당하는 내용들만 실행
              -> useMemo()   : component들의 랜더링과 동시에 실행되는 코드로.. 부득이하게 시간을 오래잡아먹는 코드라 랜더링과 함께 실행되서 성능 향상을 위한 목적으로 사용