- react 웹라이브러리를 써야 하는 이유
   : DOM객체를 통해서, JS가 HTML을 인식하고 동적으로 변경가능하게 해주었던 JQuery의 비효율성 때문
      -> 기본적으로 jQuery는 JS가 HTML을 직접 조작하는 DOM API를 단순히 쓰기만 쉽게 조정한 결과물
         (= 비유하자면, 전문가용 맥가이버 칼을 일반인도 다루기 쉬울 정도로 마개조한 상태...)
            -> 그럼에도 react 라이브러리가 등장하기 전까지는... ㅈㄴ게 편하다는 장점이 있어 angular 프레임워크에 이르기까지 널리 사용되었음..

- JQuery의 한계점
   1. 직접적으로 JS를 통해 HTML을 어떤식으로 하나하나 바꾸라고 지시하는 DOM API 자체가 너무 low-level한 영역임
        -> 웹페이지 규모가 커질수록, 이걸 통해 직접적으로 하나하나 이벤트핸들러를 통해 DOM을 조작하면.. 코드의 복잡도가 매우 높아질 수 밖에 없음
             -> DOM API를 사용하여 웹페이지를 개발 및 유지보수를 하는것은 자동차의 기능을 구현을 위한 기술적 원리와 부품까지 한땀한땀 개별적으로 커스텀 설계하는 것과 유사함
   
   2. (1의 연장선 상으로) jQuery를 통해 DOM을 하나하나 작성해서 웹서비스를 구축하는 일은 가내 수공업으로 부품을 깎아서 자동차를 만드는 짓에 비유가 가능함
        -> 장인레벨 커스텀이 아니면 안정성이 떨어질 수 밖에 없음 + 구조가 제각각이라 검증된 모듈화나 HTML 컴포넌트를 적용하기 힘듬 
            (= 그 말은 유지보수도 자칫하면 ㅈ같아 질수 있음을 의미함) 
   
   3. 사용자에 의한 동적인 HTML 조작이 난무하는 Interactive Web 서비스에서 직접 DOM 조작을 수행하는 JQuery를 이용하면.. 클라이언트나 서버나 연산과 트래픽 때문에 죽어나감... (= ㅅㅂ 성능이 문제라고..)
       -> Client  : 클라이언트에게 렌더링을 떠넘기던 말던, 직접 DOM조작을 통해 배치와 화면표시에 많은 연산을 발생시키기 때문에 브라우저의 성능이 낮아지는 문제가 있음
          Server : 서버사이드 렌더링을 채택해도, DOM조작이 이뤄질때마다 Rendering 될 HTML을 매번 보내야 하니 트래픽이 장난 아닌 문제가 발생함...


- React의 대답
   : 이 모든것을 가능하게 하기위해 불가피하게 JSX(JS extension)이라는 XHP에 기반한 확장자를 사용하게 됨
      -> 결론적으로 React를 SPA구조의 웹앱이 많이 쓰는 이유는 component, State, Props 개념을 통해 만들어낸 Virtual DOM 방식이 가장 효율을 발휘하는 방식이 SPA(Single Page Aplication) 형식의 구조이기 때문으로 요약 가능

        1. component 개념을 통한 HTML element를 JS 객체화시키고 관리, 재사용이 수월한 모듈화 시킴
            -> 이를 통해 사용자는 완성된 component를 일종의 블록처럼 사용해서, 페이지의 일부로서 재사용이 쉬워지고 약간의 수정도 용이해짐
        	   (= 사용자가 작성한 코드의 재사용이 쉬워졌다는건, 프로그램 내부로직을 구성하는데 있어 Component가 유용할 수 있는 포텐셜이 있음을 의미함)
        
        2. JS변수를 그대로 data binding 할 수 있는 {}문법을 통해, DOM조작 없이 쉽게 브라우저가 값의 변화에 반응하여 화면을 뿌리는 반응형 프로그래밍을 구현 가능  
        	   
        3. {}의 개념이 State, Props 변수 개념과 결합하여, 프로그래머가 데이터의 흐름을 쉽게 이해하고 통제하기 쉽게 만듦
            -> 전역변수 개념없이 각 웹페이지에만 통용되는 props와 그 props의 값을 초기화한 값을 시작으로 현재 component의 변수들의 값을 변경하는 state를 통해 디버깅이 쉬워지고, 데이터 흐름 이해가 쉬워짐 
        	    -> 과거의 이벤트 핸들러를 통한 DOM과 JS변수의 동시 처리는 이제 신경끄고, 변수처리는 State, Props만 다뤄서 생각하면 그만..
        	   
        4. (중요) Virtual DOM의 도입 (component, State, Props 개념을 활용, 더 효율적인 HTML 랜더링을 수행하여 성능과 무의미한 트래픽 발생을 방지함)
            -> Rendering 과정을 high-level적인 interface형식으로 제작
        	    : 이제 사용자 입장에서는 HTML을 원하는 형식으로 랜더링 하기 위해서, 직접 DOM을 이렇게 저렇게 조작해라 할 필요가 없음
        		   -> 정확히는 각 React.component의 후손인 각 component들이 선조 클래스의 render 함수를 override하게 되는데, 
        		      사용자가 State, Props를 사용한 HTML 요소를 각 component의 render 함수의 return에 작성하면?
        		       -> 런타임 환경에서 State, Props이 변하는게 감지되는 순간 Virtual DOM이 이를 감지하고 변화한 HTML내용에 맞춰 Rendering 함
        			   
                  # 함수형 component가 사용되는 현재는 각 component의 render함수를 직접 override하는 형식이 아니라..
        		     -> 각 component와 그 안의 state들을 HTML 태그와 속성처럼 작성한 형식을 parameter로 넣은 ReactDOM 클래스의 render 함수를 실행하는 형식으로 변경
        	
            -> State, Props이나 웹페이지 변화가 감지되어 Rendering을 다시할 때, 이전 DOM과 현재 DOM트리의 내용을 비교하고 변화가 감지된 부분만 재 Rendering함
               (= DOM트리의 각 파트인 component의 존재로 인해 변경 이전과 이후의 DOM트리 구조에 대한 비교가 가능해졌기에, 내용이 같은 부분까지 다시 rendering을 할 필요 X)
        		   -> 이를 통해, 상호작용이 많더라도 딱 필요한 부분만 데이터를 가져오고 Render하기에 서버의 트래픽 문제나 웹페이지 성능에 대한 부담이 떨어짐
		   

# Virtual DOM의 작동 로직
  1. 실질적으로 웹페이지의 DOM트리를 다시 rendering 하는 트리거는 State, Props의 변화와 웹페이지의 이동으로만 한정하도록 함
      -> 이로써, 사용자들이 아무리 무리한 조작을 해도, State, Props의 변화와 웹페이지의 이동이 일어나기 전까지는 서버에 어떤 부하도 일어나지 않음
  2. rendering을 다시 해야할 상황이 오면, 이전 DOM트리와 변화예정 DOM트리 구조를 비교하여, 변화할 부분만 다시 Rendering 대상으로 잡고 서버로부터 HTML 데이터를 받아서 그 부분만 처리함
      -> 이로써, 정말 필요한 부분에만 서버는 데이터를 보낼 수 있고, 클라이언트 측도 DOM트리 rendering과 관련된 연산을 정기적으로 딱 필요한 부분에만 수행할 수 있기에 양쪽에 모두 이득이 됨
	  

- React를 쓰는 이유 결론

1. 단방향적으로 접근 및 변경이 되는 State, Props 변수 개념이 예측이나 디버깅을 쉽게 해줌
2. 직관적인 반응형 프로그래밍을 구현 (= 따라서 더 이상 사용자는 DOM트리의 내용을 일일히 세부적으로 조작할 필요없이, ㅈ으로 말해도 척하고 알아서 반응하는 웹페이지를 만들수 있게됨)
    -> State, Props가 rendering을 위한 트리거 역할을 해주기에하게 함
    -> component가 rendering을 수행하는 기본단위이기에 모듈화를 적용하여 개발편의성이 올라감 + 한번 선언(Declare)하면 State, Props와 연계되어 알맞은 형태로 변화함
3. Virtual DOM을 통해, 불필요한 rendering 과정을 전부 쳐내고 진짜 필요한 내용만 다시 랜더링 할 수 있기에, 서버나 클라이언트나 서로 할일이 줄어들면서 할건 다 하는 마법을 보여줄 수 있음